<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/" class="post-title-link" itemprop="url">restful风格API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-10 16:07:24 / 修改时间：16:43:20" itemprop="dateCreated datePublished" datetime="2021-02-10T16:07:24+08:00">2021-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>REST – REpresentational State Transfer直译：表现层状态转移。</strong></p>
<p>全称是Resource Representational State Transfer：通速来讲就是资源在网络中以某种表现形式进行状态转移。分解开来：</p>
<p>Resource:资源，即数据。比如newsfeed，friends等；</p>
<p>Representational:某种表现形式，比如用json、xml、jpeg等；</p>
<p>State Transfer：状态变化，通过http动词实现。</p>
<p><strong>为什么用RESTful结构呢？</strong></p>
<p>大家都知道”古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。</p>
<p><img src="https://img-blog.csdn.net/20171107171036253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>从原理角度来分析：</strong></p>
<p>根据Richardson Maturity Model（理查德森成熟度模型）, REST架构的成熟度有4个等级：</p>
<p><img src="https://img-blog.csdn.net/20171107165849966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>Level 0-面向前台</strong></p>
<p>我们在咖啡店向前台点了一杯拿铁，这个过程可以用这段文字来描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡，接着，前台给我们返回这么一串回复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="number">447031335</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询卡号为447031335的卡的余额，查询的结果返回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;balance&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没钱……<br>哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level 1-面向资源</strong></p>
<p>现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。<br>比如还是下单，请求的内容不变，但是我们多了一条消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个斜杠和orders，这是什么意思？<br>这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作。<br>接着还是会返回订单的编号给我们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们还是要查询会员卡余额，这次请求的资源变成了cards：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="string">&quot;447031335&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level2 -打上标签</strong></p>
<p>接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求。<br>其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示，修改用PATCH表示。<br>来，我们再来重复上面那个过程，来一杯拿铁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增，返回的内容还是一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是查询会员卡余额，这次也简化了很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;447031335&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个请求我们还可以进一步优化为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /cards/<span class="number">447031335</span></span><br></pre></td></tr></table></figure>

<p>直接把要查询的卡号写在后面了。<br>没错，接着，取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>Level 3 -完美服务</strong></p>
<p>忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/&#123;orderId&#125;</span><br></pre></td></tr></table></figure>

<p>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……后面两人吵着吵着还打了起来…<br>噗，真是悲剧…<br>有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这次返回时多了些内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;link&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;rel&quot;</span>: <span class="string">&quot;cancel&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/order/123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了。<br>Level3的Restful API，给使用者带来了很大的遍历，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。<br>现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，这个模型并不是一种规范，只是用来理解Restful的工具。所以，做到了Level2，也就是面向资源和使用Http动词，就已经很Restful了。</p>
<p><strong>Levels的意义</strong></p>
<p>Level1解释了如何通过分治法（Divide and Conquer）来处理复杂问题，将一个大型的服务端点（Service Endpoint）分解成多个资源。</p>
<p>Level 2引入了一套标准的动词，用来以相同的方式应对类似的场景，移除不要的变化。</p>
<p>Level 3引入了可发现性（Discoverability），它可以使协议拥有自我描述（Self-documenting）的能力。</p>
<p><strong>从应用角度来分析：</strong></p>
<p>一、REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计RESTful API;</p>
<p>二、Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。</p>
<p>URL定位资源，用HTTP动词（GET，POST，DELETE，DETC）描述操作。</p>
<p>1、看Url就知道要什么<br>2、看http method就知道干什么<br>3、看http status  code就知道结果如何</p>
<p><a target="_blank" rel="noopener" href="http://api.qc.com/v1/newsfeed">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;</p>
<p>三、用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：</p>
<p>GET用来获取资源</p>
<p>POST用来新建资源</p>
<p>PUT用来更新资源</p>
<p>DELETE用来删除资源</p>
<p>比如：<br>DELETE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 删除某人的好友 （在http parameter指定好友id）<br>POST <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 添加好友<br>UPDATE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 更新个人资料</p>
<p>四、Server和Client之间传递某资源的一个表现形式，比如用json，xml传输文本，或者用jpg，webP传输图片等。当然还可以压缩HTTP传输时的数据。</p>
<p>五、用HTTP Status Code传递Server的状态信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">java并发volatile关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 14:00:00 / 修改时间：18:29:13" itemprop="dateCreated datePublished" datetime="2021-02-08T14:00:00+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>摘要：</strong>在java并发编程中，要想使并发程序能够正确地执行，必须要保证三条原则，即：原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致运行不正确。volatile关键字被用来保证可见性，即保证共享变量的内存可见性解决缓存一致性问题。一旦一个共享变量被volatile关键字修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。在多线程环境下，volatile关键字主要用于及时感知共享共享变量的修改，并使得其他线程可以立即得到变量的最新值，例如，用于修饰状态标记量和Double-Check中。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与内存模型紧密相关，因此在讲述volatile关键字之前，我们有必要先去了解与内存模型相关的概念和知识，然后回头再分析volatile关键字的实现原理，最后再给出volatile关键字的使用场景。</p>
<h2 id="一、内存模型的相关概念"><a href="#一、内存模型的相关概念" class="headerlink" title="一、内存模型的相关概念"></a>一、内存模型的相关概念</h2><p>由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。</p>
<p>也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行这个语句时，会先从主存当中读取 i 的值，然后复制一份到高速缓存当中，然后CPU执行指令对 i 进行加1操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如，同时有两个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。</p>
<p>最终结果i的值是1，而不是2.这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，<strong>如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 \</strong>缓存不一致** 的问题。**</p>
<p>为了解决缓存不一致性问题，在 <strong>硬件层面</strong> 上通常来说有以下两种解决方法：</p>
<p>　　1）通过在 <strong>总线加 LOCK# 锁</strong> 的方式 <strong>（在软件层面，效果等价于使用 synchronized 关键字）</strong>；</p>
<p>　　2）通过 <strong>缓存一致性协议</strong> <strong>（在软件层面，效果等价于使用 volatile 关键字）</strong>。</p>
<p>在早期的CPU当中，是通过在总线上加Lock锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问，从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中，如果一个线程在执行i=i+1，如果在执行这段代码的过程中，在总线上发出了LOCK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i的所在的内存读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以，就出现了缓存一致性协议，其中最出名的就是Intel的MESI协议。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的吃变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。因此，当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="二、并发编程中的三个概念"><a href="#二、并发编程中的三个概念" class="headerlink" title="二、并发编程中的三个概念"></a>二、并发编程中的三个概念</h2><p>原子性问题、可见性问题、有序性问题</p>
<p>1、原子性</p>
<p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>银行转账的例子</p>
<p>2、可见性</p>
<p>可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>3、有序性</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 int型 变量，定义了一个 boolean型 变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1 是在 语句2 前面的，那么 JVM 在真正执行这段代码的时候会保证 语句1 一定会在 语句2 前面执行吗？不一定，为什么呢？这里可能会发生 <strong>指令重排序（Instruction Reorder）</strong>。</p>
<p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。</p>
<p>比如上面的代码中，语句1 和 语句2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中， 语句2 先执行而 语句1 后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>那么可不可能是这个执行顺序呢： 语句2　-&gt;　语句1　-&gt;　语句4　-&gt;　语句3</p>
<p>　　答案是不可能，因为处理器在进行重排序时会考虑指令之间的 <strong>数据依赖性</strong>，如果一个指令 Instruction 2 必须用到 Instruction 1 的结果，那么处理器会保证 Instruction 1 会在 Instruction 2 之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面，看一个例子：</p>
<p>虽然 <strong>重排序不会影响单个线程内程序执行的结果</strong>，但是多线程呢？下面，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 语句1 和 语句2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在 线程1 执行过程中先执行 语句2，而此时 线程2 会以为初始化工作已经完成，那么就会跳出 while循环 ，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，<strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="三、java内存模型"><a href="#三、java内存模型" class="headerlink" title="三、java内存模型"></a>三、java内存模型</h2><p><strong>在 Java虚拟机规范 中，试图定义一种 *Java内存模型（Java Memory Model，JMM）* 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</strong>那么，Java内存模型 规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在 Java内存模型 中，也会存在缓存一致性问题和指令重排序的问题。</strong></p>
<p>java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>　　执行线程必须先在自己的工作线程中对 变量i 所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。那么，Java语言本身对原子性、可见性以及有序性 提供了哪些保证呢？</p>
<p>1、原子性</p>
<p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的：要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子，请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>乍一看，有些朋友可能会说上面的四个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是线程执行这个语句的会直接将数值10写入到工作内存中；</p>
<p>语句2实际上包含两个操作，它先要去读取x的值，再将x的值写入工作内存。虽然，读取x的值以及将x的值写入工作内存这两个操作都是原子性操作，但是合起来就不是原子性操作了；</p>
<p>同样的，x++和x=x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以，上面四个语句只有语句1的操作具备原子性。也就是说，只有简单的读取，赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过，这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p>2、可见性</p>
<p>对于可见性，java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronzied和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修饰刷新到主存当中，因此可以保证可见性。</p>
<p>3、有序性</p>
<p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在java中，可以通过volatile关键字来保证一定的“有序性”。另外，我们千万不能想当然地认为，可以通过synchronized和Lock来保证有序性，也就是说，不能由于synchonized和Lock可以让线程串行地同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 <strong>happens-before 原则</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>先行发生原则：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测代中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ul>
<h2 id="四、深入剖析volatile关键字"><a href="#四、深入剖析volatile关键字" class="headerlink" title="四、深入剖析volatile关键字"></a>四、深入剖析volatile关键字</h2><p>1、volatile关键字的两层语义</p>
<p>一旦一个共享变量被volatile修饰后，那么就具备了两层语义：</p>
<p><strong>1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 \</strong>立即可见** 的；**</p>
<p><strong>2）禁止进行指令重排序。</strong></p>
<p>先看一段代码，假如 线程1 先执行，线程2 后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p><img src="https://img-blog.csdn.net/20170116141631367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程读取数据模型"></p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，如上图所示，每个线程在运行过程中都有自己的工作内存，那么 线程1 在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么，当 线程2 更改了 stop变量 的值之后，可能会出现以下两种情形：</p>
<ul>
<li>线程2对变量的修改没有立即刷入到主存当中；</li>
<li>即使线程2对变量的修改立即反映到主存中，线程1也可能由于没有立即知道线程2对stop变量的更新而一直循环下去。</li>
</ul>
<p>这两种情形都会导致线程1处于死循环。但是，用volatile关键字修饰后就变得不一样了，如下图所示：</p>
<p>1、使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>2、使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；</p>
<p>3、由于线程1的工作内存中缓存变量stop的缓存行无效，所以，线程1再次读取变量stop的值时会去主存读取。</p>
<p>综上，<strong>在 线程2 修改 stop 值时（当然这里包括两个操作，修改 线程2 工作内存中的值，然后将修改后的值写入内存），会使得 线程1 的工作内存中缓存变量 stop 的缓存行无效，然后 线程1 读取时，会发现自己的缓存行无效从而去对应的主存读取最新的值 。**</strong>简化一下，通过使用 volatile 关键字，如下图所示，线程会及时将变量的新值更新到主存中，并且保证其他线程能够立即读到该值。**这样，线程1 读取到的就是最新的、正确的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java数组综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 11:45:40 / 修改时间：13:59:39" itemprop="dateCreated datePublished" datetime="2021-02-08T11:45:40+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、要点概览"><a href="#一、要点概览" class="headerlink" title="一、要点概览"></a>一、要点概览</h2><ul>
<li>数组与容器</li>
<li>数组的创建与初始化</li>
<li>数组与泛型</li>
<li>数组与可变参数列表</li>
<li>Arrays工具类的使用功能</li>
</ul>
<h2 id="二、数组与容器"><a href="#二、数组与容器" class="headerlink" title="二、数组与容器"></a>二、数组与容器</h2><p>早期java数组的几个特点：</p>
<ul>
<li><p>效率</p>
<p>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。由于ArrayList可以实现空间的自动分配且更为灵活，所以，通常应首选ArrayList而不是数组，但是ArrayList的效率比数组低的多。</p>
</li>
<li><p>类型</p>
<p>在 JDK 1.5 之前，Java 并未引进泛型。所以，泛型之前的容器类在处理对象时，都将它们视作没有任何具体类型，即将这些对象都当作 Object 来处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体的类型。这意味着你可以通过编译期的类型检查来防止插入错误类型和抽取不当类型。当然，无论在编译时还是运行时，Java都会阻止你向对象发送不恰当的消息。所以，并不是说哪种方法更不安全，只是若编译时就能够指出错误，会显得更为优雅。</p>
</li>
<li><p>保存基本类型的能力</p>
<p>数组可以持有基本类型，而泛型之前的容器则不能。JDK1.5之后，java引进了泛型和自动包装机制，这使得现在的容器除了性能之外的各个方面都使得数组相形见绌。</p>
</li>
</ul>
<h2 id="三、数组的创建与初始化"><a href="#三、数组的创建与初始化" class="headerlink" title="三、数组的创建与初始化"></a>三、数组的创建与初始化</h2><p>1、数组基础</p>
<ul>
<li>数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用或基本类型的值；</li>
<li>对象数组保存的是引用，基本类型数组直接保存基本类型的值；</li>
<li>“[]”语法是访问数组对象的唯一方式；</li>
</ul>
<p>2、创建与初始化</p>
<ul>
<li><p>作为数组初始化的一部分隐式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=&#123;...&#125;;	<span class="comment">//花括号内对象的个数就是数组大小</span></span><br><span class="line">System.out.println(strs.length);	<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用new表达式显式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=<span class="keyword">new</span> String[<span class="number">5</span>];	<span class="comment">//创建方式2</span></span><br><span class="line">String[] ss = <span class="keyword">new</span> String[]&#123;...&#125;;	<span class="comment">//创建方式3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3、多维数组</p>
<p>多维数组的本质：数组的元素仍是数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方式 1</span></span><br><span class="line"><span class="keyword">int</span>[][] a = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;, </span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;, </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式 2</span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//粗糙数组：每个向量具有任意长度</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-D array with varied-length vectors: </span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123; </span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)][]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) </span><br><span class="line">        a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="四、数组与泛型"><a href="#四、数组与泛型" class="headerlink" title="四、数组与泛型"></a>四、数组与泛型</h2><ul>
<li><p>数组与泛型不能很好的结合，也就是说，不能实例化具有参数化类型的数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[] first = <span class="keyword">new</span> T[<span class="number">3</span>];    <span class="comment">// ERROR  </span></span><br><span class="line">A&lt;String&gt;[] arrays = <span class="keyword">new</span> A&lt;String&gt;[<span class="number">4</span>];    <span class="comment">// ERROR: Cannot create a generic array of A&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以创建泛型数组引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;String&gt;[] arrays;	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组是协变的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs=<span class="keyword">new</span> String[<span class="number">3</span>];	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>总之，泛型容器总是比泛型数组更好的选择。</p>
<h2 id="五、数组与可变参数类型"><a href="#五、数组与可变参数类型" class="headerlink" title="五、数组与可变参数类型"></a>五、数组与可变参数类型</h2><p>1、可变参数类型概念</p>
<p>Java SE5 添加了可变参数类型 ( Variable Argument Type )，形式为 “Type… args”，<strong>只可用作方法的参数</strong>。<strong>可变参数列表适用于参数个数不确定但类型确定的情形 ( java 把可变参数当做数组处理 )。</strong>特别需要注意的是，<strong>可变参数列表必须位于最后一项 (即最多只支持一个可变参数)。</strong>当可变参数列表个数多余一个时，必将有一个不是最后一项，所以只支持一个可变参数。因为可变参数列表的参数个数不确定，所以当其后边还有相同类型参数时，Java 无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();  </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1   </span></span><br><span class="line"><span class="comment">        1 2 3   </span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~  </span></span><br></pre></td></tr></table></figure>

<p>可变参数列表具有以下特点：</p>
<ul>
<li>只能出现在方法参数列表的最后；</li>
<li>…位于变量类型和变量名之间，前后有无空格都可以；</li>
<li>调用可变参数所在的方法时，编译器会为该可变参数隐式创建一个数组，从而我们可以在方法体中以数组的形式访问可变参数列表。</li>
</ul>
<p>2、可变参数类型与数组的兼容性</p>
<ul>
<li>编译器认为数组类型和可变参数类型是相同的，即二者不能重载；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//ERROR : Duplicate method dealArray(int[]) in type TestVarArgus </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();   </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>可变参数是兼容数组类型参数的，但是数组类型参数却无法兼容可变参数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 1 ： 给参数为可变参数类型的方法传递数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line"></span><br><span class="line">        dealArray(intArray);  <span class="comment">// OK</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 2 ： 给参数为数组类型的方法传递可变参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// ERROR</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其实，对于示例代码 2 而言，只是需要一个定义为 dealArray(int, int, int）的方法或者一个定义为 dealArray(int… ）的方法。所以，自然就无法去匹配具有数组类型的参数 dealArray( int[] ) 方法了。</p>
<ul>
<li>参数匹配原则：能匹配定长的方法，那么优先匹配该方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//含有不定参数的那个重载方法是最后被选中的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bad&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> count2)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bingo&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">    dealArray(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">        Bingo </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Arrays工具类的实用功能"><a href="#六、Arrays工具类的实用功能" class="headerlink" title="六、Arrays工具类的实用功能"></a>六、Arrays工具类的实用功能</h2><p>1、复制数组</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Introduction</th>
<th>Note</th>
</tr>
</thead>
<tbody><tr>
<td>System.arraycopy(<strong>Object src,</strong> int srcPos, <strong>Object dest,</strong> int destPos, int length)</td>
<td>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</td>
<td>若复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝(浅复制)；<strong>该方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确切类型；**</strong>须明确自行新建立一个数组对象，作为副本**</td>
</tr>
<tr>
<td>copyOf(T[] original, int newLength)</td>
<td>复制指定的数组，<strong>截取或用 null 填充</strong></td>
<td><strong>底层调用的还是 System.arraycopy；返回一个新的数组对象，若新数组的长度超过原数组的长度，则保留数组默认值</strong></td>
</tr>
</tbody></table>
<p>注意</p>
<p>对于以上两个方法：</p>
<ul>
<li>若赋值对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝；</li>
<li>这两个方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确认类型。</li>
</ul>
<p>2、数组的字符串方式表示</p>
<p>方法：Arrays.toString(Object[] a)    //Arrays.deepToString(Object[] a)</p>
<p>作用：返回指定数组内容字符串表示形式：前者适用于一维数组，或者适用于多维数组</p>
<p>3、数组的比较</p>
<p>方法：Arrays.equals(Object[] a, Object[] a2)    //deepEquals(Object[] a, Object[] a2)</p>
<p>作用：比较两个数组：元素类型相同，元素个数相等，对应位置的元素相同；</p>
<p>注意：</p>
<ul>
<li>通过对每个元素使用equals()作比较来判断；</li>
<li>对于基本类型，使用的是基本类型的包装器类的equals()方法；</li>
<li>使用equals()方法比较原则：是不是同一个对象，是不是同一个类型，是不是具有相同的内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line">Arrays.fill(a1, <span class="number">47</span>); </span><br><span class="line">Arrays.fill(a2, <span class="number">47</span>); </span><br><span class="line">print(Arrays.equals(a1, a2));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>4、数组的排序</p>
<p>使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组进行排序，只要该对象实现了Comparable接口或具有相关联的Comparator。</p>
<p><strong>方法：</strong> Arrays.sort(Object[] a) / Arrays.sort(Object[] a, int fromIndex, int toIndex)<br>　　　Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) / Arrays.sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> <strong>对数组内元素进行升序排序 (默认)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = Generated.array(<span class="keyword">new</span> String[<span class="number">20</span>], <span class="keyword">new</span> RandomGenerator.String(<span class="number">5</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 String 内置的比较器（已实现 Comparable 接口）：字典序（大写字母开头的词都放在前面输出，之后才是小写字母开头的词）</span></span><br><span class="line">Arrays.sort(sa);   <span class="comment">// ... ,WHkjU, YNzbr, bkIna, cQrGs, ...</span></span><br><span class="line">.</span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： Collections.reverseOrder() ： 现有顺序的逆序</span></span><br><span class="line">Arrays.sort(sa, Collections.reverseOrder()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： String.CASE_INSENSITIVE_ORDER : 忽略大小写将单词一起进行排序</span></span><br><span class="line">Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); </span><br></pre></td></tr></table></figure>

<p>5、在已排序的数组中查找</p>
<p><strong>若数组已经 \</strong>排好序*<em>，就可以使用该方法执行快速查找；*</em>若对未排序的数组使用该方法，将产生不可预料的结果。****</p>
<p><strong>方法：</strong> binarySearch(Object[] a, Object key) / binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> 使用 <strong>二分搜索法</strong> 来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的自然顺序对数组进行<strong>升序排序（通过 sort(Object[]) 方法）</strong>; 使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过 sort(T[], Comparator) 方法）对数组进行<strong>多态**</strong>升序排序**。</p>
<p>注意：</p>
<ul>
<li>对已经有序的数组进行查找；</li>
<li>若找到了目标，方法返回的值不小于0；否则，它产生的负返回值表示在此排序下应插入的位置；</li>
<li>“sort(Object[])” 与 “binarySearch(Object[] a, Object key)” 对应，“sort(T[], Comparator)” 与 binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) 对应。</li>
</ul>
<p><strong>若数组包含重复元素，则该方法无法保证找到的是哪一个元素；若需要对无重复元素的数组进行排序，可使用 TreeSet(保持排序顺序) 或 LinkedHashSet(保持插入顺序)进行排序。除非它们成为程序的瓶颈，否则不需要自己维护数组。</strong></p>
<p>6、填充数组</p>
<p><strong>方法：</strong> fill(Object[] a, Object val)<br><strong>作用：</strong> <strong>只能使用同一个值填充各个位置，而针对对象而言，就是复制同一个对象的引用进行填充</strong></p>
<p>7、数组与容器的转化</p>
<p><strong>方法：</strong> asList(T… a)<br><strong>作用：</strong> 返回一个 <strong>受指定数组支持的固定大小的列表</strong><br><strong>注意：</strong></p>
<ul>
<li>所得到的 List 是固定大小的，因为<strong>其底层表示即为该数组，因此不能调整大小。</strong>因此，调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException (可选操作)。</li>
<li>因此，<strong>Arrays.asList() 的真正意义在于：将其结果作为构造器参数传递给任何 Collection （或者使用 addAll 方法、Collections.addAll 静态方法），这样可以生成一个动态的容器。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java异常模型综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 16:28:12 / 修改时间：20:28:49" itemprop="dateCreated datePublished" datetime="2021-02-04T16:28:12+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、异常的引入及基础"><a href="#一、异常的引入及基础" class="headerlink" title="一、异常的引入及基础"></a>一、异常的引入及基础</h2><p>发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间编译器并不能找出所有的错误，余下的错误只有在运行期才能发现和解决，这类错误就是 <strong>Throwable。</strong> 这就需要错误源能够通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确的处理这个问题，这就是Java的错误报告机制 —— 异常机制。该机制使得程序把 <strong>在正常执行过程中做什么事的代码</strong> 与 <strong>出了问题怎么办的代码</strong> 相分离。</p>
<p>在对异常的处理方面，Java 采用的是 <strong>终止模型</strong> 。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。相对于终止模型，另一种异常处理模型为 <strong>恢复模型</strong>，它使异常被处理之后能够继续执行程序。虽然该模型很吸引人，但不是很实用，其主要原因是它所导致的耦合：恢复性处理程序需要了解异常的抛出地点，这势必要包含依赖于抛出位置的非通用代码，从而大大增加了代码编写和维护的难度。</p>
<p>在异常情形中，异常的抛出伴随着以下三件事的发生：</p>
<ul>
<li>首先，同java中其他对象的创建一样，将使用new在堆上创建异常对象；</li>
<li>其次，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用；</li>
<li>最后，异常处理机制接管程序，并开始寻找对应的异常处理程序，并将程序从错误状态中恢复。</li>
</ul>
<h2 id="二、java标准异常"><a href="#二、java标准异常" class="headerlink" title="二、java标准异常"></a>二、java标准异常</h2><p>1、基本概念</p>
<p><img src="https://img-blog.csdn.net/20160916105959789" alt="这里写图片描述"></p>
<p>- <strong>Throwable：所有的异常类型的根类</strong></p>
<p>　　在 Java 中，<strong>Throwable 是所有的异常类型的根类。</strong>Throwable 有两个直接子类：<strong>Exception</strong> 和 <strong>Error</strong>。二者都是 Java 异常处理的重要子类，各自都包含大量子类。<br>　<br>- <strong>Error：程序本身无法处理的错误</strong></p>
<p>　　<strong>Error 是程序无法处理的错误，表示运行应用程序中较严重问题。</strong>这些错误大部分与代码编写者执行的操作无关，而与代码运行时的 JVM 、资源等有关。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<strong>这些错误是不可查的，并且它们在应用程序的控制和处理能力之外。</strong>在 Java 中，错误通过Error的子类描述。</p>
<ul>
<li><p><strong>Exception：程序本身可以处理的错误</strong></p>
<p>　　Exception 通常是Java程序员所关心的，其在Java类库、用户方法及运行时故障中都可能抛出。它由两个分支组成： <strong>运行时异常（派生于 RuntimeException 的异常）</strong> 和 <strong>其他异常</strong> 。<strong>划分这两种异常的规则是：由程序错误（一般是逻辑错误，如错误的类型转换、数组越界等，应该避免）导致的异常属于RuntimeException；而程序本身没有问题，但由于诸如I/O这类错误（eg：试图打开一个不存在的文件）导致的异常就属于其他异常。</strong></p>
</li>
</ul>
<hr>
<p>此外，Java的异常(包括Exception和Error)通常可分为 <strong>受检查的异常（checked exceptions）</strong> 和 <strong>不受检查的异常（unchecked exceptions）</strong> 两种类型。</p>
<ul>
<li><p><strong>不受检查异常：派生于 Error 或 RuntimeException 的所有异常</strong></p>
<p>　　<strong>不可查异常是编译器不要求强制处理的异常</strong>，包括运行时异常（RuntimeException与其子类）和错误（Error）。也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
</li>
<li><p><strong>受检查异常：除去不受检查异常的所有异常</strong></p>
<p>　　<strong>受检查异常是编译器要求必须处理的异常。</strong>这里所指的处理方式有两种： <strong>捕获并处理异常</strong> 和<strong>声明抛出异常</strong> 。也就是说，当程序中可能出现这类异常，要么用 try-catch 语句捕获它，要么用 throws 子句声明抛出它，否则编译不会通过。</p>
</li>
<li><p><strong>准则：**</strong>如果程序出现RuntimeException异常，那么一定是程序员的问题**</p>
</li>
<li><p><strong>异常和错误的区别：</strong>异常能被程序本身处理，错误则无法处理</p>
</li>
</ul>
<h2 id="三、java异常处理机制"><a href="#三、java异常处理机制" class="headerlink" title="三、java异常处理机制"></a>三、java异常处理机制</h2><p>1、异常处理</p>
<p>在java应用程序中，异常处理机制为：抛出异常与捕获异常。</p>
<p><strong>抛出异常：</strong>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处理异常的代码并执行。</p>
<p><strong>捕获异常：</strong>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常地方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着java程序的终止。</p>
<hr>
<p>对于运行时异常、错误或受检查的异常，java技术所要求的异常处理方式有所不同：</p>
<ul>
<li><p>由于<strong>运行时异常是不受检查的</strong>，Java规定：运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常；</p>
</li>
<li><p>对于<strong>方法运行中可能出现的Error</strong>，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error是不可恢复的，也属于合理的应用程序不该捕捉的异常；</p>
</li>
<li><p>对于<strong>所有受检查的异常</strong>，Java规定：异常必须被捕捉，或者进行异常说明。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常；</p>
<p>　　任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的 throw 语句抛出异常。</p>
<p>　　<strong>总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error。</strong></p>
</li>
</ul>
<p>2、异常说明</p>
<p>对于受检查异常而言，java提供了相应的语法，使你能告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> TooBig, TooSmall, DivZero </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>表示方法f可能会抛出TooBig，TooSmall，DivZero三种异常，而</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;... ...&#125;</span><br></pre></td></tr></table></figure>

<p>表示方法g不会抛出任何异常</p>
<p>代码必须与异常说明保持一致。若方法中的代码产生了受检查异常却没有进行处理，编译器就会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中表明此方法产生异常。不过，我们可以声明方法将抛出异常，但实际上并不抛出。</p>
<p>3、捕获异常</p>
<p><strong>监控区域：</strong>它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码，由try…catch…子句实现。</p>
<p>（1）try子句</p>
<p>​    如果方法内部抛出了异常，这个方法将在抛出异常的过程中结束。若不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。其中，在这个块里，尝试各种方法调用的部分称为try块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>(2) catch子句-异常处理程序</p>
<p>抛出的异常必须得到处理，而且针对每个要捕获的异常，都必须准备相应的异常处理程序。异常处理程序必须紧跟在try块之后，以catch关键字表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 id1)|&#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type1 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 id2) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type2 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type3 id3) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type3 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>异常处理程序可能用不到标识符（id1,id2,…），因为异常的类型本身就已经给出了足够的信息来处理异常，但标识符不可省。<strong>当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入对应的catch自居执行，此时认为异常得到处理。一旦catch子句结束，则处理程序的查找结束</strong>（与 switch…case…不同）。</p>
<p>特别需要注意的是：</p>
<ul>
<li>异常匹配原则：抛出异常时，异常处理系统会按照代码的书写顺序找出最近匹配的处理程序。一旦找到，它就认为异常将得到处理，然后停止查找；</li>
<li>不可屏蔽派生类异常：捕获基类异常的catch子句必须放在捕获其派生类异常的catch子句之后，否则编译不会通过；</li>
<li>catch子句必须与try子句连用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">java的抽象特性：抽象类与接口深度解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 15:47:32 / 修改时间：16:24:10" itemprop="dateCreated datePublished" datetime="2021-02-04T15:47:32+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>要点</strong></p>
<ul>
<li>抽象类</li>
<li>接口</li>
<li>抽象类与接口的区别</li>
</ul>
<h2 id="一、抽象"><a href="#一、抽象" class="headerlink" title="一、抽象"></a>一、抽象</h2><p>对于面向对象编程来说，抽象是它的四大特征之一。在java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。接口和抽象类为我们提供了一种将接口与实现分离的更加结构化的方法。</p>
<h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h2><p>1）概念基础</p>
<p>所有的对象都是通过类来描述的，但是并不是所有的类都是可以描述对象（对象=状态+行为）的。如果一个类没有足够的信息来描述一个具体的对象，那么我们就可以将这样的类设为抽象类。抽象类只能被public和默认修饰符修饰。</p>
<p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰 <strong>(特别需要注意的是，抽象类也可以不包含抽象方法，即其中所有的方法都是具体方法)**。</strong>因为抽象类中含有未具体实现的方法，所以不能用抽象类创建对象。**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就称为abstract类了。</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要三点区别：</p>
<ul>
<li>抽象方法不能是private的，否则，其不能被子类继承，子类也无法实现该方法，从而这样做没有任何意义；</li>
<li>抽象类不能用来创建对象</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</li>
</ul>
<p>2）本质</p>
<ul>
<li>抽象类与具体类的唯一区别：含有抽象方法的类一定是抽象类；</li>
<li>抽象类的根本作用是为了继承，所以抽象类的抽象方法不能被private修饰；</li>
<li>抽象类比具体类仅多一点抽象因素：行为层面的抽象（可以包含抽象方法）；</li>
</ul>
<h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><p>1）概念基础</p>
<p>接口（interface），在软件工程中，接口泛指别人调用的方法或者函数。它是对行为的抽象。接口只能被public和默认修饰符修饰。在java中，定义一个接口的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口中可以含有 变量和方法。</strong>但是要注意，接口中的 <strong>变量</strong> 会被隐式地指定为 <strong>public static final变量（并且只能是public static final变量，\</strong>而且 public static final 可省，即默认就是public static final 的）*<strong>* ，而 <strong>方法</strong> 会被隐式地指定为 <strong>public abstract方法且只能是 public abstract 方法\</strong>（public abstract 可省，即默认就是 public abstract 的）**</strong>，<strong>并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</strong>从这里可以隐约看出接口和抽象类的区别，<strong>接口是一种极度抽象的类型，它比抽象类更加“抽象”。</strong></p>
<p>要让一个类遵循某组特地的接口需要使用 <strong>implements</strong> 关键字，具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<p>2）本质</p>
<ul>
<li>接口是一种行为契约，是对行为的抽象；</li>
</ul>
<h2 id="四、接口与抽象类的区别"><a href="#四、接口与抽象类的区别" class="headerlink" title="四、接口与抽象类的区别"></a>四、接口与抽象类的区别</h2><p>1、语法层面上的区别</p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract（可省）方法；</li>
<li>抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法、而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161210225212635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>2、设计层面上的区别</p>
<p>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。</strong>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它可以跨越不同的类，是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说 <strong>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</strong></p>
<p>门和警报的例子：门都有open()和close()两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>
<p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>
<p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>
<p>　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、小结</p>
<ul>
<li>抽象类是对一种事物的抽象，接口是对行为的抽象；</li>
<li>抽象类是一种模板，接口是一种契约</li>
<li>抽象类的抽象程序介于普通类和接口之间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">java原生类型与包装器类型深度剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 10:04:19 / 修改时间：15:46:20" itemprop="dateCreated datePublished" datetime="2021-02-04T10:04:19+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>要点：</strong></p>
<ul>
<li>原生类型与包装器类型</li>
<li>字面值概念和种类</li>
<li>基本类型、自动转型与强制转型</li>
<li>自动装箱与拆箱机制（Autoboxing and Unboxing）</li>
</ul>
<h2 id="一、原生类型与包装器类型"><a href="#一、原生类型与包装器类型" class="headerlink" title="一、原生类型与包装器类型"></a>一、原生类型与包装器类型</h2><p>八种基本数据类型</p>
<p>注意：</p>
<ul>
<li>未带有字符串标识的整数默认为int类型，未带有字符串后缀标识的浮点数默认为double类型；</li>
<li>只有byte，char，short，int四种基本类型纪其包装类可以用于switch语句（只有enum类型和int类型可以应用到switch），其他类型编译会报错；</li>
<li>char(两个字节)可以用单引号标识单个字符（可以是汉字），如：‘良’，‘A’；</li>
<li>整数可以由二进制（以0B/0b开头）、八进制（以0开头的整数）、十进制、十六进制表示；</li>
</ul>
<h2 id="二、字面值"><a href="#二、字面值" class="headerlink" title="二、字面值"></a>二、字面值</h2><p>字面值大体上可以分为整型字面值、浮点型字面值、字符串字面值、特殊字面值四种。</p>
<p>1、整型字面值</p>
<ul>
<li>整型字面值可以使用十进制、十六进制、八进制和二进制来表示。当然，基数不能超出进制的范围。</li>
<li>一般情况下，字面值创建的是int类型，但是int字面值可以赋值给byte、short、char、long和int。当然，前提是字面值在目标范围以内(java会自动完成转换)；如果试图将超出范围的字面值赋给某一类型，编译通不过，需要强制类型转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b0 = <span class="number">128</span>;       <span class="comment">// Type mismatch: cannot convert from int to byte</span></span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">12</span>;       <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">byte</span> b2 = (<span class="keyword">byte</span>)<span class="number">300</span>；<span class="comment">// OK 需要强制转换，但表示的数字是截取后的数字（300二进制为100101100，截取后为00101100，即44）</span></span><br><span class="line"><span class="keyword">char</span> c0 = <span class="number">5</span>;       <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="keyword">char</span>(-<span class="number">3</span>);       <span class="comment">// 编译通过,但打印值为 ？（char 为无符号的）</span></span><br><span class="line">System.out.println(c1);   <span class="comment">// ？</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建long类型，需要在字面值最后面加上L或者l。整型字面值包括int字面值和long字面值两种。</li>
<li>java中，字符字面值用单引号括起来。</li>
</ul>
<p>2、浮点字面值</p>
<p>浮点字面值简单的理解可以理解为小数，分为float字面值和double字面值。默认为double类型，如果在小数后面加上F或者f，则表示是个float字面值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">10</span>；     <span class="comment">// OK，自动类型转换</span></span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">11.4</span>;    <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">1.23E3</span>;    <span class="comment">// OK  </span></span><br><span class="line"><span class="keyword">double</span> d4 = <span class="number">10D</span>;    <span class="comment">// OK  </span></span><br><span class="line"><span class="keyword">double</span> d5 = <span class="number">0.4D</span>;     <span class="comment">// OK </span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">10</span>;      <span class="comment">// OK，自动类型转换</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">11.1F</span>;      <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">11.1</span>;      <span class="comment">// Type mismatch: cannot convert from double to float</span></span><br></pre></td></tr></table></figure>

<p>3、字符及字符串字面值</p>
<p>java中字符字面值用单引号括起来，如‘@’，‘1’。字符串字面值使用双引号，字符串字面值中同样可以包含字符字面值中的转义字符序列。</p>
<p>4、特殊字面值</p>
<p>null是一种特殊的类型（type），可以将它赋给任何引用类型变量，表示这个变量不引用任何东西。如果一个引用类型变量为null，表示这个变量不可用。</p>
<p>还有一种特殊的class literal，用type name加上.class表示，例如String.class。class literal用于表示类型本身。</p>
<h2 id="三、自动转型与强制转型"><a href="#三、自动转型与强制转型" class="headerlink" title="三、自动转型与强制转型"></a>三、自动转型与强制转型</h2><p>1、自动转型</p>
<p>自动转型总原则：byte,short，char（同级）-&gt;int-&gt;long-&gt;float-&gt;double（由低精度到高精度）</p>
<ul>
<li><p>从位数低的类型向位数高的类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">c = b;  <span class="comment">// Error，同级</span></span><br><span class="line">c = s;  <span class="comment">// Error，同级</span></span><br><span class="line">s = c;  <span class="comment">// Error，同级</span></span><br><span class="line">i = c;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从整型向浮点型的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d=<span class="number">1</span>;</span><br><span class="line">f=i;	<span class="comment">//OK</span></span><br><span class="line">f=t;	<span class="comment">//OK</span></span><br><span class="line">d=f;	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2、运算符对基本类型的影响</p>
<p>1）当使用+,-,*,/,%,==,&gt;,&lt;等等运算符对基本类型进行运算时，遵循如下规则：</p>
<p>​    两个操作数中，先考虑吧是否有一个是double类型的。如果有，另一个操作数和结果将会转换成double类型。再依次考虑float，long。除此之外，两个操作数都将会被转换成int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">10</span> ;  <span class="comment">//OK，会检查发现10没有超过byte类型的最大值</span></span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">12</span>;   <span class="comment">//OK，会检查发现12没有超过byte类型的最大值</span></span><br><span class="line"><span class="keyword">byte</span> b = b1 + b2; <span class="comment">//Error，byte类型在计算时会自动提升为int类型，此时就会报错，因为b1+b2实际上是int类型，但是左侧的变量为byte类型。</span></span><br><span class="line"><span class="keyword">short</span> s1=<span class="number">1</span>; <span class="comment">//OK，会检查发现1没有超过short类型的最大值</span></span><br><span class="line">s1=s1+<span class="number">1</span>;    <span class="comment">//Error，因为s1+1 结果int，但左侧变量为 short，报错</span></span><br><span class="line">s1++;      <span class="comment">//OK，不会报错，与s1=s1+1不同！！！，会检查发现2没有超过short类型的最大值</span></span><br><span class="line">s1=<span class="number">1</span>+<span class="number">1</span>;   <span class="comment">//OK，1+1 是个编译时可以确定的常量，&#x27;+&#x27;运算在编译时就被执行了，而不是在程序执行的时候，这个语句的效果等同于s1=2</span></span><br></pre></td></tr></table></figure>

<p>2）当使用+=，-=,*=,/=,%=,i++,++i运算符对基本类型进行运算时，遵循如下规则：</p>
<p><strong>运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</strong>自增(减)运算也类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1=<span class="number">1</span>; <span class="comment">// OK，会检查发现1没有超过short类型的最大值</span></span><br><span class="line"><span class="keyword">short</span> s2;</span><br><span class="line"></span><br><span class="line">s1+=<span class="number">1</span>;    <span class="comment">// OK，正确，1首先被强制转换为short型，然后再参与运算，并且结果也是short类型</span></span><br><span class="line"></span><br><span class="line">s2 = ++s1;     <span class="comment">// OK，正确，s2的值为2</span></span><br></pre></td></tr></table></figure>

<p>2、强制转型</p>
<p>​    强制转型的格式是在需要转型的数据前加上“（）”，然后在括号内加入需要转化的数据类型。主要发生以下两种情形：</p>
<ul>
<li>由高精度向低精度转换</li>
<li>一种类型到另一种类型转换，则必须使用强制类型转化（同级之间：byte，short,char）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> t = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>;</span><br><span class="line">i = (<span class="keyword">int</span>) f;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">t = (<span class="keyword">long</span>) f;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">b = (<span class="keyword">byte</span>) i;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">i = b; <span class="comment">// OK，由低精度向高精度转换，自动转型</span></span><br><span class="line">System.out.println(c==s);  <span class="comment">// OK，true，c 和 s 自动转型为int,然后比较</span></span><br><span class="line">b = (<span class="keyword">byte</span>) s;  <span class="comment">// OK，一种类型到另一种类型转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) b;  <span class="comment">// OK，一种类型到另一种类型转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) s;   <span class="comment">// OK，一种类型到另一种类型转换</span></span><br></pre></td></tr></table></figure>

<p>特别需要注意的是，强制转换常常会导致二进制位的截取，甚至会导致意想不到的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">System.out.println(b);           <span class="comment">// -128(即-0)</span></span><br></pre></td></tr></table></figure>

<h2 id="四、自动装箱与拆箱（Autoboxing-and-Unboxing）"><a href="#四、自动装箱与拆箱（Autoboxing-and-Unboxing）" class="headerlink" title="四、自动装箱与拆箱（Autoboxing and Unboxing）"></a>四、自动装箱与拆箱（Autoboxing and Unboxing）</h2><p>1、什么是装箱？什么是拆箱？</p>
<p>java为每种基本数据类型都提供了对应的包装器类型。在java SE5之前，如果要创建一个数值为10的Integer对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>而从java SE5之后就提供了自动装箱的特性，如果要创建一个数值为10的Integer对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个过程会自动根据数值创建对应的Integer对象，这就是装箱。</p>
<p>那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i=<span class="number">10</span>;	<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n=i;	<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>2、装箱和拆箱是如何实现的</p>
<p>上一小节了解装箱的基本概念之后，这一小节来了解一下装箱和拆箱是如何实现的。我们就以Integer类为例，下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</p>
<p>对于其他的包装器类，比如Double、Character，也同样适用。</p>
<p>因此，可以用一句话总结装箱和拆箱的实现过程；</p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的（xxx代表对应的基本数据类型）。</p>
<p>3、valueOf、xxxValue方法在JDK中的实现</p>
<p>（1）在Byte、Charater、Short、Integer、Long中的实现（以Integer为例）</p>
<ul>
<li>public static Integer valueOf(int i): 类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;                                         <span class="comment">// 静态代码块  </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Use Long.decode here to avoid invoking methods that</span></span><br><span class="line">                <span class="comment">// require Integer&#x27;s autoboxing cache to be initialized</span></span><br><span class="line">                <span class="keyword">int</span> i = Long.decode(integerCacheHighPropValue).intValue();</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - -low);</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)                      <span class="comment">// 初始化  </span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会被自动调用：如果整型字面值在[-128,127]之间，便返回IntegerCache.cache中已经存在的对象的引用；否则，创建一个新的Integer对象并返回。</p>
<ul>
<li><p>public int intValue():实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Integer对象会自动调用其intValue方法，返回该对象对应的int值。</p>
</li>
</ul>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">        System.out.println(i1==i2);          <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3==i4);          <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在Float、Double中的实现（以Double为例）</p>
<ul>
<li><p>public static Double valueOf(double d):  类方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会自动调用，从而创建相应的Double对象并返回。</p>
</li>
<li><p>public int intValue()：实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Double对象会自动调用其doubleValue方法，返回该对象对应的double值。</p>
</li>
</ul>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Double i1=<span class="number">100.0</span>;</span><br><span class="line">        Double i2=<span class="number">100.0</span>;</span><br><span class="line">        Double i3=<span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现呢？原因很简单，在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<p>（3）在Boolean中的实现</p>
<ul>
<li>public static Boolean valueOf(boolean b): 类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会被自动调用，从而创建相应的Boolean对象并返回。</p>
<ul>
<li><p>public boolean booleanValue():实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Boolean对象会自动调用其booleanValue方法，返回该对象对应的boolean值。</p>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(i1==i2);          <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3==i4);          <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，有限可列举，共享[-128,127];</li>
<li>Double、Float的valueOf方法的实现是类似的，无限不可列举，不共享；</li>
<li>Boolean的valueOf方法的实现不同于以上的整型和浮点型，只有两个值，有限可列举，共享；</li>
</ul>
</li>
</ul>
<p>4、Integer i = new Integer(xxx)和Integer i=xxx；的区别</p>
<ul>
<li>第一种方式不会触发自动装箱的过程，而第二种方式会触发；</li>
<li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下（[-128,127]）要优于第一种情况（注意这并不是绝对的）。</li>
</ul>
<p>5、“==”运算符</p>
<p>当使用“==”运算符在基本类型和其包装类型对象之间比较时，涉及到自动装箱、拆箱机制，遵循如下规则：</p>
<p>1）、只要两个操作数中有一个是基本类型或表达式，就是比较它们的数值是否相等。</p>
<p>2）、否则，就是判断这两个对象的内存地址是否相等，即是否是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i01=<span class="number">59</span>;</span><br><span class="line">        <span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">        Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">        Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line">        System.out.println(i01==i02);  <span class="comment">// true，拆箱</span></span><br><span class="line">        System.out.println(i01==i03);  <span class="comment">// true，同一对象</span></span><br><span class="line">        System.out.println(i03==i04);  <span class="comment">// false，不同对象</span></span><br><span class="line">        System.out.println(i02==i04);  <span class="comment">// true，拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(c==d);  <span class="comment">// true</span></span><br><span class="line">        System.out.println(e==f);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(c==(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(g==(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a+b));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a+h));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个和第二个输出结果没有什么疑问；</li>
<li>第三个打印语句由于 a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等；</li>
<li>对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较；</li>
<li>对于g==(a+b)，会分别触发 Integer 和 Long 的自动拆箱过程，<strong>然后 int 自动转为 long</strong>，进行比较；</li>
<li>对于g.equals(a+b)，最终会归结于 Long对象与Integer对象的比较，由于二者不为同一类型，直接返回 false ;</li>
<li>对于g.equals(a+h)，最终会归结于 Long对象与Long对象的比较，由于 -128 &lt;= 3 &lt;= 127, 二者为同一对象，直接返回 true 。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/" class="post-title-link" itemprop="url">java String综述2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 10:29:46" itemprop="dateCreated datePublished" datetime="2021-02-02T10:29:46+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-03 19:09:03" itemprop="dateModified" datetime="2021-02-03T19:09:03+08:00">2021-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="六、字符串常量池"><a href="#六、字符串常量池" class="headerlink" title="六、字符串常量池"></a>六、字符串常量池</h2><p>字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(str1==str2);	<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个初始为空的字符串池，它由类String私有地维护。当以字面值形式创建一个字符串时，总是先检查字符串池是否含存在该对象，若存在，则直接返回。此外，通过new操作符创建的字符串对象不指向字符串池中的任何对象。</p>
<p>2、手动入池</p>
<p>​    一个初始为空的字符串池，它由类String私有地维护。当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。特别地，手动入池遵循以下规则：</p>
<p>​    对于任意两个字符串s和t，当且仅当s.equals(t)为true时，s.intern() == t.intern()才为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String str3 = s2.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println( str1 == str2 );   <span class="comment">//false</span></span><br><span class="line">        System.out.println( str1 == str3 );   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于String str1=“abc”，str1引用的是常量池（方法区）的对象；而String str2=new String(“abc”)，str2引用的是堆中的对象，所以内存地址不一样。但是由于内容一样，所以str1和str3指向同一对象。</p>
<p>3、实例</p>
<p>1）情景一：字符串常量池</p>
<p>Java虚拟机（JVM）中存在着一个字符串常量池，其中保存着很多String对象，并且这些String对象可以被共享使用，因此提高了效率。之所以字符串具有字符串常量池，是因为String对象是不可变的，因此可以被共享。字符串常量池由String类维护，我们可以通过intern()方法使字符串池手动入池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 在字符串池创建了一个对象  </span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s2 : &quot;</span>+(s1==s2));    </span><br><span class="line"><span class="comment">//↑ true 指向同一个对象，  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2)));    </span><br><span class="line"><span class="comment">//↑ true  值相等  </span></span><br></pre></td></tr></table></figure>

<p>2）情景二：关于new String(“…”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 创建了两个对象，一个存放在字符串池中，一个存在与堆区中；  </span></span><br><span class="line"><span class="comment">//↑ 还有一个对象引用s3存放在栈中  </span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3 == s4 : &quot;</span>+(s3==s4));  </span><br><span class="line"><span class="comment">//↑false   s3和s4栈区的地址不同，指向堆区的不同地址；  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4)));  </span><br><span class="line"><span class="comment">//↑true  s3和s4的值相同  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s3 : &quot;</span>+(s1==s3));  </span><br><span class="line"><span class="comment">//↑false 存放的地区都不同，一个方法区，一个堆区  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3)));  </span><br><span class="line"><span class="comment">//↑true  值相同 </span></span><br></pre></td></tr></table></figure>

<p>通过new String(“…”)来创建字符串时，在该构造函数的参数值为字符串字面值的前提下，若该字面值不在字符串常量池中，那么会创建两个对象：一个在字符串常量池中，一个在堆中；否则，只会在堆中创建一个对象。对于不在同一区域的两个对象，二者的内存地址必定不同。</p>
<p>3）情景三：字符串连接符“+”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;ab&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str3 = <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象                                         </span></span><br><span class="line">String str4 = str2+str3;                                        </span><br><span class="line">String str5 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;str4 = str5 : &quot;</span> + (str4==str5)); <span class="comment">// false  </span></span><br></pre></td></tr></table></figure>

<p>局部变量str2，str3指向字符串常量池中的两个对象。在运行时，第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</p>
<p>　(1). 调用 String 类的静态方法 <strong>String.valueOf()</strong> 将 str2 转换为字符串表示；</p>
<p>　(2). JVM 在堆中创建一个 StringBuilder对象，同时用str2指向转换后的字符串对象进行初始化；　</p>
<p>　(3). 调用StringBuilder对象的append方法完成与str3所指向的字符串对象的合并；</p>
<p>　(4). 调用 StringBuilder 的 toString() 方法在堆中创建一个 String对象；</p>
<p>　(5). 将刚刚生成的String对象的堆地址存赋给局部变量引用str4。</p>
<p>而引用str5指向的是字符串常量池中字面值”abcd”所对应的字符串对象。由上面的内容我们可以知道，引用str4和str5指向的对象的地址必定不一样。这时，内存中实际上会存在五个字符串对象： 三个在字符串常量池中的String对象、一个在堆中的String对象和一个在堆中的StringBuilder对象。</p>
<p>4）情景四：字符串的编译期优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str11 = <span class="string">&quot;abcd&quot;</span>;   </span><br><span class="line">System.out.println(<span class="string">&quot;str1 = str11 : &quot;</span>+ (str1 == str11));   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">final</span> String str8 = <span class="string">&quot;cd&quot;</span>;  </span><br><span class="line">String str9 = <span class="string">&quot;ab&quot;</span> + str8;  </span><br><span class="line">String str89 = <span class="string">&quot;abcd&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str9 = str89 : &quot;</span>+ (str9 == str89));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">//↑str8为常量变量，编译期会被优化  </span></span><br><span class="line">String str6 = <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">String str7 = <span class="string">&quot;a&quot;</span> + str6;  </span><br><span class="line">String str67 = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str7 = str67 : &quot;</span>+ (str7 == str67));     <span class="comment">// false</span></span><br><span class="line"><span class="comment">//↑str6为变量，在运行期才会被解析。</span></span><br></pre></td></tr></table></figure>

<p>java编译器对于类似“常量+字面值”的组合，其值在编译的时候就能够被确定了。在这里，str1和str9的的值在编译时就可以被确定，因此它们分别等价于：String str1=”abcd”；和String str9=”abcd”；</p>
<p>java编译器对于含有“String”引用的组合，则在运行期会产生新的对象（通过调用StringBuilder类的toString()方法），因此这个对象存储在堆中。</p>
<p>4、小结</p>
<ul>
<li>使用字面值形式创建的字符串与通过new创建的字符串一定是不同的，因为二者的存储位置不同：前者在方法区，后者在堆；</li>
<li>我们在使用诸如String str=”abc”；的格式创建字符串对象时，总是想当然地认为，我们创建了String类的对象str。但是事实上，对象可能并没有被创建。唯一可以肯定的是，指向String对象的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑；</li>
<li>字符串常量池的理念是享元模式；</li>
<li>java编译器对“常量+字面值”的组合是当成常量表达式直接求值来优化的；对于含有”String 引用”的组合，其在编译期不能被确定，会在运行期创建新对象。</li>
</ul>
<h2 id="七、三个字符串类"><a href="#七、三个字符串类" class="headerlink" title="七、三个字符串类"></a>七、三个字符串类</h2><p>1、String与StringBuilder</p>
<p>简要的说， <strong>String 类型 和 StringBuilder 类型的主要性能区别在于 String 是不可变的对象。</strong> 事实上，在对 String 类型进行“改变”时，实质上等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。由于频繁的生成对象会对系统性能产生影响，特别是当内存中没有引用指向的对象多了以后，JVM 的垃圾回收器就会开始工作，继而会影响到程序的执行效率。所以，<strong>对于经常改变内容的字符串，最好不要声明为 String 类型</strong>。但如果我们使用的是 StringBuilder 类，那么情形就不一样了。因为，我们的每次修改都是针对 StringBuilder 对象本身的，而不会像对String操作那样去生成新的对象并重新给变量引用赋值。所以，<strong>在一般情况下，推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下</strong>。</p>
<p>在某些特别情况下，String对象的字符串拼接可以直接被JVM在编译期确定下来，这时StringBuilder在速度上就不占任何优势了。</p>
<p>因此，在绝大部分情况下，在效率方面：StringBuilder&gt;String</p>
<p>2、StringBuffer与StringBuilder</p>
<p>首先需要明确的是，StringBuffer 始于 JDK 1.0，而 StringBuilder 始于 JDK 5.0；此外，从 JDK 1.5 开始，对含有字符串变量 (非字符串字面值) 的连接操作(+)，JVM 内部是采用 StringBuilder 来实现的，而在这之前，这个操作是采用 StringBuffer 实现的。</p>
<p>　　<strong>JDK的实现中 StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder。</strong>AbstractStringBuilder的实现原理为：AbstractStringBuilder中采用一个 <strong>char数组</strong> 来保存需要append的字符串，char数组有一个初始大小，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是 <strong>2</strong> 倍。</p>
<p>　　<strong>StringBuffer 和 StringBuilder 都是可变的字符序列，但是二者最大的一个不同点是：StringBuffer 是线程安全的，而 StringBuilder 则不是。StringBuilder 提供的API与StringBuffer的API是完全兼容的，即，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，但是后者一般要比前者快。**</strong>因此，可以这么说，StringBuilder 的提出就是为了在单线程环境下替换 StringBuffer 。**</p>
<p>　　在单线程环境下，优先使用 StringBuilder。</p>
<p>3、实例</p>
<p>1）编译时优化与字符串连接符的本质</p>
<p>先来看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2 + s3;</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量s的创建等价于String s=”abc”；而变量s4的创建相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder(s1);</span><br><span class="line">temp.append(s2).append(s3);</span><br><span class="line">String s4 = temp.toString();</span><br></pre></td></tr></table></figure>

<p>但事实上，是不是这样子呢？我们将其反编译一下，来看看Java编译器究竟做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将上述 Test2 的 class 文件反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;            <span class="comment">// 编译期优化</span></span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//底层使用 StringBuilder 进行字符串的拼接</span></span><br><span class="line">        String s4 = (<span class="keyword">new</span> StringBuilder(String.valueOf(s1))).append(s2).append(s3).toString();   </span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的反编译结果，很好的印证了我们在第六节中提出的字符串连接符的本质。</p>
<p>2）另一个例子：字符串连接符的本质</p>
<p>由上面的分析结果，我们不难推断出 String 采用连接运算符（+）效率低下原因分析，形如这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            s+=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被编译器编译为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            s = (<span class="keyword">new</span> StringBuilder(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，每做一次 字符串连接操作 “+” 就产生一个 StringBuilder 对象，然后 append 后就扔掉。下次循环再到达时，再重新 new 一个 StringBuilder 对象，然后 append 字符串，如此循环直至结束。事实上，如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 <strong>N - 1</strong> 次创建和销毁对象的时间。所以，<strong>对于在循环中要进行字符串连接的应用，一般都是用StringBulider对象来进行append操作。</strong></p>
<h2 id="八、字符串与正则表达式：匹配、替换与验证"><a href="#八、字符串与正则表达式：匹配、替换与验证" class="headerlink" title="八、字符串与正则表达式：匹配、替换与验证"></a>八、字符串与正则表达式：匹配、替换与验证</h2><p>正则表达式：</p>
<p><strong>用一个字符串来描述一个特征，然后去验证另一个字符串是否符合这个特征。</strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。 Java 内置了对正则表达式的支持，其相关的类库在 java.util.regex 包下</p>
<p>1、java转义与正则表达式转义</p>
<p>要想匹配某些特殊字符，比如 “\”，需要进行两次转义，即Java转义与正则表达式转义。对于下面的例子，需要注意的是，split()函数的参数必须是“正则表达式”字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a\\b&quot;</span>;</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>2、使用Pattern与Matcher构造功能强大的正则表达式对象</p>
<p>Pattern与Matcher的组合就是Java对正则表达式的主要内置支持，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;.\\\\.&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;a\\b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.matches());</span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    a\b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="九、String与（深）克隆"><a href="#九、String与（深）克隆" class="headerlink" title="九、String与（深）克隆"></a>九、String与（深）克隆</h2><p>1、克隆的定义与意义</p>
<p>克隆就是制造一个对象的副本。一般地，根据所要克隆的对象的成员变量中是否含有引用类型，可以将克隆分为两种：浅克隆（Shallow Clone）和深克隆（Deep Clone），默认情况下使用Object中的clone方法进行克隆就是浅克隆，即完成对象域对域的拷贝。</p>
<p>（1）Object中的clone()方法</p>
<p><img src="https://img-blog.csdn.net/20170313093548412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在使用clone()方法时，若该类未实现 Cloneable 接口，则抛出 java.lang.CloneNotSupportedException 异常。下面我们以Employee这个例子进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆完成...&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        ~Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: P1_1.Employee</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>(2).Cloneable接口</p>
<p>Cloneable接口是一个标识性接口，即该接口不包含任何方法，但是如果一个类想合法的进行克隆，那么就必须实现这个接口。JDK描述如下：</p>
<ul>
<li>A class implements the Cloneable interface to indicate to the java.lang.Object.clone() method that it is <strong>legal</strong> for that method to make a field-for-field copy of instances of that class.</li>
<li><strong>Invoking Object’s clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown.</strong></li>
<li>By convention, classes that implement this interface should <strong>override</strong> Object.clone (which is protected) with <strong>a public method</strong>.</li>
<li><strong>Note that this interface does *not* contain the clone() method.</strong> Therefore, it is not possible to clone an object merely by virtue of the fact that it implements this interface. Even if the clone method is invoked reflectively, there is no guarantee that it will succeed.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Clone与Copy</p>
<p>假设现在有一个Employee对象，Employee tobby = new Employee(“CMTobby”,5000)，<strong>通常, 我们会有这样的赋值Employee tom=tobby，这个时候只是简单了copy了一下reference</strong>，tom 和 tobby 都指向内存中同一个object，这样tom或者tobby对对象的修改都会影响到对方。打个比方，如果我们通过tom.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。如果我们希望得到tobby所指向的对象的一个精确拷贝，同时两者互不影响，那么我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法</p>
<p>3、Shallow Clone与Deep Clone</p>
<p>Clone是如何完成的呢？Object中的clone()方法在对某个对象实施克隆时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了，以Employee为例，它里面有一个域hireDay不是基本类型的变量，而是一个reference变量，经过Clone之后克隆类只会产生一个新的Date类型的引用，它和原始引用都指向同一个 Date 对象，这样克隆类就和原始类共享了一部分信息，显然这种情况不是我们愿意看到的</p>
<p>这个时候，我们就需要进行 Deep Clone 了，以便对那些引用类型的域进行特殊的处理，例如本例中的hireDay。我们可以重新定义 clone方法，对hireDay做特殊处理，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       Employee cloned = (Employee) <span class="keyword">super</span>.clone();  </span><br><span class="line">       <span class="comment">// Date 支持克隆且重写了clone()方法，Date 的定义是：</span></span><br><span class="line">       <span class="comment">// public class Date implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;</span></span><br><span class="line">       cloned.hireDay = (Date) hireDay.clone() ;   </span><br><span class="line">       <span class="keyword">return</span> cloned;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>因此，Object 在对某个对象实施 Clone 时，对其是一无所知的，它仅仅是简单执行域对域的Copy。 其中，对八种基本类型的克隆是没有问题的，但当对一个引用类型进行克隆时，只是克隆了它的引用。因此，克隆对象和原始对象共享了同一个对象成员变量，故而提出了深克隆 ： 在对整个对象浅克隆后，还需对其引用变量进行克隆，并将其更新到浅克隆对象中去。</strong></p>
<p>4、一个克隆的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Employee </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((hireDay == <span class="keyword">null</span>) ? <span class="number">0</span> : hireDay.hashCode());</span><br><span class="line">        result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        temp = Double.doubleToLongBits(salary);</span><br><span class="line">        result = prime * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee other = (Employee) obj;</span><br><span class="line">        <span class="keyword">if</span> (hireDay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.hireDay != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hireDay.equals(other.hireDay))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.doubleToLongBits(salary) != Double</span><br><span class="line">                .doubleToLongBits(other.salary))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; : &quot;</span> + String.valueOf(salary) + <span class="string">&quot; : &quot;</span> + hireDay.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类 Manger </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manger</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String edu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manger</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay, String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, hireDay);</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEdu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdu</span><span class="params">(String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getSalary() + <span class="string">&quot; : &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.getHireDay() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getEdu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">super</span>.hashCode();</span><br><span class="line">        result = prime * result + ((edu == <span class="keyword">null</span>) ? <span class="number">0</span> : edu.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(obj))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manger other = (Manger) obj;</span><br><span class="line">        <span class="keyword">if</span> (edu == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.edu != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!edu.equals(other.edu))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Manger manger = <span class="keyword">new</span> Manger(<span class="string">&quot;Rico&quot;</span>, <span class="number">20000.0</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;NEU&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        Manger clonedManger = (Manger) manger.clone();</span><br><span class="line">        <span class="comment">// 输出克隆的manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象的克隆对象 = &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象和其克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改、输出manger</span></span><br><span class="line">        manger.setEdu(<span class="string">&quot;TJU&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原克隆对象= &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象和原克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象的克隆对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象和其克隆对象是否相等：  true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        修改后的Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : TJU</span></span><br><span class="line"><span class="comment">        原克隆对象= Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        修改后的Manger对象和原克隆对象是否相等：  false</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>5、Clone()方法的保护机制</p>
<p>　<strong>在Object中clone()是被申明为 \</strong>protected** 的，这样做是有一定的道理的。**以 Employee 类为例，如果我们在Employee中重写了protected Object clone()方法， ，就大大限制了可以“克隆”Employee对象的范围，即可以保证只有在和Employee类在同一包中类及Employee类的子类里面才能“克隆”Employee对象。进一步地，如果我们没有在Employee类重写clone()方法，则只有Employee类及其子类才能够“克隆”Employee对象。</p>
<p>6、注意事项</p>
<p>Clone()方法的使用比较简单，注意以下几点：</p>
<ul>
<li><p>什么时候使用shallow Clone，什么时候使用deep Clone？</p>
<p>这个主要看具体对象的域是什么性质的，基本类型还是引用类型</p>
</li>
<li><p>调用Clone()方法的对象所属的类(Class)必须实现Clonable接口，否则在调用Clone方法的时候会抛出CloneNotSupportedException；</p>
</li>
<li><p>所有数组对象都实现了Clonable接口，默认支持克隆；</p>
</li>
<li><p>如果我们实现了Clonable接口，但没有重写Object类的clone方法，那么执行域对域的拷贝；</p>
</li>
<li><p>明白String在克隆中的特殊性</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/java-String%E7%BB%BC%E8%BF%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/java-String%E7%BB%BC%E8%BF%B01/" class="post-title-link" itemprop="url">java String综述1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-01 15:45:06 / 修改时间：20:37:34" itemprop="dateCreated datePublished" datetime="2021-02-01T15:45:06+08:00">2021-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、java内存模型与常量池"><a href="#一、java内存模型与常量池" class="headerlink" title="一、java内存模型与常量池"></a>一、java内存模型与常量池</h2><p>1、java内存模型</p>
<ul>
<li><p>程序计数器</p>
<p>多线程时，当线程数超过CPU数量或CPU内核数量，线程之间就要根据时间片轮询抢夺CPU时间资源。因此，每个线程要有一个独立的程序计数器，记录下一条要运行的指令，其为线程私有的内存区域。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。</p>
</li>
<li><p>虚拟机栈</p>
<p>线程私有的，与线程在同一时间创建，是管理java方法执行的内存模型。栈中主要存放一些基本类型的变量数据（int,short,long,byte,float,double,boolean,char）和对象引用。每个方法执行时都会创建一个帧栈来存储方法的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。使用jclasslib工具可以查看class类文件的结构。</p>
</li>
<li><p>本地方法区</p>
<p>和虚拟机栈功能相似，但管理的不是java方法，是本地方法，本地方法是用C实现的。</p>
</li>
<li><p>java堆</p>
<p>线程共享的，存放所有对象实例和数组，是垃圾回收的主要区域。堆是一个运行时数据区，类的对象从中分配空间，这些对象通过new、newarray，anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆可以分为新生代和老年代（tenured）。新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。新生代又可进一步细分为eden、survivorSpace0、survivorSpace1(s1,tospace)。刚创建的对象都放入eden，s0和s1都至少经过一次GC并幸存。如果幸存对象经过一定实践仍存在，则进入老年代（tenured）。</p>
</li>
<li><p>方法区</p>
<p>线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码，也成为永久代。如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收。</p>
</li>
</ul>
<p>2、常量池</p>
<p>常量池属于类信息的一部分，而类信息反映到JVM内存模型中对应于方法区，也就是说，常量池位于方法区。常量池主要存放两大常量：字面量（Literal）和符号引用（Symbolic ）。其中，字面量主要包括字符串字面量，整型字面量和声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h2 id="二、常量与变量"><a href="#二、常量与变量" class="headerlink" title="二、常量与变量"></a>二、常量与变量</h2><ul>
<li><p>一般把内存地址不变，值可以改变的东西称为变量，换句话说，在内存地址不变的前提下内存的内容是可变的，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Human_1 h =<span class="keyword">new</span> Human_1(<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">        Human_1 h2=h;</span><br><span class="line">        System.out.printf(<span class="string">&quot;h: %s\n&quot;</span>,h.toString());</span><br><span class="line">        Syytem.out.printf(<span class="string">&quot;h2: %s\n\n&quot;</span>,h.toString());</span><br><span class="line">        h.id=<span class="number">3</span>;</span><br><span class="line">        h.age=<span class="number">32</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;h:%s\n&quot;</span>,h.toString());</span><br><span class="line">        System.out.printf(<span class="string">&quot;h2:%s\n\n&quot;</span>,h.toString());</span><br><span class="line">        </span><br><span class="line">        System.out.println(h==h2);	<span class="comment">//引用值不变，即对象内存底子不变，但内容改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般把若内存地址不变，则值也不可以改变的东西称为常量，典型的String就是不可变的，所以称之为常量（constant）。此外，我们可以通过final关键字来定义常量，但严格来说，只有基本类型被其修饰后才是常量（对基本类型来说是其值不可变，而对于对象变量来说其引用不可再变）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、String定义与基础"><a href="#三、String定义与基础" class="headerlink" title="三、String定义与基础"></a>三、String定义与基础</h2><ol>
<li><p>String的声明</p>
<p>由JDK中关于String的声明可以知道：</p>
<ol>
<li>不同字符串可能共享同一个底层char数组，例如字符串String s=”abc”与s.substring(1)就共享同一个char数组：char[] c={‘a’,’b’,’c’}。其中，前者的offset和count的值分别为0和3，后者的offset和count的值分别为1和2.</li>
<li>offset和count两个成员变量不是多余的，比如，在执行substring操作时。</li>
</ol>
</li>
<li><p>JDK中关于String的描述</p>
<p>The String class represents character Strings. All string literals(字符串字面值) in java programs, such as “abc”, are implemented as instances of this class. Strings are constant(常量); their values cannot be changed after they are created. String buffers[StringBuilder OR StringBuffer] support mutable strings. Because String objects are immutable, they can be shared(享元模式).</p>
</li>
<li><p>String类所内置的操作</p>
<p>The class String includes methods for examining individual characters of the sequence, for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode standard version specified by the java.lang.Character class.</p>
</li>
</ol>
<p>4、字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持</p>
<p>　　The Java language provides special support for the <strong>string concatenation operator (+)</strong>, and for conversion of other objects to strings. String concatenation is implemented through the <strong>StringBuilder(JDK1.5 以后) OR StringBuffer(JDK1.5 以前)</strong> class and <strong>its append method</strong>. String conversions(转化为字符串) are implemented through the method <strong>toString</strong>, defined by class Object and inherited by all classes in Java.</p>
<p>注意：</p>
<ul>
<li><p>String不属于八种基本数据类型，String的实例是一个对象。因为对象的默认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其他对象没有的一些特性(String的不可变性导致其像八种基本类型一样，比如，作为方法参数时，像基本类型的传值效果一样)。例如，以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String s=str;</span><br><span class="line">        str+=<span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        changeStr(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        1234</span></span><br><span class="line"><span class="comment">        1234 </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new String()和new String(“”都是声明一个新的空字符串)，是空串不是null；</p>
</li>
</ul>
<h2 id="四、String的不可变性"><a href="#四、String的不可变性" class="headerlink" title="四、String的不可变性"></a>四、String的不可变性</h2><p>1、什么是不可变对象？</p>
<p>众所周知，在java中，String类是不可变类（基本类型的包装类都是不可改变的）的典型代表，也是Immutable设计模式的典型应用。String变量一旦初始化后就不能更改，禁止改变对象的状态，从而增加共享对象的坚固性、减少对象访问的错误，同时还避免了在多线程共享时进行同步的需要。什么是不可变的对象呢？可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态指的是不能改变对象内的成员变量，包括：</p>
<ul>
<li>基本数据类型的值不能改变；</li>
<li>引用类型的变量不能指向其他的对象；</li>
<li>引用类型指向的对象的状态也不能改变；</li>
</ul>
<p>除此之外，还应具有以下特点：</p>
<ul>
<li>除了构造函数之外，不应该有其他任何函数（至少是任何public函数）修改任何成员变量；</li>
<li>任何使成员变量获得新值的函数都应该将新的值保存在新的对象中，而保持原来的对象不被修改。</li>
</ul>
<p>2、区分引用和对象</p>
<p>对于java初学者，对于String是不可变对象总是存有疑惑。看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);    <span class="comment">// s = ABCabc</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);    <span class="comment">// s = 123456</span></span><br></pre></td></tr></table></figure>

<p>首先创建了一个String对象s，然后让s的值为”ABCabc“，然后又让s的值为”1234560“。从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？其实这里存在一个误区：s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。也就是说，s只是一个引用，它指向了一个具体的对象，当s=”123456”；这句代码执行过之后，又创建了一个新的对象”123456“，而引用s重新指向了这个心的对象，原来的对象”ABCabc”还在内存中存在，并没有改变。</p>
<p>Java和C++的一个不同点是，<strong>在 Java 中，引用是访问、操纵对象的唯一方式： 我们不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身</strong>，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。其实，Java中的引用和C++中的指针在概念上是相似的，他们都是存放的对象在内存中的地址值，只是在Java中，引用丧失了部分灵活性，比如Java中的引用不能像C++中的指针那样进行加减运算。</p>
<p>3、为什么String对象是不可变的？</p>
<p>在JDK1.6中，String的成员变量有以下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">string</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0&lt;/string&gt;</span></span><br></pre></td></tr></table></figure>

<p>在JDK1.7中，String类做了一些改动，主要是改变了substring方法执行时的行为，这和本文的主题不相关。JDK1.7中String类的主要成员变量就剩下了两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">string</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0&lt;/string&gt;</span></span><br></pre></td></tr></table></figure>

<p>在java中，String类其实就是对字符数组的封装。JDK6中，value是String封装的数组，offset是String在这个value数组中的起始位置，count是String所占的字符的个数。在JDK7中，只有一个value变量，也就是value中的所有字符都是属于String这个对象的。这个改变不影响本文的讨论。除此之外还有一个hash成员变量，是该String对象的哈希值的缓存，这个成员的变量也和本文的讨论无关。在java中，数组也是对象。所以value也只是一个引用，它指向一个真正的数组对象。其实执行了String s =”ABCabc”；这句代码之后，真正的内存布局应该是这样的：</p>
<p>value、offset和count这三个变量都是private的，并且没有提供setValue，setOffset和setCount等公共方法来修改这些值，所以在String类的外部无法修改String。也就是说一旦初始化就不能修改，并且在String类的外部不能访问这三个成员。此外，value，offset和count这三个变量都是final的，也就是说在String类内部，一旦这三个值初始化了，也不能被改变。所以，可以认为String对象是不可变的了。</p>
<p>那么在String中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括substring， replace， replaceAll， toLowerCase等。例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);    <span class="comment">// a = ABCabc</span></span><br><span class="line"></span><br><span class="line">a = a.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);    <span class="comment">//a = aBCabc</span></span><br></pre></td></tr></table></figure>

<p>那么a的值看似改变了，其实也是同样的误区。再次说明， a只是一个引用， 不是真正的字符串对象，在调用a.replace(‘A’, ‘a’)时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用a。</p>
<p>我们可以自己查看其他方法，都是在方法内部重新创建新的String对象，并且返回这个新的对象，原来的对象是不会被改变的。这也是为什么像replace， substring，toLowerCase等方法都存在返回值的原因。也是为什么像下面这样调用不会改变对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;ss = &quot;</span> + ss);     <span class="comment">// ss = 123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ss.replace(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ss = &quot;</span> + ss);     <span class="comment">//ss = 123456</span></span><br></pre></td></tr></table></figure>

<p>4、String对象真的不可变吗？</p>
<p>String的成员变量是private final的，也就是初始化之后不可改变。那么在这几个成员中，value比较特殊，因为他是一个引用变量，而不是真正的对象。value是final修饰的，也就是说final不能再指向其他数组对象，那么我能改变value指向的数组吗？比如，将数组中的某个位置上的字符变为下划线”_”。至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个value引用，更不能通过这个引用去修改数组，那么用什么方式可以访问私有成员呢？没错，用反射，可以反射出String对象中的value属性，进而改变通过获得的value引用改变数组的结构。下面是实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">&quot;Hello World&quot;</span>; </span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化，也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般不这么做。这个反射的实例还可以说明一个问题：如果一个对象，它组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final的，但是这个Wheel对象内部的状态可以改变，那么就不能很好的保证Car对象不可变。</p>
<h2 id="五、String对象创建方式"><a href="#五、String对象创建方式" class="headerlink" title="五、String对象创建方式"></a>五、String对象创建方式</h2><p>1、字面值形式：JVM会自动根据字符串常量池中字符串的实际情况来决定是否创建新对象（要么不创建，要么创建一个对象，关键要看常量池中有没有）</p>
<p>JDK中明确指出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] =&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br></pre></td></tr></table></figure>

<p>这该种方式先在栈中创建一个对String类的对象引用变量s，然后去查找 “abc”是否被保存在字符串常量池中。<strong>若”abc”已经被保存在字符串常量池中，则在字符串常量池中找到值为”abc”的对象，然后将s 指向这个对象</strong>; 否则，<strong>在 \</strong>堆** 中创建char数组 data，然后在 *<em>堆*</em> 中创建一个String对象object，它由 data 数组支持，紧接着这个String对象 object 被存放进字符串常量池，最后将 s 指向这个对象。**</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    String s0 = <span class="string">&quot;kvill&quot;</span>;        <span class="comment">// 1</span></span><br><span class="line">    String s1 = <span class="string">&quot;kvill&quot;</span>;        <span class="comment">// 2</span></span><br><span class="line">    String s2 = <span class="string">&quot;kv&quot;</span> + <span class="string">&quot;ill&quot;</span>;     <span class="comment">// 3</span></span><br><span class="line">    System.out.println(s0 == s1);       <span class="comment">// true  </span></span><br><span class="line">    System.out.println(s0 == s2);       <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行第 1 行代码时，“kvill” 入池并被 s0 指向；执行第 2 行代码时，s1 从常量池查询到” kvill” 对象并直接指向它；所以，s0 和 s1 指向同一对象。 由于 ”kv” 和 ”ill” 都是字符串字面值，所以 s2 在编译期由编译器直接解析为 “kvill”，所以 s2 也是常量池中”kvill”的一个引用。 所以，我们得出 s0==s1==s2;</p>
<p>2.通过new创建字符串对象：一概在堆中创建新对象，无论字符串字面值是否相等（要么创建一个，要么创建两个对象，关键要看常量池中有没有）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String original=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s=<span class="keyword">new</span> String(original);</span><br></pre></td></tr></table></figure>

<p>所以，<strong>通过 new 操作产生一个字符串（“abc”）时，会先去常量池中查找是否有“abc”对象，如果没有，则创建一个此字符串对象并放入常量池中。然后，在堆中再创建“abc”对象，并返回该对象的地址。</strong>所以，<strong>对于 String str=new String(“abc”)**：</strong>如果常量池中原来没有”abc”，则会产生两个对象（一个在常量池中，一个在堆中）；否则，产生一个对象。**</p>
<p>用new String()创建的字符串对象位于堆中，而不是常量池中，它们有自己独立的地址空间，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    String s0 = <span class="string">&quot;kvill&quot;</span>;  </span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;kvill&quot;</span>);  </span><br><span class="line">    String s2 = <span class="string">&quot;kv&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;ill&quot;</span>);  </span><br><span class="line">    String s = <span class="string">&quot;ill&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;kv&quot;</span> + s;    </span><br><span class="line">    System.out.println(s0 == s1);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s0 == s2);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s1 == s2);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s0 == s3);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s1 == s3);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s2 == s3);       <span class="comment">// false  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>例子中，s0 还是常量池中”kvill”的引用，s1 指向运行时创建的新对象”kvill”，二者指向不同的对象。对于s2，因为后半部分是 new String(“ill”)，所以无法在编译期确定，在运行期会 new 一个 StringBuilder 对象， 并由 StringBuilder 的 append 方法连接并调用其 toString 方法返回一个新的 “kvill” 对象。此外，s3 的情形与 s2 一样，均含有编译期无法确定的元素。因此，以上四个 “kvill” 对象互不相同。StringBuilder 的 toString 为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value,<span class="number">0</span>,count);	<span class="comment">//new的方式创建字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数String(String original)的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据源字符串的底层数组长度与该字符串本身长度是否相等决定是否共用支撑数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = original.count;</span><br><span class="line">    <span class="keyword">char</span>[] originalValue = original.value;</span><br><span class="line">    <span class="keyword">char</span>[] v;</span><br><span class="line">    <span class="keyword">if</span> (originalValue.length &gt; size) &#123;</span><br><span class="line">        <span class="comment">// The array representing the String is bigger than the new</span></span><br><span class="line">        <span class="comment">// String itself. Perhaps this constructor is being called</span></span><br><span class="line">        <span class="comment">// in order to trim the baggage, so make a copy of the array.</span></span><br><span class="line">        <span class="keyword">int</span> off = original.offset;</span><br><span class="line">        v = Arrays.copyOfRange(originalValue, off, off + size);  <span class="comment">// 创建新数组并赋给 v</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The array representing the String is the same</span></span><br><span class="line">        <span class="comment">// size as the String, so no point in making a copy.</span></span><br><span class="line">        v = originalValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = size;</span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以知道，<strong>所创建的对象在大多数情形下会与源字符串 original 共享 char数组 。</strong>但是，<strong>什么情况下不会共享呢？</strong><br>　　<br>　　Take a look at <strong>substring</strong> , and you’ll see how this can happen.</p>
<p>　　Take for instance String s1 = “Abcd”; String s2 = s1.substring(3). Here s2.size() is 1, but s2.value.length is 4. <strong>This is because s1.value is the same as s2.value. This is done of performance reasons (substring is running in O(1), since it doesn’t need to copy the content of the original String).</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Abcd&quot;</span>;       <span class="comment">// s1 的value为Abcd的数组，offset为 0，count为 4</span></span><br><span class="line">String s2 = a.substring(<span class="number">3</span>);      <span class="comment">// s2 的value也为Abcd的数组，offset为 3，count为 1</span></span><br><span class="line">String c = <span class="keyword">new</span> String(s2);      <span class="comment">// s2.value.length 为 4，而 original.count = size = 1, 即 s2.value.length &gt; size 成立</span></span><br></pre></td></tr></table></figure>

<p><strong>Using substring can lead to a memory leak.</strong> Say you have a really long String, and you only want to keep a small part of it. If you just use substring, you will actually keep the original string content in memory. <strong>Doing</strong> <strong>String snippet = new String(reallyLongString.substring(x,y))</strong> , <strong>prevents you from wasting memory backing a large char array no longer needed.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/java%E4%B8%AD%E7%9A%84-equals%E4%B8%8EhashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/java%E4%B8%AD%E7%9A%84-equals%E4%B8%8EhashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" class="post-title-link" itemprop="url">java中的==,equals与hashCode的区别与联系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-01 10:30:44 / 修改时间：14:35:11" itemprop="dateCreated datePublished" datetime="2021-02-01T10:30:44+08:00">2021-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>1、概念</p>
<ul>
<li>==：该操作符生成的是一个boolean结果，它计算的是操作数的值之间的关系</li>
<li>equals：Object的实例方法，比较两个对象的content是否相同</li>
<li>hashCode：Object的native方法，获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数。</li>
</ul>
<h2 id="二、关系操作符"><a href="#二、关系操作符" class="headerlink" title="二、关系操作符 =="></a>二、关系操作符 ==</h2><p>1、操作数的值</p>
<ul>
<li><p>基本数据类型</p>
<p>在java中有八种基本数据类型：</p>
<p>​    浮点型：float(4 byte)，double(8 byte)</p>
<p>​    整型：byte(1 byte)，short(2 byte)，int（4 byte）,long(8 byte)</p>
<p>​    字符型：char(2 byte)</p>
<p>​    布尔型：boolean（JVM规范没有明确规定其所占空间的大小，仅规定其只能够取字面值“true”和”false”</p>
<p>对于这八种基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符==来进行比较时，比较的就是“值”本身。要注意的是，浮点型和整型都是有符号类型的，而char是无符号类型的。</p>
</li>
<li><p>引用类型变量</p>
<p>在java中，引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址。比如下面这行代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1;</span><br></pre></td></tr></table></figure>

<p>这句话声明了一个引用类型的变量，此时它没有和任何对象关联。</p>
<p>而通过new来产生一个对象，并将这个对象和str1进行绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么str1就指向了这个对象，此时引用变量str1中存储的是它指向在内存中的存储地址，并不是“值”本身，也就是说并不是直接存储的字符串“hello”。这里面的引用和C/C++中的指针很类似。</p>
</li>
</ul>
<p>2、小结</p>
<p>因此，对于关系操作符==：</p>
<ul>
<li>若操作的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等。</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。也就是说，若此时返回true，则该操作符作用的一定是同一个对象。</li>
</ul>
<h2 id="三、equals方法"><a href="#三、equals方法" class="headerlink" title="三、equals方法"></a>三、equals方法</h2><p>1、来源</p>
<p>​    equals方法是基类Object中的实例方法，因此对所有继承于Object的类都会有该方法。</p>
<p>在Object中的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2、equals方法的作用</p>
<p>初衷：判断两个对象的content是否相同</p>
<p>为了更直观地理解equals方法的作用，先看Object类中equals方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p>
<p>但是String类重写了equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;	<span class="comment">//方法签名与Object类中的一致</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == anObject)&#123;	<span class="comment">//先判断引用是否相同（是否为同一对象）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;	<span class="comment">//再判断类型是否一致，</span></span><br><span class="line">        <span class="comment">//最后判断内容是否一致</span></span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        <span class="keyword">int</span> n=count;</span><br><span class="line">        <span class="keyword">if</span> (n==anotherString.count)&#123;</span><br><span class="line">            <span class="keyword">char</span> v1[]=value;</span><br><span class="line">            <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=offset;</span><br><span class="line">            <span class="keyword">int</span> j=anotherString.offset;</span><br><span class="line">            <span class="keyword">while</span> (n--!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i++]!=v2[j++])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于诸如“字符串”比较时用的什么方法，内部实现如何？“之类的回答即为：</p>
<p>使用equals方法，内部实现分为三个步骤：</p>
<ul>
<li>先比较引用是否相同（是否为同一对象）</li>
<li>再判断类型是否一致（是否为同一类型）</li>
<li>最后比较内容是否一致</li>
</ul>
<p>java中所有内置的类的equals方法的实现步骤均是如此，特别是诸如Integer、Double等包装器类。</p>
<p>3、equals重写原则</p>
<p>对象内容的比较才是设计equal()的真正目的，java语言对equals()的要求如下，这些要求是重写该方法时必须遵循的：</p>
<ul>
<li>对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”；</li>
<li>自反性：x.equals(x)必须返回是”true“；</li>
<li>类推性：如果x.equals(y)返回是”true“，而且y.equals(z)返回是”true“，那么z.equals(x)也应该返回是”true“</li>
<li>一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true“;</li>
<li>对称性：如果x.equals(y)返回是”true“，那么y.equals(x)也应该返回是”true”。</li>
<li>任何情况下，x.equals(null) ，永远返回都是”false“；x.equals(和x不同类型的对象)永远返回是”false”.</li>
</ul>
<p>4、小结</p>
<p>因此，对于equals方法：</p>
<ul>
<li>其本意是比较两个对象的content是否相同</li>
<li>必要的时候，我们需要重写该方法，避免违背本意，且要遵循上述原则</li>
</ul>
<h2 id="四、hashCode方法"><a href="#四、hashCode方法" class="headerlink" title="四、hashCode方法"></a>四、hashCode方法</h2><p>1、hashCode的来源</p>
<p>​    hashCode方法是基类Object中的实例native方法，因此对所有继承于Object的类都会有该方法。</p>
<p>​    在Object类中的声明（native方法暗示这些方法是有实现体的，但不提供实现体，因为其实现体是由非java语言在外面实现的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、哈希相关概念</p>
<p>首先了解一下哈希表</p>
<ul>
<li><p>概念：哈希就是把任意长度的输入（又叫做预映射，pre-image），通过散列算法，变换成固定长度的输出（int），该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间。不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值，简单的说，就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
</li>
<li><p>应用-数据结构：数组的特点是存址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。哈希表有一种拉链法，可以理解为链表的数组。如图：</p>
<p><img src="https://img-blog.csdn.net/20160907231114726" alt="这里写图片描述"></p>
</li>
</ul>
<p>左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。其中，将根据元素特征计算元素数组下标的方法就是散列法。</p>
<ul>
<li>拉链法的适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。</li>
<li>要点：hash函数选择，针对字符串，整数，排列，具体相应的hash方法；碰撞处理，一种是open hashing，也称为拉链法，另一种就是closed hashing，也称开地址法，open addressing。</li>
</ul>
<p>3、hashCode简述</p>
<p>在java中，由Object类定义的hashCode方法会针对不同的对象返回不同的整数。</p>
<p><strong>hashCode 的常规协定是：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法 <strong>不要求</strong> 一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ul>
<p>HashCode只是在需要用到哈希算法的数据结构中才有用，比如HashSet，HashMap和Hashtable。</p>
<p>java中的集合（Collection）有三类，一类是List，一类是Queue，再有一类就是Set。前两个集合内的元素是有序的，元素可以重复；最后一个集合内的元素无序，但元素不可重复。</p>
<p>那么, 这里就有一个比较严重的问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是 <strong>Object.equals</strong> 方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。 也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了<strong>哈希表的原理</strong>。 这样，我们对每个要存入集合的元素使用哈希算法算出一个值，然后根据该值计算出元素应该在数组的位置。所以，当集合要添加新的元素时，可分为两个步骤：</p>
<ul>
<li>先调用这个元素的hashCode方法，然后根据所得到的值计算出元素应该在数组的位置。如果这个位置上没有元素，那么直接将它存储在这个位置上；</li>
<li>如果这个位置上已经有元素了，那么调用它的equals方法与新元素进行比较：相同的话就不存了，否则将其存在这个位置对应的链表中（Java中HashSet，HashMap和Hashtable的实现总将元素放到链表的表头）。</li>
</ul>
<p>4、equals与hashCode</p>
<p><strong>前提：</strong> 谈到hashCode就不得不说equals方法，二者均是Object类里的方法。由于Object类是所有类的基类，所以一切类里都可以重写这两个方法</p>
<ul>
<li><strong>原则 1 ：</strong> 如果 x.equals(y) 返回 “true”，那么 x 和 y 的 hashCode() 必须相等 ；</li>
<li><strong>原则 2 ：</strong> 如果 x.equals(y) 返回 “false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等 ；</li>
<li><strong>原则 3 ：</strong> 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ；</li>
<li><strong>原则 4 ：</strong> <strong>一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用 ；</strong></li>
<li><strong>原则 5 ：</strong> <strong>当一个对象类型作为集合对象的元素时，那么这个对象应该拥有自己的equals()和hashCode()设计，而且要遵守前面所说的几个原则。</strong></li>
</ul>
<p>5、实现例证</p>
<p>hashCode()在Object类中定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明这是一个本地方法，它的实现是根据本地机制相关的。</p>
<p>String类是这样重写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];     <span class="comment">//成员变量1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;      <span class="comment">//成员变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;       <span class="comment">//成员变量3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0    //非成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">int</span> len = count;         <span class="comment">//用到成员变量3</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> off = offset;         <span class="comment">//用到成员变量2</span></span><br><span class="line">        <span class="keyword">char</span> val[] = value;       <span class="comment">//用到成员变量1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span>*h + val[off++];       <span class="comment">//递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><ul>
<li>hashCode是系统用来快速检索对象而使用</li>
<li>equals方法本意是用来判断引用的对象是否一致</li>
<li>重写equals方法和hashCode方法时，equals方法中用到的成员也必定会在hashCode方法中用到，只不过前者作为比较项，后者作为生成摘要的信息项，本质上所用到的数据是一样的，从而保证二者的一致性</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/31/java%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/java%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">java继承、多态与类的复用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-31 19:53:17" itemprop="dateCreated datePublished" datetime="2021-01-31T19:53:17+08:00">2021-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-01 10:05:39" itemprop="dateModified" datetime="2021-02-01T10:05:39+08:00">2021-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文结合Java的类的复用对面向对象两大特征继承和多态进行了全面的介绍。首先，我们介绍了继承的实质和意义，并探讨了继承，组合和代理在类的复用方面的异同。紧接着，我们根据继承引入了多态，介绍了它的实现机制和具体应用。此外，为了更好地理解继承和多态，我们对final关键字进行了全面的介绍。在此基础上，我们介绍了Java中类的加载及初始化顺序。最后，我们对面向对象设计中三个十分重要的概念–重载、覆盖与隐藏进行了详细的说明。</p>
<p><strong>要点：</strong></p>
<ul>
<li>继承</li>
<li>组合、继承、代理</li>
<li>多态</li>
<li>final关键字</li>
<li>类加载及初始化顺序</li>
<li>重载、覆盖与隐藏</li>
</ul>
<h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>继承是所有OOP语言不可缺少的部分，在java中，使用extends关键字来表示继承关系。当创建一个类时，总是在继承，如果没有明确指出要继承的类，就总是隐式地从根类Object进行继承。如果两个类存在继承关系，则子类会自动继承父类的方法和变量，在子类中可以直接调用父类的方法和变量。需要指出的是，在java中，只允许单继承，也就是说，一个类最多只能显式地继承于一个父类。但是，一个类却可以被多个类继承，也就是说，一个类可以拥有多个子类。此外，<strong>我们需要特别注意以下几点：</strong></p>
<p>1、成员变量的继承</p>
<p>当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：</p>
<ul>
<li>子类能够继承父类的public和protected成员变量，不能够继承父类的private成员变量，但可以通过父类相应的getter/setter方法进行访问；</li>
<li>对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承，否则，子类不能够继承；</li>
<li>对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。</li>
</ul>
<p>2、成员方法的继承</p>
<p>同样地，当子类继承了某个类之后，便可以使用父类中的成员方法，但是子类并不是完全继承父类的所有方法。具体的原则如下：</p>
<ul>
<li>子类能够继承父类的public和protected成员方法，不能够继承父类的private成员方法；</li>
<li>对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承，否则，子类不能够继承；</li>
<li>对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。</li>
</ul>
<p><strong>程序示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String gentle = <span class="string">&quot;Father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String gentle = <span class="string">&quot;Son&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.gentle;	<span class="comment">//在子类中访问父类中同名成员变</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        Student student= <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;####&quot;</span> + student.gentle);</span><br><span class="line">        Person p = student;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****&quot;</span> + p.gentle);	<span class="comment">//隐藏：编译时决定，不会发生多态</span></span><br><span class="line">        </span><br><span class="line">        Sytem.out.println(<span class="string">&quot;----&quot;</span> + student.print());</span><br><span class="line">        System.out.println(<span class="string">&quot;----&quot;</span> + p.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。</p>
<p>3、基类的初始化与构造器</p>
<p>导出类就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但是，继承并不只是复制基类的接口。当创建一个导出类对象时，该对象会包含一个基类的子对象。这个子对象与我们用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部。</p>
<p>因此，对基类子对象的正确初始化是至关重要的，并且java也提供了相应的方法来保证这一点：导出类必须在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力。当基类含有默认构造时，java会自动在导出类的构造器插入对该基类默认构造器的调用，因为编译器不必考虑要传递什么样的参数的问题。但是，若父类不含有默认构造器，或者导出类想调用一个带参数的父类构造器，那么在导出类的构造器中就必须使用super关键字显式的进行调用相应的基类的构造器，并且该调用语句必是导出类构造器的第一条语句。</p>
<h2 id="二、组合，继承，代理"><a href="#二、组合，继承，代理" class="headerlink" title="二、组合，继承，代理"></a>二、组合，继承，代理</h2><p>组合、继承和代理三种技术都可以实现代码的复用。</p>
<p><strong>（1）组合（has-a）</strong></p>
<p><strong>通过在新的类中加入现有类的对象即可实现组合。</strong>即，新的类是由现有类的对象所组成。<strong>该技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。</strong>也就是说，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。</p>
<p><strong>（2）继承 （is-a）</strong></p>
<p>继承可以使我们按照现有类的类型来创建新类。即，我们采用现有类的形式并在其中添加新代码。通常，这意味着我们在使用一个通用类，并为了某种特殊需要而将其特殊化。本质上，组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。</p>
<p><strong>（3）代理（继承与组合之前的一种中庸之道：像组合一样使用已有类的功能，同时像继承一样使用已有类的接口)</strong></p>
<p>代理是继承与组合之前的一种中庸之道，java并没有提供对它的直接支持。在代理中，我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴漏了该成员对象的接口/方法。（就像继承）</p>
<p><strong>程序示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太空船需要一个控制模块，那么，构造太空船的一种方式是使用继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> <span class="keyword">extends</span> <span class="title">SpaceShipControls</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpaceShip</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpaceShip protector = <span class="keyword">new</span> SpaceShip(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">        protector.forward(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，SpaceShip 并不是真正的 SpaceShipControls 类型，即便你可以“告诉” SpaceShip 向前运动（forward()）。<strong>更准确的说，SpaceShip 包含 SpaceShipControls ，与此同时， SpaceShipControls 的所有方法在 SpaceShip 中都暴露出来。</strong> <strong>代理（SpaceShip 的运动行为由 SpaceShipControls 代理完成）</strong> 正好可以解决这种问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpaceShip 的行为由 SpaceShipControls 代理完成</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> SpaceShipControls controls = <span class="keyword">new</span> SpaceShipControls(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理方法: </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.back(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.down(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.forward(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.left(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.right(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        controls.turboBoost(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.up(velocity); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        SpaceShipDelegation protector = <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>); </span><br><span class="line">        protector.forward(<span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，使用代理时可以拥有更多的控制力，因为我们可以选择只提供在成员对象中方法的某个子集。</p>
<h2 id="三、final关键字"><a href="#三、final关键字" class="headerlink" title="三、final关键字"></a>三、final关键字</h2><p>　许多编程语言都需要某种方法来向编译器告知一块数据是恒定不变的。有时，数据的恒定不变是很有用的，比如：</p>
<ul>
<li>一个永不改变的编译时常量；</li>
<li>一个在运行时被初始化的值，而你不希望它被改变。</li>
</ul>
<p>对于编译期常量这种情况，编译器可以将该常量值带入任何可能用到它的计算式中，也即是说，可以在编译时执行计算式，这减轻了一些运行时负担。在java中，这类常量必须满足两个条件：</p>
<ul>
<li>是基本类型，并且用final修饰；</li>
<li>在对这个常量进行定义的时候，必须对其进行赋值。</li>
</ul>
<p>此外，当用final修饰对象引用时，final使其引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。然而，对象本身是可以被修改的，这同样使用于数组，因为它也是对象。</p>
<p>特别需要注意的是，我们不能因为某数据是final的，就认为在编译时就可以知道它的值。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i4=rand.nextInt(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、空白final</p>
<p>　　Java允许生成 <strong>空白final</strong> , 即：<strong>声明final但又未给定初值的域。</strong>但无论什么情况，编译器都会确保空白final在使用前被初始化。但是，<strong>空白final在关键字final的使用上提供了更大的灵活性:</strong> <strong>一个类中的 final域 就可以做到根据对象而有所不同，却又保持其恒定不变的特性</strong></p>
<p>必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。</p>
<p>2、final参数</p>
<p>final参数主要应用于局部内部类和匿名内部类中。</p>
<p>3、final方法</p>
<p><strong>final关键字作用域方法时，用于锁定方法，以防任何继承类修改它的含义。**</strong>这是出于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。**</p>
<p>　　<strong>对于成员方法，只有在明确禁止覆盖时，才将方法设为final的。</strong></p>
<p>4、final类</p>
<p>当讲某个类定义为final时，就表明你不打算继承该类，而且也不允许别人这样做。换句话说，出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全考虑，你不希望它有子类。</p>
<p>需要注意的是，final类的域可以根据实际情况选择是否为final的。不论是否被定义为final，相同的规则都适用于定义final的域。然而，由于final类禁止继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖它们。在final类中可以给方法添加final修饰，但这不会增添任何意义。</p>
<p>5、final与private</p>
<p><strong>类中所有的private方法都隐式地指定为final的。</strong>由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰，但这并不会给该方法添加任何额外的意义。</p>
<p>特别需要注意的是，覆盖只有在某方法是基类接口的一部分时才会出现。如果一个方法是private的，它就不是基类接口中的一部分，而仅仅是一些隐藏于类中的程序代码。但若在类中以相同的名称生成一个非private方法，此时我们并没有覆盖该方法，仅仅是生成了一个新的方法。由于private方法无法触及并且能有效隐藏，所以除了把它看成是由于它所归属的类的组织结构的原因而存在外，其他任何情况都不需要考虑它。</p>
<p>6、final与static</p>
<ul>
<li>static修饰变量时，其具有默认值，且可改变，且其只能修饰成员变量和成员方法。</li>
<li>一个static final域只占据一段不能改变的存储空间，且只能在声明时进行初始化。因为其是final的，因而没有默认值；且又是static的，因此在类没有实例化时，其已被赋值，所以只能在声明时初始化。</li>
</ul>
<h2 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h2><p>继承允许将对象视为它自己本身的类型或基类型加以处理，从而使同一份代码可以毫无差别地运行在这些不同的类型之上。其中，多态方法调用允许一种类型表现出其他相似类型之间的区别，只要这些类型由同一个基类所导出。所以，多态的作用主要体现在两个方面：</p>
<ul>
<li>多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来，从而实现将改变的事物与未变的事物分离开来；</li>
<li>消除类型之间的耦合关系</li>
</ul>
<p>1、实现机制</p>
<p>方法的覆盖很好的体现了多态，但是当使用一个基类引用去调用一个覆盖方法时，到底该调用哪个方法才正确呢？</p>
<p>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。但是，显然，这种机制并不能解决上面的问题，因为在编译时编译器并不知道上述基类引用到底指向哪个对象。解决的办法就是后期绑定（动态绑定/运行时绑定）：在运行时根据对象的具体类型进行绑定。</p>
<p>事实上，在java中，除了static方法和final方法外，其他所有的方法都是后期绑定。这样，一个方法声明为final后，可以防止其他人覆盖该方法，但更重要的一点是：这样做可以有效地关闭动态绑定，或者说，告诉编译器不需要对其进行动态绑定，以便为final方法调用生成更有效的代码。</p>
<p>基于动态绑定机制，我们就可以编写只与基类打交道的代码了，并且这些代码对所有的导出类都可以正确运行。或者说，发送消息给某个对象，让该对象去断定该做什么事情。</p>
<p>2、向下转型与运行时类型识别</p>
<p>由于向上转型会丢失具体的类型信息，所以我们可能会想，通过向下转型也应该能够获取类型信息。然而，向上转型是安全的，因为基类不会具有大于导出类的接口。因此，我们通过基类接口发送的消息都能被接受，但是对于向下转型，我们就无法保证了。</p>
<p>要解决这个问题，必须有某种方法来确保向下转型的正确性，使我们不至于贸然转型到一种错误的类型，进而发出该对象无法接受的消息。在java中，运行时类型识别（RTTI）机制可以处理这个问题，它保证java中所有的转型都会得到检查。所以，即使我们只是进行一次普通的加括弧形式的类型转换，再进入运行期时仍会对其进行检查，以便保证它的确是我们希望的那种类型。如果不是，我们就会得到一个类型转换异常：ClassCastException。</p>
<p>3、多态的应用举例</p>
<ul>
<li>策略模式</li>
<li>适配器模式</li>
</ul>
<h2 id="五、类加载及初始化顺序"><a href="#五、类加载及初始化顺序" class="headerlink" title="五、类加载及初始化顺序"></a>五、类加载及初始化顺序</h2><p>类加载及初始化顺序：父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造函数-&gt;子类非静态代码块-&gt;子类构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String STR = <span class="string">&quot;Super Class Static Variable&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Static Block:&quot;</span> + STR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Constructor Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInit</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String STR = <span class="string">&quot;Class Static Variable&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class Static Block:&quot;</span> + STR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class Block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        ObjectInit a = <span class="keyword">new</span> ObjectInit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">        Super Class Static Block:Super Class Static Variable</span></span><br><span class="line"><span class="comment">        Class Static Block:Class Static Variable</span></span><br><span class="line"><span class="comment">        Super Class Block</span></span><br><span class="line"><span class="comment">        Super Class Constructor Method</span></span><br><span class="line"><span class="comment">        Class Block</span></span><br><span class="line"><span class="comment">        Constructor Method</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在运行该程序时，所发生的第一件事就是试图访问ObjectInit.main方法（一个static方法），于是加载器开始启动并加载ObjectInit类。在对其加载时，编译器注意到它有一个基类（由关键字extends得知），于是先进行加载其基类。如果该基类还有其自身的基类，那么先加载这个父基类，如此类推（本例中是先加载Object类，再加载SuperClass类，最后加载ObjectInit类）。接下来，根基类中的static域和static代码块会被执行，然后是下一个导出类，以此类推这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否正确初始化。到此为止，所有的类都已加载完毕，对象就可以创建了。首先，初始化根基类所有的普通成员变量和代码块，然后执行根基类构造器以便创建一个基对象，然后是下一个导出类，依次类推，知道初始化完成。</p>
<h2 id="六、重载、覆盖与隐藏"><a href="#六、重载、覆盖与隐藏" class="headerlink" title="六、重载、覆盖与隐藏"></a>六、重载、覆盖与隐藏</h2><p>1、重载与覆盖</p>
<p>重载：如果在一个类中定义了多个同名的方法，但它们有不同的参数（包含三方面：参数个数，参数类型和参数顺序），则称为方法的重载。其中，不能通过访问权限、返回类型和抛出异常进行重载。</p>
<p>覆盖：子类中定义的某个方法与其父类中某个方法具有相同的方法签名（包含相同的名称和参数列表），则称为方法的覆盖。子类对象使用这个方法时，将调用该方法在子类中的定义，对它而言，父类中该方法的定义被屏蔽了。</p>
<p>总的来说，重载和覆盖是java多态性的不同表现。前者是一个类中多态性的一种表现，后者是父类与子类之间多态性的一种表现。</p>
<p>2、实现机制</p>
<p>重载是一种参数多态机制，即通过方法参数的差异实现多态机制。并且，其属于一种静态绑定机制，在编译时已经知道具体执行哪个方法。</p>
<p>覆盖是一种动态绑定的多态机制。即，在父类与子类中具有相同签名的方法具有不同的具体实现，至于最终执行哪个方法根据运行时的实际情况而定。</p>
<p><strong>覆盖与隐藏</strong></p>
<p>定义：</p>
<p>覆盖：指运行时系统调用当前对象引用<strong>运行时类型</strong>中定义的方法，属于运行期绑定。</p>
<p>隐藏：指运行时系统调用当前对象引用<strong>编译时类型</strong>中定义的方法，即被声明或者转换为什么类型就调用对应类型中的方法或变量，属于编译器绑定。</p>
<p>范围：</p>
<p>覆盖：只针对示例方法。</p>
<p>隐藏：只针对静态方法和成员变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
