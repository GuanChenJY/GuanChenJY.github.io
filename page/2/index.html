<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/20/docker%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/20/docker%E5%AE%B9%E5%99%A8%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">docker容器面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 16:09:56" itemprop="dateCreated datePublished" datetime="2021-03-20T16:09:56+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 09:08:51" itemprop="dateModified" datetime="2021-03-25T09:08:51+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="容器核心知识"><a href="#容器核心知识" class="headerlink" title="容器核心知识"></a>容器核心知识</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。</p>
<p>容器由两部分组成：应用容器本身；依赖；</p>
<p>虚拟机底层需要有操作系统，量级比较大。</p>
<p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Build One Run Anywhere.</p>
<p>Docker的核心组件包括：</p>
<ul>
<li>Docker客户端：Client</li>
<li>Docker服务器：Docker Daemon</li>
<li>Docker镜像：Image</li>
<li>Registry</li>
<li>Docker容器：Container</li>
</ul>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20210320161934555.png" alt="image-20210320161934555"></p>
<p>Docker采用的是Client/Server架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个Host上，客户端也可以通过socket或REST API与远程的服务器通信。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Linux操作系统由内核空间和用户空间组成。</p>
<p>rootfs：</p>
<p>内核空间是kernel，Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。用户空间的文件系统是rootfs，包括熟悉的/dev、/proc、/bin等目录</p>
<p>对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。</p>
<h3 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h3><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p>
<h3 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h3><p>cgroup全称Control Group。Linux操作系统通过cgroup可以设置进程使用CPU、内存和IO资源的限额。</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>namespace管理这host中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace实现了容器间资源的隔离。Linux使用了6种namespace，分别对应6种资源：mount、UTS、IPC、PID、Network和User。</p>
<p><strong>Mount Namespace</strong></p>
<p>Mount namespace让容器看上去拥有整个文件系统。</p>
<p><strong>UTS namespace</strong></p>
<p>简单地说，UTS namespace让容器有自己的hostname。默认情况下，容器的hostname是它的短ID，可以通过-h或–hostname参数设置。</p>
<p><strong>IPC namespace</strong></p>
<p>IPC namespace容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与host和其他容器的IPC混在一起。</p>
<p><strong>PID namespace</strong></p>
<p>所有容器的进程都挂在dockerd进程下，同时也可以看到容器自己的子进程。如果进入到某个容器，ps就只能看到自己的进程了。</p>
<p>而且进程的PID不同于host中对应进程的PID，容器中PID=1的进程当然也不是host的init进程。也就是说：容器拥有自己独立的一套PID，这就是PID namespace提供的功能。</p>
<p><strong>Network namespace</strong></p>
<p>Network namspace让容器拥有自己独立的网卡、IP、路由等资源。</p>
<p><strong>User namespace</strong></p>
<p>User namespace让容器能够管理自己的用户，host不能看到容器中创建的用户。</p>
<h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><p>容器之间可通过ip、Docker DNS Server或joined容器三种方式通信。</p>
<h3 id="ip通信"><a href="#ip通信" class="headerlink" title="ip通信"></a>ip通信</h3><p>具体做法是在容器创建时通过–network指定相应的网络，或者通过docker network connect将现有容器加入到指定网络。</p>
<h3 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h3><p>docker daemon实现了一个内嵌的DNS Server，使容器可以直接通过容器名通信，方法很简单，只要在启动时用–name为容器命名就可以了。</p>
<h3 id="joined容器"><a href="#joined容器" class="headerlink" title="joined容器"></a>joined容器</h3><p>joined容器是另一种实现容器间通信的方式</p>
<p>joined容器可以使两个或多个容器共享一个网络栈，共享网卡和配置信息。joined容器之间可以通过127.0.0.1直接通信。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20210320165148657.png" alt="image-20210320165148657"></p>
<p>外网可以通过端口映射的方式来访问容器。</p>
<p>除了映射动态端口，也可以在-p中指定映射到host某个特定端口，例如可将80端口映射到host的8080端口。</p>
<p>每一个映射的端口，host都会启动一个docker-proxy进程来处理访问容器的流量，</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20210320165623003.png" alt="image-20210320165623003"></p>
<h2 id="Docker存储"><a href="#Docker存储" class="headerlink" title="Docker存储"></a>Docker存储</h2><p>Docker为容器两种存放数据的资源：</p>
<p>1、由storage driver管理的镜像层和容器层。</p>
<p>2、Data Volume。</p>
<p>容器由最后上面一个可写的容器层，以及若干只读的镜像层组成，容器的数据就存放在这些层中。这样的分层结构最大的特性是Copy-On-write：</p>
<p>（1）新数据会直接存放在最上面的容器层。</p>
<p>（2）修改现有数据会从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。</p>
<p>（3）如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</p>
<p>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于Docker storage driver。正是storage driver实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。</p>
<h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><p>Data Volume本质上是Docker Host文件系统中的目录或文件，能够直接被mount到容器的文件系统中。Data Volume有以下特点：</p>
<p>1、Data Volume是目录或文件，而非没有格式化的磁盘。</p>
<p>2、容器可以读写volume中的数据。</p>
<p>3、volume数据可以被永久地保存，即使使用它的容器已经被销毁。</p>
<h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p><strong>容器与host共享数据</strong></p>
<p>有两种类型的data volume，它们均可实现在容器与host之间共享数据，但方式有所区别。</p>
<p>对于bind mount是非常明确的：直接将要共享的目录mount到容器。</p>
<p>docker managed volume是在容器启动时才生成，所以需要将共享数据复制到volume中。</p>
<p><strong>容器之间共享数据</strong></p>
<p>第一种方法是将共享数据放在bind mount中，然后将其mount到多个容器。还是以httpd为例，不过这次的场景复杂些，我们要创建由三个httpd容器组成的web server集群，它们使用相同的html文件。</p>
<p>第二种是volume container，专门为其他容器提供volume的容器。它提供的卷可以是bind mount，也可以是docker managed volume。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/16/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/16/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">分治算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-16 11:00:35 / 修改时间：21:49:32" itemprop="dateCreated datePublished" datetime="2021-03-16T11:00:35+08:00">2021-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>分治算法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是【分而治之】，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<p><img src="https://pic.leetcode-cn.com/4f492f90ae0561f73291f48b3b87ee895392da9bbfb49277fb8fec6024a86634-image.png" alt="image.png"></p>
<p>分治法有时候也会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法。这些算法比一般的分治算法更能有效地运行。</p>
<p><strong>合并两个排序的链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组中超半数的元素</strong></p>
<p>可以采用分治的思路去求解，分别划分为左子区间和右子区间。分别找两个子区间里的众数，若两个众数相同则返回，不相同则需要分别对这两个众数进行计数比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> majority(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majority</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果区间里只有一个元素，那它就是众数</span></span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别递归找出左右半边的众数</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftNum = majority(nums, left, mid);</span><br><span class="line">        <span class="keyword">int</span> rightNum = majority(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 左右半边众数一致</span></span><br><span class="line">        <span class="keyword">if</span>(leftNum == rightNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右半边众数不一致，数一下哪个多</span></span><br><span class="line">        <span class="keyword">int</span> leftNumCount = count(nums, leftNum, left, right);</span><br><span class="line">        <span class="keyword">int</span> rightNumCount = count(nums, rightNum, left, right);</span><br><span class="line">        <span class="keyword">return</span> leftNumCount &gt; rightNumCount ? leftNum : rightNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两半边数组众数不一样，所以需要数一下哪边多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == num) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分治法求最大子序和</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    <span class="function">def <span class="title">maxSubArray</span><span class="params">(self, nums: List[<span class="keyword">int</span>])</span> -&gt; <span class="keyword">int</span>:</span></span><br><span class="line"><span class="function">        n </span>= len(nums)</span><br><span class="line">        #递归终止条件</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            #递归计算左半边最大子序和</span><br><span class="line">            max_left = self.maxSubArray(nums[<span class="number">0</span>:len(nums) <span class="comment">// 2])</span></span><br><span class="line">            #递归计算右半边最大子序和</span><br><span class="line">            max_right = self.maxSubArray(nums[len(nums) <span class="comment">// 2:len(nums)])        </span></span><br><span class="line">        #计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加</span><br><span class="line">        max_l = nums[len(nums) <span class="comment">// 2 - 1]</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(len(nums)</span> <span class="comment">// 2 - 1, -1, -1):</span></span></span><br><span class="line"><span class="function">            tmp +</span>= nums[i]</span><br><span class="line">            max_l = max(tmp, max_l)</span><br><span class="line">        max_r = nums[len(nums) <span class="comment">// 2]</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(len(nums)</span> <span class="comment">// 2, len(nums)):</span></span></span><br><span class="line"><span class="function">            tmp +</span>= nums[i]</span><br><span class="line">            max_r = max(tmp, max_r)</span><br><span class="line">        #返回三个中的最大值</span><br><span class="line">        <span class="keyword">return</span> max(max_right,max_left,max_l+max_r)</span><br></pre></td></tr></table></figure>






































































































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">可重入锁+AQS源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-15 21:39:04" itemprop="dateCreated datePublished" datetime="2021-03-15T21:39:04+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 14:42:13" itemprop="dateModified" datetime="2021-03-28T14:42:13+08:00">2021-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p><strong>可重入锁：</strong></p>
<p>1、指的是同一线程外层函数获得锁后，在进入该线程的内层方法会自动获取锁（类似于家里面的大门，进入之后可以进入厕所、厨房等）</p>
<p>2、java中ReentrantLock(显式锁)和synchronized(隐式锁)都是可重入锁，可重入锁的一个优点是可在一定程序避免死锁。</p>
<p>3、隐式锁（<strong>即synchronized关键字使用的锁)默认是可重入锁(同步块、同步方法)<br>原理如下：</strong>）</p>
<p>1、每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针</p>
<p>2、当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程持有，java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>
<p>3、当执行monitorexit时，java虚拟机则锁对象的计数器减1.计数器为零代表锁已经被释放</p>
<p><img src="https://img-blog.csdnimg.cn/20201021213526233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.同步块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SychronizedDemo</span> </span>&#123;</span><br><span class="line">    Object object=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sychronizedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;外层....&quot;</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;中层....&quot;</span>);</span><br><span class="line">                   <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;内层....&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SychronizedDemo().sychronizedMethod();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            A	外层....</span></span><br><span class="line"><span class="comment">            A	中层....</span></span><br><span class="line"><span class="comment">            A	内层....</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.同步代码块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendSms&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  可重入锁(也叫做递归锁)</span></span><br><span class="line"><span class="comment"> *  指的是同一线程外层函数获得锁后,内层递归函数任然能获取该锁的代码</span></span><br><span class="line"><span class="comment"> *  在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁</span></span><br><span class="line"><span class="comment"> *  也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</span></span><br><span class="line"><span class="comment"> *  **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * t1 sendSms</span></span><br><span class="line"><span class="comment">     * t1 sendEmail</span></span><br><span class="line"><span class="comment">     * t2 sendSms</span></span><br><span class="line"><span class="comment">     * t2 sendEmail</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、显式锁（即lock也有ReentrantLock这样的可重入锁）</p>
<p>（有多少个lock，就有多少个unlock，他们是配对使用的；如果多一个或者少一个会使得其他线程处于等待状态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //reentrantLock.lock();</span></span><br><span class="line"><span class="comment">        注意有多少个lock,就有多少个unlock,他们是配对使用的</span></span><br><span class="line"><span class="comment">        如果多了一个lock(),那么会出现线程B一直处于等待状态</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendSms&quot;</span>);</span><br><span class="line">            sendEmails();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEmails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendEmails...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone2 phone2=<span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;phone2.sendSms();&#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;phone2.sendSms();&#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="为什么要使用LockSupport"><a href="#为什么要使用LockSupport" class="headerlink" title="为什么要使用LockSupport"></a>为什么要使用LockSupport</h2><p><strong>1、3种让线程等待唤醒的方法</strong></p>
<ul>
<li>使用Object中的wait()方法让线程等待，使用Object中的notify方法唤醒线程</li>
<li>使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</li>
<li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li>
</ul>
<p><strong>2、Object类中wait()和notify()实现线程的等待唤醒</strong></p>
<p>wait和notify方法必须要在同步块或同步方法里且成对出现使用。 wait和notify方法两个都去掉同步代码块后看运行效果出现异常情况:<br>Exception in thread “A” Exception in thread “B”<br>java.lang.IllegalMonitorStateException<br>先wait后notify才可以(如果先notify后wait会出现另一个线程一直处于等待状态)<br>synchronized是关键字属于JVM层面。monitorenter(底层是通过monitor对象来完成,其实wait/notify等方法也依赖monitor对象只能在同步块或方法中才能调用wait/notify等方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitThread</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//      1.如果将synchronized (this)&#123;&#125;注释,会抛出异常,因为wait和notify一定要在同步块或同步方法中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;coming....&quot;</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;end....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;唤醒A线程....&quot;</span>);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo synchronizedDemo = <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            2.如果把下行这句代码打开,先notify后wait,会出现A线程一直处于等待状态</span></span><br><span class="line"><span class="comment">//            try &#123; TimeUnit.SECONDS.sleep(3);  &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">            synchronizedDemo.waitThread();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            synchronizedDemo.notifyThread();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、Condition接口中的await和signal方法实现线程等待和唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//如果把下行这句代码打开,先signal后await,会出现A线程一直处于等待状态</span></span><br><span class="line">            <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(3);  &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;coming....&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;END....&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;唤醒A线程****&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JUC强大的三个工具类"><a href="#JUC强大的三个工具类" class="headerlink" title="JUC强大的三个工具类"></a>JUC强大的三个工具类</h2><p>CountDownLatch，CyclicBarrier，Semaphore底层都是AQS来实现的。</p>
<h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch(闭锁)"></a>CountDownLatch(闭锁)</h3><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞</li>
<li>其他线程调用countDown方法会将计数器减1</li>
<li>计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行</li>
</ul>
<p>用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器cnt，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为调用await()方法而在等待的线程就会被唤醒。</p>
<p><img src="https://camo.githubusercontent.com/ceda39fe72e6d9797cbed436eb09cc974190b17a0b6c60266e235314ce5663b8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求:要求6个线程都执行完了,mian线程最后执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,i+<span class="string">&quot;&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t班长关门走人，main线程是班长&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、利用枚举减少if else的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    one(<span class="number">1</span>,<span class="string">&quot;齐&quot;</span>),two(<span class="number">2</span>,<span class="string">&quot;楚&quot;</span>),three(<span class="number">3</span>,<span class="string">&quot;燕&quot;</span>),</span><br><span class="line">    four(<span class="number">4</span>,<span class="string">&quot;赵&quot;</span>),five(<span class="number">5</span>,<span class="string">&quot;魏&quot;</span>),six(<span class="number">6</span>,<span class="string">&quot;韩&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer retCode;</span><br><span class="line">    <span class="keyword">private</span> String retMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CountryEnum</span><span class="params">(Integer retCode,String retMessage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retCode=retCode;</span><br><span class="line">        <span class="keyword">this</span>.retMessage=retMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">getCountryEnum</span><span class="params">(Integer index)</span></span>&#123;</span><br><span class="line">        CountryEnum[] countryEnums = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum countryEnum : countryEnums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(countryEnum.getRetCode()==index)&#123;</span><br><span class="line">                <span class="keyword">return</span> countryEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRetCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRetMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	楚	**国,被灭</span></span><br><span class="line"><span class="comment">	魏	**国,被灭</span></span><br><span class="line"><span class="comment">	赵	**国,被灭</span></span><br><span class="line"><span class="comment">	燕	**国,被灭</span></span><br><span class="line"><span class="comment">	齐	**国,被灭</span></span><br><span class="line"><span class="comment">	韩	**国,被灭</span></span><br><span class="line"><span class="comment">	main	**秦国一统江湖</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;**国,被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,CountryEnum.getCountryEnum(i).getRetMessage()).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;**秦国一统江湖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>1、CyclicBarrier的字面意思是可循环（Cyclic），使用的屏障（barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫做同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。</p>
<p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和<code>CountdownLatch</code>相似，都是通过维护计数器来实现的。线程执行await()方法之后计数器会减1，并进行等待，直到计数器为0，所有调用await()方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier和CountDownLatch的一个区别是：CyclicBarries的计数器通过调用reset()方法可以循环使用，所以它才叫做循环屏障。</p>
<p><img src="https://camo.githubusercontent.com/347eb2206a468d116abe31c7aa1b55c503e186439043c75e6f3af79fffe1c1cd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66373161663636622d306435342d343339392d613434622d6634376235383332313938342e706e67" alt="img"></p>
<p>2、代码验证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//集齐7颗龙珠就能召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125;</span></span><br><span class="line">        CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤龙珠&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp=i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t收集到了第&quot;</span>+temp+<span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p><strong>Semaphore（信号量）</strong></p>
<ul>
<li>acquire(获取)，当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release(释放) 实际上会将信号量的值加1，然后唤醒等待的线程。</li>
<li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li>
<li>代码验证</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t抢占了车位&quot;</span>);</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LockSupport详解"><a href="#LockSupport详解" class="headerlink" title="LockSupport详解"></a>LockSupport详解</h2><p><strong>LockSupport详解</strong></p>
<p><strong>1、什么是LockSupport？</strong></p>
<p>1、通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</p>
<p>2、LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根揭底，LockSupport调用的Unsafe中的native代码。</p>
<p>3、官网解释：</p>
<p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语<br>LockSupport类使用了一种名为Permit(许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(permit),permit只有两个值1和零，默认是零<br>可以把许可看成是一种(0,1)信号量(Semaphore），但与Semaphore不同的是，许可的累加上限是1<br><strong>2、阻塞方法</strong></p>
<ol>
<li>Permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时, park方法会被唤醒，然后会将permit再次设置为0并返回。</li>
<li>static void park()：底层是Unsafe类native方法</li>
<li>static void park(Object blocker)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201023152750416.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>3、唤醒方法</strong>(注意这个permit最多只能为1)</p>
<p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)会自动唤醒thread线程，即之前阻塞中的LockSupport.park()方法会立即返回<br>static void unpark( )<br><img src="https://img-blog.csdnimg.cn/2020102315302662.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>4、LockSupport它的解决的痛点</strong></p>
<p>1、LockSupport不用持有锁块，不用加锁，程序性能好</p>
<p>2、先后顺序，不容易导致卡死（因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞）</p>
<p><strong>5、代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1).阻塞</span></span><br><span class="line"><span class="comment"> (permit默认是O，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时,</span></span><br><span class="line"><span class="comment"> park方法会被唤醒，然后会将permit再次设置为O并返回)</span></span><br><span class="line"><span class="comment"> static void park()</span></span><br><span class="line"><span class="comment"> static void park(Object blocker)</span></span><br><span class="line"><span class="comment">(2).唤醒</span></span><br><span class="line"><span class="comment">static void unpark(Thread thread)</span></span><br><span class="line"><span class="comment"> (调用unpark(thread)方法后，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，</span></span><br><span class="line"><span class="comment"> permit值还是1)会自动唤醒thread线程，即之前阻塞中的LockSupport.park()方法会立即返回)</span></span><br><span class="line"><span class="comment"> static void unpark(Thread thread)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;coming....&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果这里有两个LockSupport.park(),因为permit的值为1,上一行已经使用了permit</span></span><br><span class="line"><span class="comment">            所以下一行被注释的打开会导致程序处于一直等待的状态</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="comment">//LockSupport.park();</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被B唤醒了&quot;</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码注释是为了A线程先执行</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(3);  &#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line"></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;唤醒A线程&quot;</span>);</span><br><span class="line">            <span class="comment">//有两个LockSupport.unpark(t1),由于permit的值最大为1,所以只能给park一个通行证</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            <span class="comment">//LockSupport.unpark(t1);</span></span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、面试题目</strong></p>
<p>为什么可以先唤醒线程后阻塞线程?(因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞)<br>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?(因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次park却需要消费两个凭证，证不够，不能放行)</p>
<h2 id="AbstractQueuedSynchronizer之AQS"><a href="#AbstractQueuedSynchronizer之AQS" class="headerlink" title="AbstractQueuedSynchronizer之AQS"></a>AbstractQueuedSynchronizer之AQS</h2><h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><p>用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的CLH队列的变种来完成资源获取线程的排队工作，将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，有一个int类变量表示持有锁的状态，通过CAS完成对status值的修改（0表示没有，1表示阻塞）</p>
<p><img src="https://img-blog.csdnimg.cn/20201024103405147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201024103538578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>AQS为什么是JUC内容中最重要的基石</p>
<p>（ReentrantLock，CountDownlatch，ReentrantReadWriteLock，Semaphore）</p>
<p><img src="https://img-blog.csdnimg.cn/2020102410375214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201024103718565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201024103724964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020102410373547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201024103742886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3、锁，面向锁的使用者（定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可）同步器，面向锁的实现者（比如java并发大神Douglee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理，阻塞线程排队和通知，唤醒机制等。）</p>
<p>4、如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果</p>
<p><img src="https://img-blog.csdnimg.cn/20201024103954190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="AQS内部体系架构"><a href="#AQS内部体系架构" class="headerlink" title="AQS内部体系架构"></a>AQS内部体系架构</h3><p><img src="https://img-blog.csdnimg.cn/20201024104851886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201024104332465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2、详解AQS内部代码有什么？</p>
<p><img src="https://img-blog.csdnimg.cn/20201024104940778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CLH队列（三个大牛的名字组成），为一个双向队列</p>
<p><img src="https://img-blog.csdnimg.cn/20201024105009266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>内部结构（Node此类的讲解）</p>
<p><img src="https://img-blog.csdnimg.cn/20201025200211969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>5、属性说明（node此类的详解）</p>
<p><img src="https://img-blog.csdnimg.cn/20201024105140661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>AQS同步队列的基本结构</p>
<p><img src="https://img-blog.csdnimg.cn/20201024105320135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="ReentrantLock开始解读AQS"><a href="#ReentrantLock开始解读AQS" class="headerlink" title="ReentrantLock开始解读AQS"></a>ReentrantLock开始解读AQS</h3><p><img src="https://img-blog.csdnimg.cn/20201025210257600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">//带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制</span></span><br><span class="line">        <span class="comment">//3个线程模拟3个来银行网点，受理窗口办理业务的顾客</span></span><br><span class="line">        <span class="comment">//A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----A thread come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123; TimeUnit.MINUTES.sleep(<span class="number">20</span>); &#125;<span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span></span><br><span class="line">        <span class="comment">//进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----B thread come in&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span></span><br><span class="line">        <span class="comment">//进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----C thread come in&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从最简单的lock方法开始看看公平和非公平</strong></p>
<p>通过ReentrantLock的源码来讲解公平锁和非公平锁</p>
<p><img src="https://img-blog.csdnimg.cn/20201025200743744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201025200752772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201025200758604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>②. 可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件:hasQueuedPredecessors()<br>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201025200829191.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>lock()</strong></p>
<p>1、lock.lock()源码</p>
<p><img src="https://img-blog.csdnimg.cn/20201025201218165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2、acquire()：源码和3打流程走向</p>
<p><img src="https://img-blog.csdnimg.cn/20201025201418303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RaODQ1MTk1NDg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>tryAquire(arg)</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/%E5%AD%97%E5%85%B8%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/%E5%AD%97%E5%85%B8%E6%A0%91/" class="post-title-link" itemprop="url">字典树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-15 19:41:03" itemprop="dateCreated datePublished" datetime="2021-03-15T19:41:03+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-16 21:49:26" itemprop="dateModified" datetime="2021-03-16T21:49:26+08:00">2021-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h2><ul>
<li><p>叫前缀树更容易理解</p>
<p><img src="https://img-blog.csdn.net/20180823221048359?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTc3ODU3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
</li>
</ul>
<p>Trie又被称为前缀树、字典树、所以当然是一棵树。上面这棵Trie树包含的字符串集合是{in, inn, int, tea, ten, to}。典型的应用是用于统计和排序大量的字符串，所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。</p>
<p>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p><strong>前缀树的3个基本性质：</strong></p>
<p>1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p>
<p>2、从根节点到某一结点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>3、每个节点的所有子节点包含的字符都不相同。</p>
<p><strong>前缀树查询和哈希查询的比较（示相对情况而定）：</strong></p>
<p>通常字典树的查询时间复杂度是O（logL）,L是字符串的长度。所以效率还是比较高的。</p>
<p>网上的一部分文章说的都是字典树的效率比hash表高。我觉得还是相对来看比较好，各有各的特点吧。</p>
<p>hash表，通过hash函数把所有的单词分别hash成key值，查询的时候直接通过hash函数即可，都知道hash表的效率是非常高的为O(1)，直接说字典树的查询效率比hash高，难道有比O（1）还快的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-15 19:01:39" itemprop="dateCreated datePublished" datetime="2021-03-15T19:01:39+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 18:49:01" itemprop="dateModified" datetime="2021-03-25T18:49:01+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>滑动窗口算法就像一个滑动的窗口，套在一个序列中，左右的滑动，窗口内就是一个内容集。</p>
<p><strong>最长连续1的个数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,len=A.length;</span><br><span class="line">    <span class="keyword">while</span> (right&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[right]==<span class="number">0</span>) count++;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; K)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[left]==<span class="number">0</span>) count--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right-left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>替换后的最长重复串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            maxn = Math.max(maxn, num[s.charAt(right) - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> - maxn &gt; k) &#123;</span><br><span class="line">                num[s.charAt(left) - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>串联所有单词的子串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || words.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> word_num=words.length;</span><br><span class="line">        <span class="keyword">int</span> one_word=words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> all_len=one_word*word_num;</span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word:words)&#123;</span><br><span class="line">            map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;one_word;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=i,right=i,count=<span class="number">0</span>;</span><br><span class="line">            Map&lt;String,Integer&gt; tmp_map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (right+one_word&lt;=s.length())&#123;</span><br><span class="line">                String w=s.substring(right,right+one_word);</span><br><span class="line">                right+=one_word;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(w))&#123;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    left=right;</span><br><span class="line">                    tmp_map.clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp_map.put(w,tmp_map.getOrDefault(w,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">while</span> (tmp_map.getOrDefault(w,<span class="number">0</span>)&gt;map.getOrDefault(w,<span class="number">0</span>))&#123;</span><br><span class="line">                        String t_w=s.substring(left,left+one_word);</span><br><span class="line">                        count--;</span><br><span class="line">                        tmp_map.put(t_w,tmp_map.getOrDefault(t_w,<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                        left+=one_word;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == word_num) res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/13/%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/13/%E5%A0%86/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-13 13:31:10 / 修改时间：14:24:56" itemprop="dateCreated datePublished" datetime="2021-03-13T13:31:10+08:00">2021-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆（heap）是一个可以看成近似完全二叉树的数组。树上的每一个节点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。</p>
<p>堆包括最大堆和最小堆：最大堆的每一个节点的值不大于其父节点；最小堆的每一个节点的值不小于其父节点。</p>
<p><strong>堆常见的操作：</strong></p>
<ul>
<li>HEAPIFY建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为O(n)；</li>
<li>HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为O（logn）</li>
<li>HEAPPOP：从最大堆中取出最大值或从堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为O（logn）</li>
<li>HEAPSORT：借用HEAPFY建堆和HEAPPOP堆数组进行排序，时间复杂度为O（nlogn），空间复杂度为O（1）</li>
</ul>
<p><strong>根据字符出先得频率排序</strong>·</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    StringBuffer res=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] heap,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp=heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">char</span>[] heap,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest=i;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;n &amp;&amp; map.get(heap[i])&lt;map.get(heap[l]))&#123;</span><br><span class="line">            largest=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r&lt;n &amp;&amp; map.get(heap[largest])&lt;map.get(heap[r]))&#123;</span><br><span class="line">            largest=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest!=i)&#123;</span><br><span class="line">            swap(heap,i,largest);</span><br><span class="line">            heapify(heap,n,largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] S=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (Character c:S)&#123;</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=map.size();</span><br><span class="line">        <span class="keyword">char</span>[] heap=<span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        Iterator it=map.keySet().iterator();</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            heap[k]=(Character)it.next();</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            heapify(heap,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">            swap(heap, i, <span class="number">0</span>);</span><br><span class="line">            heapify(heap, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;map.get(heap[j]);t++)&#123;</span><br><span class="line">                res.append(heap[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后一块石头得重量：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stones.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:stones)&#123;</span><br><span class="line">            queue.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> first_max=queue.poll();</span><br><span class="line">            <span class="keyword">int</span> second_max=queue.poll();</span><br><span class="line">            first_max-=second_max;</span><br><span class="line">            queue.offer(first_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组中第k个最大元素</strong>·</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue= <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            queue.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++&lt;k)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最接近原点的K个点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Double&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            map.put(i,Math.sqrt(points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>]+points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator it=map.keySet().iterator();</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] heap=<span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;K)&#123;</span><br><span class="line">                heap[i]=(Integer)it.next();</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i==K)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=K/<span class="number">2</span>-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                        heapSort(heap,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> key=(Integer)it.next();</span><br><span class="line">                <span class="keyword">if</span> (map.get(key)&lt;map.get(heap[<span class="number">0</span>])) heap[<span class="number">0</span>]=key;</span><br><span class="line">                heapSort(heap,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;heap.length;j++)&#123;</span><br><span class="line">            res[j][<span class="number">0</span>]=points[heap[j]][<span class="number">0</span>];</span><br><span class="line">            res[j][<span class="number">1</span>]=points[heap[j]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] heap,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=heap[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>*i+<span class="number">1</span>;j&lt;heap.length;j=j*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span> &lt; heap.length &amp;&amp; map.get(heap[j+<span class="number">1</span>])&gt;map.get(heap[j])) j++;</span><br><span class="line">        <span class="keyword">if</span> (map.get(heap[j]) &gt; map.get(temp))&#123;</span><br><span class="line">            heap[i]=heap[j];</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序矩阵中第K小的元素</strong>：</p>
<p>本题既可以采用堆的方式构建，也可采用二分法查找（因为矩阵满足从上到下，从左到右依次递增）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length,left=matrix[<span class="number">0</span>][<span class="number">0</span>],right=matrix[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (check(matrix,mid,k,n))&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> mid,<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=n-<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]&lt;=mid)&#123;</span><br><span class="line">                num+=i+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num&gt;=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前K个高频元素：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(o2).compareTo(map.get(o1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator=map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=iterator.next();</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;k)&#123;</span><br><span class="line">            res[i]=queue.poll();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/java%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/java%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-12 15:31:26 / 修改时间：16:40:58" itemprop="dateCreated datePublished" datetime="2021-03-12T15:31:26+08:00">2021-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java异常架构与异常关键字"><a href="#java异常架构与异常关键字" class="headerlink" title="java异常架构与异常关键字"></a>java异常架构与异常关键字</h2><h3 id="java异常简介"><a href="#java异常简介" class="headerlink" title="java异常简介"></a>java异常简介</h3><p>java异常时是java提供的一种识别及响应错误的一致性机制。</p>
<h3 id="java异常架构"><a href="#java异常架构" class="headerlink" title="java异常架构"></a>java异常架构</h3><p><img src="https://img-blog.csdnimg.cn/20200314173417278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable是java语言中所有错误异常的超类。</p>
<p>Throwable包含两个子类：Error和Exception，它们通常用于指示发生了异常情况。</p>
<p>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p>
<h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p><strong>定义：</strong>Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p><strong>特点：</strong>一般表示代码运行时JVM出现问题。通常由Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h3><p>程序本身可以捕获并且可以处理的异常。Exception这种异常又分为两类：运行时异常和编译时异常。</p>
<p><strong>运行时异常</strong></p>
<p><strong>定义：</strong>RuntimeException类及其子类，表示JVM在运行期间可能出现的异常。</p>
<p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！<br>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（<strong>就算我们没写异常捕获语句运行时也会抛出错误</strong>！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<p><strong>编译时异常</strong></p>
<p><strong>定义:</strong> Exception 中除 RuntimeException 及其子类之外的异常。</p>
<p><strong>特点:</strong> Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p>
<h3 id="受检异常与非受检异常"><a href="#受检异常与非受检异常" class="headerlink" title="受检异常与非受检异常"></a>受检异常与非受检异常</h3><p>java所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）</p>
<p><strong>受检异常</strong></p>
<p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。<br><strong>非受检异常</strong></p>
<p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没用使用throws抛出该异常，编译也会正常通过。该类异常包括运行时异常（RuntimeException及其子类）和错误（Error）.</p>
<h2 id="java异常关键字"><a href="#java异常关键字" class="headerlink" title="java异常关键字"></a>java异常关键字</h2><p>• try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>• throw – 用于抛出异常。<br>• throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<h2 id="java异常处理"><a href="#java异常处理" class="headerlink" title="java异常处理"></a>java异常处理</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xMC8xNmU1NWYyYzMyMWQ5MDlk?x-oss-process=image/format,png" alt="img"></p>
<p>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p>
<p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p>
<h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用<strong>throws</strong>关键字声明可能会抛出的异常。</p>
<p>注意</p>
<ul>
<li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li>
<li>一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误。</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p>
<p>throw关键字作用是在方法内部抛出一个<code>Throwable</code>类型的异常。任何Java代码都可以通过throw语句抛出异常。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p>
<h3 id="如何选择异常类型"><a href="#如何选择异常类型" class="headerlink" title="如何选择异常类型"></a>如何选择异常类型</h3><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常</p>
<p><img src="https://img-blog.csdnimg.cn/20200314173209267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="常见异常处理方式"><a href="#常见异常处理方式" class="headerlink" title="常见异常处理方式"></a>常见异常处理方式</h2><h3 id="直接抛出异常"><a href="#直接抛出异常" class="headerlink" title="直接抛出异常"></a>直接抛出异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="封装异常再抛出"><a href="#封装异常再抛出" class="headerlink" title="封装异常再抛出"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        MyException ex = <span class="keyword">new</span> MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</p>
<p>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readFile method <span class="keyword">catch</span> block.</span><br><span class="line">readFile method <span class="keyword">finally</span> block.</span><br></pre></td></tr></table></figure>

<p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p>
<h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h2 id="java异常常见面试题"><a href="#java异常常见面试题" class="headerlink" title="java异常常见面试题"></a>java异常常见面试题</h2><h3 id="Error和Exception区别是什么？"><a href="#Error和Exception区别是什么？" class="headerlink" title="Error和Exception区别是什么？"></a>Error和Exception区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>
<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>
<h3 id="运行时异常和一般异常区别是什么？"><a href="#运行时异常和一般异常区别是什么？" class="headerlink" title="运行时异常和一般异常区别是什么？"></a>运行时异常和一般异常区别是什么？</h3><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>
<p>RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p>
<h3 id="jvm如何处理异常的？"><a href="#jvm如何处理异常的？" class="headerlink" title="jvm如何处理异常的？"></a>jvm如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>
<h3 id="throw和throws的区别是什么？"><a href="#throw和throws的区别是什么？" class="headerlink" title="throw和throws的区别是什么？"></a>throw和throws的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>
<p><strong>throws关键字和throw关键字在使用上的几点区别如下：</strong></p>
<p>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。<br>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p>
<h3 id="final、finally、finalize有什么区别？"><a href="#final、finally、finalize有什么区别？" class="headerlink" title="final、finally、finalize有什么区别？"></a>final、finally、finalize有什么区别？</h3><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p>
<h3 id="NoClassDefFoundError和ClassNotFoundException区别？"><a href="#NoClassDefFoundError和ClassNotFoundException区别？" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException区别？"></a>NoClassDefFoundError和ClassNotFoundException区别？</h3><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p>
<p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p>
<p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>
<h3 id="try-catch-finally中哪个部分可以省略？"><a href="#try-catch-finally中哪个部分可以省略？" class="headerlink" title="try-catch-finally中哪个部分可以省略？"></a>try-catch-finally中哪个部分可以省略？</h3><p>答：catch 可以省略</p>
<p>原因</p>
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p>
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p>
<h3 id="try-catch-finally中，如果catch中return了，finally还会执行吗？"><a href="#try-catch-finally中，如果catch中return了，finally还会执行吗？" class="headerlink" title="try-catch-finally中，如果catch中return了，finally还会执行吗？"></a>try-catch-finally中，如果catch中return了，finally还会执行吗？</h3><p>答：会执行，在return前执行。</p>
<p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</p>
<p><strong>代码示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了</span></span><br><span class="line"><span class="comment">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span></span><br><span class="line"><span class="comment">         * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：30</p>
<p><strong>代码示例2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(a / <span class="number">0</span>);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        a = <span class="number">40</span>;</span><br><span class="line">        <span class="comment">//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40</span></span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类ExampleA继承Exception，类ExampleB继承ExampleA"><a href="#类ExampleA继承Exception，类ExampleB继承ExampleA" class="headerlink" title="类ExampleA继承Exception，类ExampleB继承ExampleA"></a>类ExampleA继承Exception，类ExampleB继承ExampleA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ExampleA&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问执行此段代码的输出是什么？</p>
<p><strong>答</strong>：</p>
<p>输出：ExampleA.根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annoyance</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneeze</span> <span class="keyword">extends</span> <span class="title">Annoyance</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">			&#125; <span class="keyword">catch</span> ( Annoyance a ) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">				<span class="keyword">throw</span> a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> ( Sneeze s ) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h3 id="常见的RuntimeException有哪些？"><a href="#常见的RuntimeException有哪些？" class="headerlink" title="常见的RuntimeException有哪些？"></a>常见的RuntimeException有哪些？</h3><p>ClassCastException(类转换异常)<br>IndexOutOfBoundsException(数组越界)<br>NullPointerException(空指针)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>还有IO操作的BufferOverflowException异常</p>
<h3 id="java常见异常有哪些？"><a href="#java常见异常有哪些？" class="headerlink" title="java常见异常有哪些？"></a>java常见异常有哪些？</h3><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p>
<p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p>
<p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
<p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p>
<p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p>
<p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p>
<p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p>
<p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p>
<p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p>
<p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p>
<p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p>
<p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p>
<p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p>
<p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p>
<h2 id="java异常处理最佳实践"><a href="#java异常处理最佳实践" class="headerlink" title="java异常处理最佳实践"></a>java异常处理最佳实践</h2><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</p>
<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>
<h3 id="在finally块中清理资源或者使用try-with-resource语句"><a href="#在finally块中清理资源或者使用try-with-resource语句" class="headerlink" title="在finally块中清理资源或者使用try-with-resource语句"></a>在finally块中清理资源或者使用try-with-resource语句</h3><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCloseResourceInTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。<br><strong>使用finally代码块</strong></p>
<p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeResourceInFinally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>java7的try-with-resource语法</strong></p>
<p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">automaticallyCloseResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先明确的异常"><a href="#优先明确的异常" class="headerlink" title="优先明确的异常"></a>优先明确的异常</h3><p>你抛出的异常越明确越好，永远记住，你的同事或者几个月之后的你，将会调用你的方法并且处理异常。</p>
<p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。</p>
<p>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotDoThis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThis</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对异常进行文档说明"><a href="#对异常进行文档说明" class="headerlink" title="对异常进行文档说明"></a>对异常进行文档说明</h3><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用描述性消息抛出异常"><a href="#使用描述性消息抛出异常" class="headerlink" title="使用描述性消息抛出异常"></a>使用描述性消息抛出异常</h3><p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>
<p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先捕获最具体的异常"><a href="#优先捕获最具体的异常" class="headerlink" title="优先捕获最具体的异常"></a>优先捕获最具体的异常</h3><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要捕获Throwable类"><a href="#不要捕获Throwable类" class="headerlink" title="不要捕获Throwable类"></a>不要捕获Throwable类</h3><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h3><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要记录并抛出异常"><a href="#不要记录并抛出异常" class="headerlink" title="不要记录并抛出异常"></a>不要记录并抛出异常</h3><p>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。</p>
<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装异常时不要抛弃原始的异常"><a href="#包装异常时不要抛弃原始的异常" class="headerlink" title="包装异常时不要抛弃原始的异常"></a>包装异常时不要抛弃原始的异常</h3><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要使用异常控制程序的流程"><a href="#不要使用异常控制程序的流程" class="headerlink" title="不要使用异常控制程序的流程"></a>不要使用异常控制程序的流程</h3><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p>
<h3 id="使用标准异常"><a href="#使用标准异常" class="headerlink" title="使用标准异常"></a>使用标准异常</h3><p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</p>
<h3 id="异常会影响性能"><a href="#异常会影响性能" class="headerlink" title="异常会影响性能"></a>异常会影响性能</h3><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。</p>
<p>仅在异常情况下使用异常；<br>在可恢复的异常情况下使用异常；<br>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/spring%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/spring%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">spring面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 14:53:41" itemprop="dateCreated datePublished" datetime="2021-03-12T14:53:41+08:00">2021-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-03 19:29:07" itemprop="dateModified" datetime="2021-04-03T19:29:07+08:00">2021-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Springbean的生命周期"><a href="#Springbean的生命周期" class="headerlink" title="Springbean的生命周期"></a>Springbean的生命周期</h3><ul>
<li>Bean容器找到配置文件中SpringBean的定义</li>
<li>Bean容器利用java Reflection API创建一个Bean的实例。</li>
<li>如果涉及到一些属性值利用set（）方法设置一些属性值。</li>
<li>如果Bean实现了BeanNameAware接口，调用setBeanName（）方法，传入Bean的名字。</li>
<li>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li>
<li>与上面的类似，如果实现了其他*.Aware接口，就调用相应的方法。</li>
<li>如果有和加载这个Bean的spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li>
<li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li>
<li>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</li>
<li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li>
<li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li>
<li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</li>
</ul>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/10/%E9%9D%A2%E8%AF%95%E6%94%B6%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/10/%E9%9D%A2%E8%AF%95%E6%94%B6%E8%8E%B7/" class="post-title-link" itemprop="url">面试收获</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-10 20:26:31" itemprop="dateCreated datePublished" datetime="2021-03-10T20:26:31+08:00">2021-03-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/09/mybatis%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/09/mybatis%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">mybatis面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 20:56:39" itemprop="dateCreated datePublished" datetime="2021-03-09T20:56:39+08:00">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-03 20:12:16" itemprop="dateModified" datetime="2021-04-03T20:12:16+08:00">2021-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="mybatis简介"><a href="#mybatis简介" class="headerlink" title="mybatis简介"></a>mybatis简介</h2><h3 id="mybatis是什么？"><a href="#mybatis是什么？" class="headerlink" title="mybatis是什么？"></a>mybatis是什么？</h3><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h3 id="ORM是什么？"><a href="#ORM是什么？" class="headerlink" title="ORM是什么？"></a>ORM是什么？</h3><p>ORM(Object Relational Mapping)，对象关系映射，是一种为了解决关系型数据库与简单java对象（POJO）的映射关系的技术。简单地说，ORM是通过使用描述对象和数据据之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h3 id="传统JDBC开发存在的问题"><a href="#传统JDBC开发存在的问题" class="headerlink" title="传统JDBC开发存在的问题"></a>传统JDBC开发存在的问题</h3><p>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。<br>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。<br>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。<br>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</p>
<h3 id="JDBC编程有哪些不足之处，Mybatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，Mybatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，Mybatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，Mybatis是如何解决这些问题的？</h3><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p>
<p>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决： Mybatis自动将java对象映射至sql语句。</p>
<p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h3 id="Mybatis优缺点"><a href="#Mybatis优缺点" class="headerlink" title="Mybatis优缺点"></a>Mybatis优缺点</h3><p><strong>优点</strong></p>
<p>与传统的数据库访问技术相比，ORM有以下优点：</p>
<p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用<br>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接<br>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）<br>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护<br>能够与Spring很好的集成<br><strong>缺点：</strong></p>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时候，对开发人员编写SQL语句的功底有一定要求</li>
<li>SQL语句依赖于数据库，导致数据库移植性较差，不能随意更换数据库</li>
</ul>
<h3 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h3><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<h3 id="Hibiernate与Mybatis的区别"><a href="#Hibiernate与Mybatis的区别" class="headerlink" title="Hibiernate与Mybatis的区别"></a>Hibiernate与Mybatis的区别</h3><p><strong>相同点：</strong></p>
<p>都是对jdbc的封装，都是持久层的框架，都用于DAO层的开发。</p>
<p><strong>不同点：</strong></p>
<p>映射关系：</p>
<ul>
<li>MyBatis是一个半自动映射的框架，配置java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li>
<li>Hibernate是一个全表映射的框架，配置java对象与数据库表的对应关系，多表关联关系配置复杂</li>
</ul>
<p>SQL优化和移植性</p>
<p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。<br>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。开发难易程度和学习成本</p>
<p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</p>
<p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</p>
<p>总结</p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h3 id="SqlMapConfig-xml配置"><a href="#SqlMapConfig-xml配置" class="headerlink" title="SqlMapConfig.xml配置"></a>SqlMapConfig.xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-properties(属性)</span><br><span class="line">	--property</span><br><span class="line">-setttings(全局配置参数)</span><br><span class="line">	--setting</span><br><span class="line">-typeAliases(类型别名)</span><br><span class="line">	--typeAliase</span><br><span class="line">	--package</span><br><span class="line">-typeHandlers(类型处理器)</span><br><span class="line">-objectFactory(对象工厂)</span><br><span class="line">-plugins(插件)</span><br><span class="line">-environments(环境集合属性对象)</span><br><span class="line">	--environment(环境子属性对象)</span><br><span class="line">		--transactionManager(事务管理)</span><br><span class="line">		--dataSource(数据源)</span><br><span class="line">-mappers(映射器)</span><br><span class="line">	--mapper</span><br><span class="line">	--package</span><br></pre></td></tr></table></figure>



<h2 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h2><h3 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h3><p>1、创建SqlSessionFactory</p>
<p>2、通过SqlSessionFactory创建SqlSession</p>
<p>3、通过SqlSession执行数据库操作</p>
<p>4、调用session.commit()提交事务</p>
<p>5、调用session.close()关闭会话</p>
<h3 id="MyBatis的工作原理"><a href="#MyBatis的工作原理" class="headerlink" title="MyBatis的工作原理"></a>MyBatis的工作原理</h3><p>MyBatis的工作原理如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt="MyBatis工作原理"></p>
<p>1、读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境信息，例如数据库连接信息。</p>
<p>2、加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>3、构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<p>4、创建会话对象：由会话工厂创建SqlSession对象，该对象包含了执行SQL语句的所有方法。</p>
<p>5、Executor执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<p>6、MappedStatement对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<p>7、输入参数映射：输入参数可以是Map、List等集合类型。也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。</p>
<p>8、输出结果映射：输出结果类型可以是map，list等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。</p>
<h3 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis功能框架"></p>
<p>MyBatis的功能架构分为三层：</p>
<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理</li>
</ul>
<h3 id="MyBatis的框架架构设计是怎么样的？"><a href="#MyBatis的框架架构设计是怎么样的？" class="headerlink" title="MyBatis的框架架构设计是怎么样的？"></a>MyBatis的框架架构设计是怎么样的？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis框架架构"></p>
<p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p>
<p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p>
<p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p>
<p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p>
<p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p>
<h3 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h3><p>SQL预编译指的是数据库驱动在发送SQL语句和参数给DBMS之前对SQL语句进行编译，这样DBMS执行SQL时，就不需要重新编译。</p>
<p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</p>
<h3 id="MyBatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#MyBatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="MyBatis都有哪些Executor执行器？它们之间的区别是什么？"></a>MyBatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Statement对象是java执行数据库操作的一个重要方法，用于在已经建立数据库连接的基础上，向数据库发送要执行的SQL语句。</p>
<p>Statement对象，用于执行不带参数的简单SQL语句。</p>
<p>PreparedStatement用于执行带或不带IN参数的预编译SQL语句。</p>
<p>CallableStatement对象用于执行对数据库已存在的存储过程的调用。</p>
<p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h3 id="MyBatis中如何指定使用哪一种Executor执行器？"><a href="#MyBatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="MyBatis中如何指定使用哪一种Executor执行器？"></a>MyBatis中如何指定使用哪一种Executor执行器？</h3><p>在MyBatis配置文件中，在设置可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession.openSession(ExecutorType exectype)</p>
<p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p>
<h3 id="MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis仅支持<strong>association关联对象</strong>和<strong>collection关联集合对象</strong>的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h3><p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</p>
<p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
<p>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</p>
<p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</p>
<p>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p>
<p>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</p>
<h3 id="模糊查询like语句该怎么写？"><a href="#模糊查询like语句该怎么写？" class="headerlink" title="模糊查询like语句该怎么写？"></a>模糊查询like语句该怎么写？</h3><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p>
<p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p>
<p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p>
<p>（4）使用bind标签</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;listUserLikeUsername&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="line">　　&lt;bind name=<span class="string">&quot;pattern&quot;</span> value=<span class="string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br><span class="line">　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h3><p><strong>方法1：顺序传参法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span><span class="params">(String name, <span class="keyword">int</span> deptId)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的数字代表传入参数的顺序。</p>
<p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p>
<p><strong>方法2：@Param注解传参法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String name, <span class="keyword">int</span> <span class="meta">@Param(&quot;deptId&quot;)</span> deptId)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p>
<p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p>
<p><strong>方法3：map传参法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span><span class="params">(Map&lt;String, Object&gt; params)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是Map里面的key名称。</p>
<p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p>
<p><strong>方法4：java Bean传参法</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>#{}里面的名称对应的是User类里面的成员属性。</p>
<p>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p>
<h3 id="MyBatis如何执行批量操作"><a href="#MyBatis如何执行批量操作" class="headerlink" title="MyBatis如何执行批量操作"></a>MyBatis如何执行批量操作</h3><p><strong>使用foreach标签</strong></p>
<p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p>
<p>item　　表示集合中每一个元素进行迭代时的别名，随便起的变量名；<br>index　　指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；<br>open　　表示该语句以什么开始，常用“(”；<br>separator表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；<br>close　　表示以什么结束，常用“)”。<br>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p>
<p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list<br>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array<br>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，<br>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key<br>具体用法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">addEmpsBatch</span><span class="params">(<span class="meta">@Param(&quot;emps&quot;)</span> List&lt;Employee&gt; emps)</span></span>; --&gt;</span><br><span class="line">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; <span class="comment">//推荐使用</span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    <span class="function">INSERT INTO <span class="title">emp</span><span class="params">(ename,gender,email,did)</span></span></span><br><span class="line"><span class="function">    VALUES</span></span><br><span class="line"><span class="function">    &lt;foreach collection</span>=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=<span class="keyword">true</span>的支持</span><br><span class="line"> 如jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/mybatis?allowMultiQueries=true --&gt;  </span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;;&quot;</span>&gt;                                 </span><br><span class="line">        <span class="function">INSERT INTO <span class="title">emp</span><span class="params">(ename,gender,email,did)</span></span></span><br><span class="line"><span class="function">        <span class="title">VALUES</span><span class="params">(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用ExecutroType.BATCH</strong></p>
<p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的<br>具体用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> Employee(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长&quot;</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper和mapper.xml如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    <span class="function">Long <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;addEmp&quot;</span>&gt;</span><br><span class="line">        <span class="function">insert into <span class="title">employee</span><span class="params">(lastName,email,gender)</span></span></span><br><span class="line"><span class="function">        <span class="title">values</span><span class="params">(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span></span></span><br><span class="line"><span class="function">    &lt;/insert&gt;</span></span><br><span class="line"><span class="function">&lt;/mapper&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h3><p><strong>对于支持主键自增的数据库（MySQL）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insertUser&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;userId&quot;</span> &gt;</span><br><span class="line">    <span class="function">insert into <span class="title">user</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    user_name, user_password, create_time)</span> </span></span><br><span class="line"><span class="function">    <span class="title">values</span><span class="params">(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span></span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br></pre></td></tr></table></figure>

<p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后 可以通过java实体或者Map 来获取主键值。通过 getUserId获取主键</p>
<p><strong>不支持主键自增的数据库（Oracle）</strong></p>
<p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。<br>可以使用<code>＜selectKey＞</code>标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库<br><code>＜selectKey＞</code>一般的用法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<h3 id="当实体类中的属性名和表中的字段名不一样，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，怎么办？"></a>当实体类中的属性名和表中的字段名不一样，怎么办？</h3><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>第2种： 通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultMap=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">	select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span> id=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;order_id&quot;</span>&gt;</span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;</span><br><span class="line">    &lt;result property =<span class="string">&quot;orderno&quot;</span> column =<span class="string">&quot;order_no&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;price&quot;</span> column=<span class="string">&quot;order_price&quot;</span> /&gt;</span><br><span class="line">&lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Mapper编写有哪几种方式？"><a href="#Mapper编写有哪几种方式？" class="headerlink" title="Mapper编写有哪几种方式？"></a>Mapper编写有哪几种方式？</h3><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p>
<ul>
<li><p>在SqlMapConfig.xml中配置mapper.xml的位置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义mapper接口</p>
</li>
<li><p>实现类集成SqlSessionDaoSupport(mapper方法中可以this.getsqlSession()进行数据增删改查)</p>
</li>
<li><p>spring配置</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot; &quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;mapper 接口的实现&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactory&quot;</span></span><br><span class="line">    ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p>
<p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<p>(2) 定义mapper接口</p>
<p>(3) mapper.xml中的namespace为mapper接口的地址</p>
<p>(4) mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致</p>
<p>(5) Spring中定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;mapperInterface&quot;</span> value=<span class="string">&quot;mapper 接口地址&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactory&quot;</span> ref=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>第三种：使用 mapper 扫描器：</p>
<p>（1）mapper.xml 文件编写：</p>
<p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p>
<p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p>
<p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p>
<p>（2）定义 mapper 接口：</p>
<p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p>
<p>（3）配置 mapper 扫描器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;basePackage&quot;</span> value=<span class="string">&quot;mapper 接口包地址</span></span><br><span class="line">    &quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="line">    value=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>(4) 使用扫描器后从spring容器中获取mapper的实现对象。</p>
<h3 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式</p>
<p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p>
<p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p>
<h3 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h3><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p>
<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p>
<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p>
<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h3 id="最佳实践中，通常一个XML映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载嘛"><a href="#最佳实践中，通常一个XML映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载嘛" class="headerlink" title="最佳实践中，通常一个XML映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载嘛"></a>最佳实践中，通常一个XML映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载嘛</h3><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h3 id="MyBatis的Xml映射文件中，不同的XML映射文件，id是否可以重复？"><a href="#MyBatis的Xml映射文件中，不同的XML映射文件，id是否可以重复？" class="headerlink" title="MyBatis的Xml映射文件中，不同的XML映射文件，id是否可以重复？"></a>MyBatis的Xml映射文件中，不同的XML映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h3 id="简述MyBatis的XML映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述MyBatis的XML映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述MyBatis的XML映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述MyBatis的XML映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="MyBatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射方式？"><a href="#MyBatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射方式？" class="headerlink" title="MyBatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射方式？"></a>MyBatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射方式？</h3><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</p>
<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？"><a href="#xml映射文件中，除了常见的select-insert-update-delete标签之外，还有哪些标签？" class="headerlink" title="xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？"></a>xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？</h3><p>还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p>
<h3 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p>
<p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>MyBatis实现一对一，一对多有几种方式，怎么操作的？</h3><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p>
<h3 id="MyBatis是否可以映射Enum枚举类"><a href="#MyBatis是否可以映射Enum枚举类" class="headerlink" title="MyBatis是否可以映射Enum枚举类"></a>MyBatis是否可以映射Enum枚举类</h3><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p>
<p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不</h3><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h2 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h2><h3 id="mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="mybatis是如何进行分页的？分页插件的原理是什么？"></a>mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>
<h3 id="Mybatis的插件运行原理，以及如何编写一个插件"><a href="#Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="Mybatis的插件运行原理，以及如何编写一个插件"></a>Mybatis的插件运行原理，以及如何编写一个插件</h3><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="mybatis的一级、二级缓存"><a href="#mybatis的一级、二级缓存" class="headerlink" title="mybatis的一级、二级缓存"></a>mybatis的一级、二级缓存</h3><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
