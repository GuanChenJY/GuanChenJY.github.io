<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Spring-AOP%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Spring-AOP%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">Spring AOP理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 16:41:18" itemprop="dateCreated datePublished" datetime="2021-02-18T16:41:18+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:11:47" itemprop="dateModified" datetime="2021-02-23T21:11:47+08:00">2021-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、AOP概念"><a href="#1、AOP概念" class="headerlink" title="1、AOP概念"></a>1、AOP概念</h2><p>面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来。</p>
<ul>
<li>主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等等。</li>
<li>主要意图：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</li>
</ul>
<h2 id="2、AOP特点"><a href="#2、AOP特点" class="headerlink" title="2、AOP特点"></a>2、AOP特点</h2><blockquote>
<p>采用横向抽取机制，取代了传统纵向继承体系重复性代码</p>
</blockquote>
<h2 id="3、AOP底层实现"><a href="#3、AOP底层实现" class="headerlink" title="3、AOP底层实现"></a>3、AOP底层实现</h2><p>AOP底层使用动态代理实现。包括两种方式：</p>
<ul>
<li>使用JDK动态代理实现</li>
<li>使用cglib来实现</li>
</ul>
<p><strong>JDK动态代理实现：</strong></p>
<p> 只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。步骤如下：</p>
<ol>
<li>定义一个实现接口<code>InvocationHandler</code>的类</li>
<li>通过构造函数，注入被代理类</li>
<li>实现<code>invoke（ Object proxy, Method method, Object[] args）</code>方法</li>
<li>在主函数中获得被代理类的类加载器</li>
<li>使用<code>Proxy.newProxyInstance( )</code>产生一个代理对象</li>
<li>通过代理对象调用各种方法</li>
</ol>
<p><strong>cglib动态代理实现：</strong></p>
<p>针对类实现代理，对是否实现接口无要求。原理是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法最好不要声明为final类型。</p>
<ul>
<li>定义一个实现了<code>MethodInterceptor</code>接口的类</li>
<li>实现其<code>intercept（）</code>方法，在其中调用<code>proxy.invokeSuper( )</code></li>
</ul>
<p><strong>代理方式的选择</strong></p>
<ol>
<li>如果目标对象实现了接口，默认情况下回采用JDK的动态代理实现AOP，也可以强制使用cglib实现AOP</li>
<li>如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换</li>
</ol>
<p><strong>静态代理和动态代理的区别：</strong></p>
<ul>
<li>静态代理：自己编写创建代理类，然后再进行编译，在程序运行前，代理类的.class文件就已经存在了。</li>
<li>动态代理：在实现阶段不用关心代理谁，而在运行阶段（通过反射机制）才指定代理哪一个对象。</li>
</ul>
<h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><p><img src="https://img-blog.csdn.net/20170716175506888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20170716175528540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="5、AOP操作术语"><a href="#5、AOP操作术语" class="headerlink" title="5、AOP操作术语"></a>5、AOP操作术语</h2><ul>
<li><strong>Joinpoint(连接点)</strong>: 类里面可以被增强的方法，这些方法称为连接点</li>
<li><strong>Pointcut(切入点)</strong>:所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li><strong>Advice(通知/增强)</strong>:所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</li>
<li><strong>Aspect(切面)</strong>: 是切入点和通知（引介）的结合</li>
<li><strong>Introduction(引介)</strong>:引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.</li>
<li><strong>Target(目标对象)</strong>:代理的目标对象(要增强的类)</li>
<li><strong>Weaving(织入)</strong>:是把增强应用到目标的过程，把advice 应用到 target的过程</li>
<li><strong>Proxy（代理）</strong>:一个类被AOP织入增强后，就产生一个结果代理类  </li>
</ul>
<p>其实我们只需要这么记忆即可：</p>
<ul>
<li><p><strong><em>\</em>切入点：**</strong>在类里边可以有很多方法被增强，比如实际操作中，只是增强了个别方法，则定义实际被增强的某个方法为切入点。</p>
</li>
<li><p><strong>通知/增强：</strong></p>
<p>增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强。包括：</p>
<ul>
<li><strong>前置通知</strong>：在方法之前执行</li>
<li><strong>后置通知</strong>：在方法之后执行</li>
<li><strong>异常通知</strong>：方法出现异常执行</li>
<li><strong>最终通知</strong>：在后置之后执行</li>
<li><strong>环绕通知</strong>：在方法之前和之后执行</li>
</ul>
</li>
<li><p><strong><em>切面：*</em></strong>把增强应用到具体方法上面的过程称为切面。</p>
</li>
</ul>
<h2 id="6、AOP操作案例"><a href="#6、AOP操作案例" class="headerlink" title="6、AOP操作案例"></a>6、AOP操作案例</h2><p><strong>导入和AOP相关的jar包</strong></p>
<p><img src="https://img-blog.csdn.net/20170716180550635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>创建Spring核心配置文件，导入aop约束</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用表达式配置切入点</strong></p>
<p>常用的表达式：<br>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p>
<ul>
<li>execution(* cn.itcast.aop.Book.add(..))</li>
<li>execution(* cn.itcast.aop.Book.*(..))</li>
<li>execution(* <em>.</em>(..))</li>
<li>匹配所有save开头的方法 execution(* save*(..))</li>
</ul>
<h2 id="7、举例"><a href="#7、举例" class="headerlink" title="7、举例"></a>7、举例</h2><p>1、首先定义一个Book类，里边有方法add（），也就是切入点（被增强的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;add...........&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义一个MyBook类，里边有可以用来增强的方法，即某些功能方法代码。我们要实现的就是将某些功能方法加入切入点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBook</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前置增强......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置增强......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//环绕通知</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around1</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//方法之前</span></span><br><span class="line">		System.out.println(<span class="string">&quot;方法之前.....&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//执行被增强的方法</span></span><br><span class="line">		proceedingJoinPoint.proceed();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方法之后</span></span><br><span class="line">		System.out.println(<span class="string">&quot;方法之后.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、核心配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 1  配置对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.ywq.aop.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBook&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.ywq.aop.MyBook&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 2 配置aop操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2.1 配置切入点 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.ywq.aop.Book.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.2 配置切面 </span></span><br><span class="line"><span class="comment">			把增强用到方法上面</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myBook&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 配置增强类型 </span></span><br><span class="line"><span class="comment">				method： 增强类里面使用哪个方法作为前置</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;after1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、测试类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnno</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = </span><br><span class="line">				<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">		Book book = (Book) context.getBean(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">		book.add();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、结果如下：        </p>
<p><img src="https://img-blog.csdn.net/20170716181323013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>以上就是使用aop的一个基本简单介绍，这样便可以在业务逻辑代码前后加一些功能性代码了，比如<strong>日志记录，性能统计，安全控制，事务处理，异常处理</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/spring-core%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/spring-core%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">spring-core源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-18 11:55:17 / 修改时间：12:41:32" itemprop="dateCreated datePublished" datetime="2021-02-18T11:55:17+08:00">2021-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>本部分从最基本的Spring开始。配置文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;base.SimpleBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line">    SimpleBean bean = context.getBean(SimpleBean.class);</span><br><span class="line">    bean.send();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am send method from SimpleBean!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/ResourceLoader.jpg" alt="ResourceLoader继承体系"></p>
<p>ResourceLoader代表了<strong>加载资源的一种方式，正是策略模式的实现。</strong></p>
<p>构造器源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getResourcePatternResolver:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p>
<h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolvePath:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: <code>new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);</code>那么classpath:就是需要被解析的。</p>
<p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/Environment.jpg" alt="Environment继承体系"></p>
<p>Environmen接口<strong>代表了当前应用所处的环境。</strong>从此接口的方法可以看出，其主要和profile、Property相关。</p>
<h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。<strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong>使用了Profile的配置文件示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;develop&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-develop.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-production.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-test.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动代码中可以用如下代码设置活跃Profile:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">&quot;dev&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p>
<blockquote>
<p>properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.</p>
</blockquote>
<h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertySources.jpg" alt="PropertySources继承体系"></p>
<p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p>
<p>StandardEnvironment.customizePropertySources:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** System environment property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">&quot;systemEnvironment&quot;</span>;</span><br><span class="line"><span class="comment">/** JVM system properties property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">&quot;systemProperties&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource</span><br><span class="line">        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource</span><br><span class="line">        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>PropertySource接口代表了键值对的Property来源。继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertySource.jpg" alt="PropertySource继承体系"></p>
<p>AbstractEnvironment.getSystemProperties:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) System.getProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) <span class="keyword">new</span> ReadOnlySystemAttributesMap() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">getSystemAttribute</span><span class="params">(String attributeName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(attributeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(format(<span class="string">&quot;Caught AccessControlException when accessing system &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;property [%s]; its value will be returned [null]. Reason: %s&quot;</span>,</span><br><span class="line">                                attributeName, ex.getMessage()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p>
<p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p>
<h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="comment">//text即配置文件路径，比如classpath:config.xml</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">            <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure>

<h5 id="ProperytResolver接口"><a href="#ProperytResolver接口" class="headerlink" title="ProperytResolver接口"></a>ProperytResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertyResolver.jpg" alt="PropertyResolver继承体系"></p>
<p>此接口正是用来解析PropertyResource。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三个参数分别是$&#123;, &#125;, :</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</span><br><span class="line">        <span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doResolvePlaceholders：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PlaceholderResolver接口依然是策略模式的体现</span></span><br><span class="line">    <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPropertyAsRawString(placeholderName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;spring&quot;</span>, <span class="string">&quot;classpath&quot;</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;$&#123;spring&#125;:config.xml&quot;</span>);</span><br><span class="line">SimpleBean bean = context.getBean(SimpleBean.class);</span><br></pre></td></tr></table></figure>

<p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProperty(key, String.class, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p>
<p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p>
<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/10/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">图解http笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-10 16:47:52" itemprop="dateCreated datePublished" datetime="2021-02-10T16:47:52+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-15 15:24:45" itemprop="dateModified" datetime="2021-02-15T15:24:45+08:00">2021-02-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）</p>
<h3 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h3><p><strong>TCP/IP协议族</strong></p>
<p>TCP/IP协议族是互联网相关联的协议的集合。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及web页面显式需要处理的步骤，等等。而http是属于它内部的一个子集。</p>
<p><strong>TCP/IP的分层管理</strong></p>
<p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。 分层的好处：把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。而且，层次化之后，设计也变得相对简单。处于应用层上的应用可以只考虑分派给自己的任务，而无需弄清对方在地球上哪个地方、对方的传输路线、是否能确保传输送达等问题。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。TCP/IP协议族预存了各类通用的应用服务。如FTP（File Transfer Protocol）、DNS和HTTP。</li>
<li>传输层：该层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP和UDP。</li>
<li>网络层：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎么样的路径到达对方计算机。</li>
<li>链路层：用来处理网络的硬件部分。</li>
</ul>
<p><strong>TCP/IP通信传输流</strong></p>
<p><img src="https://camo.githubusercontent.com/b042898f685e28b66c740535b1d8e7b950bcdcdf841ba9a27ce28062684415c4/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d392e6a7067" alt="缺一张照片P9"></p>
<p>利用TCP/IP协议族进行网路通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>用HTTP 举例来说：首先作为发送端的客户端在应用层（HTTP协议）发出一个HTTP请求。 接着，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分隔，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这就让发往网络的通信请求准备齐全了。 接收端的服务器在链路层接收到数据后，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到客户端发送过来的HTTP请求。</p>
<p><img src="https://camo.githubusercontent.com/cfd3eff10113cb844f43eb253477d20e763cb1989d3dbae7317ecb5cbfff0b7e/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31302e6a7067" alt="&gt; 缺一张照片P10"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h3><p><strong>负责传输的IP协议</strong></p>
<p>IP（网际协议）位于网络层。该协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中最重要的两个条件是 IP 地址和 MAC地址。 IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。</p>
<p><strong>使用ARP协议凭借MAC地址进行通信</strong> IP间通信通信依赖MAC地址。通信的双方通常会经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。该协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>
<p><img src="https://camo.githubusercontent.com/5e168ebb2e85b5042d51ec7abd0bbcf144009610a869e29f978a4cbaf2e9f698/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31322e6a7067" alt="此处输入图片的描述"></p>
<p><strong>确保可靠性的TCP协议</strong></p>
<p>TCP属于传输层，提供可靠的字节流服务。字节流服务是指：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。这就是为什么下载高清大图时，图片会一块一块地加载。</p>
<p><strong>三次握手</strong>为了准确无误地将数据送达目标处，TCP协议在发送数据的准备阶段采用了三次握手策略（若在握手过程中某个阶段中断，TCP协议会再以相同的顺序发送相同的数据包）。</p>
<p><img src="https://camo.githubusercontent.com/5052b0fda439c493c0305e9495deba5a0cd316dd951cc83c42a03184bdeb381b/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31332e6a7067" alt="&gt; 缺图片P13"></p>
<p>当然，除了三次握手，TCP还有其它各种手段确保通信的可靠性。</p>
<h3 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h3><p>DNS服务提供域名到IP地址之间的解析服务。即可通过域名查找IP，或逆向从IP地址反查询域名服务。</p>
<p><img src="https://camo.githubusercontent.com/ca546afb0ebd451b7926a76a6398c1fb12503241d10438eedfdf50d9dad713a1/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31342e6a7067" alt="此处输入图片的描述"></p>
<p><strong>URI和URL</strong></p>
<p>URI（uniform Resource Identifier）Uniform:规定统一的格式可方便处理多种不同类型的资源。Resource:可标识的任何东西Identifier:标识符</p>
<p>URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称，如http、ftp。</p>
<p>URI 用字符串标识某一个互联网资源，而URL表示资源的地点。URL是URI的子集。</p>
<p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处指定的URL，如<code>/image/logo.gif</code>.</p>
<p>绝对URI的格式如下：</p>
<p><img src="https://camo.githubusercontent.com/ef4a26a5f83c09791980bc94140312b926c480f3edc182af01c111d8eb9cd7e2/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31382e6a7067" alt="图片P18"></p>
<h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>HTTP协议规定，先从客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。</p>
<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p><img src="https://camo.githubusercontent.com/60c9513a2ca5927f006b20a8950f59d84b8c3d2f3ff8d58d0561e295b2821e37/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d32342e6a7067" alt="&gt; 图片P24"></p>
<p>响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<p><img src="https://camo.githubusercontent.com/ac4031c04d349053fd3818439b5a21f8da096ea5aefd6519e95e8a99a61f4f43/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d32352e6a7067" alt="&gt; 图片P25"></p>
<p><strong>HTTP是不保存状态的协议</strong></p>
<p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议得可伸缩性。HTTP/1.1随时无状态协议，但可通过Cookie技术保存状态。</p>
<h3 id="告知服务器意图得HTTP方法"><a href="#告知服务器意图得HTTP方法" class="headerlink" title="告知服务器意图得HTTP方法"></a>告知服务器意图得HTTP方法</h3><ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li>
<li>DELETE：删除文件，与PUT相反</li>
<li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法</li>
<li>TRACE：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理</li>
</ul>
<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。方法名区分大小写，主要要用大写字母。</p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p><strong>持久连接</strong></p>
<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>
<p><img src="https://camo.githubusercontent.com/0b38dcc8b73925247087cf4f96e5af05c1a083d815d013777e51a75764f0c559/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33342e6a7067" alt="此处输入图片的描述"></p>
<p>发送请求一份包含多张图片的HTML文档对应的Web页面，会产生大量通信开销。</p>
<p><img src="https://camo.githubusercontent.com/97d2b88a8927bd5c1ae2d8dbf8b4345ee3c4084dd973724e9a236353b4a0a8df/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33352e6a7067" alt="此处输入图片的描述"></p>
<p>为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP Connection resue）的方法。 <strong>持久连接的特点</strong>是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p><img src="https://camo.githubusercontent.com/463cfc1f1f34386f3c4d2613e49e5ac24ca009c6137c466c7c10d05da501ba97/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33362e6a7067" alt="TCP持久连接"></p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也相应提高了。</p>
<p>在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。 毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>
<p><strong>管线化</strong></p>
<p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>注意：尽管HTTP管线化可以克服同域并行请求限制带来的阻塞，但HTTP/1.x有严格的串行返回响应机制，服务器通过TCP连接返回响应时，就是必须按照客户端的请求顺序进行响应，前一个响应没有完成，下一个响应就不能返回。所以使用“HTTP管道”技术时，万一第一个响应时间很长，那么后面的响应处理完了也无法发送，只能被缓存起来，占用服务器内存，这就是传说中的“队首阻塞”。</p>
<h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存Cookie当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>用于HTTP协议交互的信息被称为HTTP报文，请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。</p>
<p>HTTP报文本身是由多行（用CR+LF做换行符）数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两部块。两者由最初出现的空行（CR+LF、回车符+换行符）来划分。通常，并不一定要有报文主体。</p>
<h3 id="编码提升传输效率"><a href="#编码提升传输效率" class="headerlink" title="编码提升传输效率"></a>编码提升传输效率</h3><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率，但这会消耗更多的CPU等资源。</p>
<p><strong>报文主体和实体主体的差异</strong></p>
<p>报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<p><strong>压缩传输的内容编码</strong></p>
<p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。 常见的内容编码有：gzip（GNU zip）、compress（UNIX系统的标准压缩）、deflate（zlib）、identity（不进行编码）</p>
<p><strong>分隔发送的分块传输编码</strong></p>
<p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。 这种把实体主体分块的功能称为<strong>分块传输编码</strong>（Chunked Transfer Coding）。</p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常实在图片或文本文件等上传时使用。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>下载大尺寸的图片的过程中，如果网络中断，则需要重新下载。因此需要一种可恢复的机制。 实现该功能需要指定下载的实体范围，像这样，指定范围发送的请求叫做<strong>范围请求</strong>。 执行范围请求时，会用到首部字段Range来指定资源的byte范围。响应会返回状态码206 Partial Content。</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。状态码如200 OK，以3为数字和原因短语组成。数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="常用的状态码14种："><a href="#常用的状态码14种：" class="headerlink" title="常用的状态码14种："></a>常用的状态码14种：</h3><p><strong>2XX成功</strong></p>
<ul>
<li>200 OK：请求被正常处理</li>
<li>204 No Content:一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：客户端进行范围请求</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/" class="post-title-link" itemprop="url">restful风格API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-10 16:07:24 / 修改时间：16:43:20" itemprop="dateCreated datePublished" datetime="2021-02-10T16:07:24+08:00">2021-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>REST – REpresentational State Transfer直译：表现层状态转移。</strong></p>
<p>全称是Resource Representational State Transfer：通速来讲就是资源在网络中以某种表现形式进行状态转移。分解开来：</p>
<p>Resource:资源，即数据。比如newsfeed，friends等；</p>
<p>Representational:某种表现形式，比如用json、xml、jpeg等；</p>
<p>State Transfer：状态变化，通过http动词实现。</p>
<p><strong>为什么用RESTful结构呢？</strong></p>
<p>大家都知道”古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。</p>
<p><img src="https://img-blog.csdn.net/20171107171036253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>从原理角度来分析：</strong></p>
<p>根据Richardson Maturity Model（理查德森成熟度模型）, REST架构的成熟度有4个等级：</p>
<p><img src="https://img-blog.csdn.net/20171107165849966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>Level 0-面向前台</strong></p>
<p>我们在咖啡店向前台点了一杯拿铁，这个过程可以用这段文字来描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡，接着，前台给我们返回这么一串回复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="number">447031335</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询卡号为447031335的卡的余额，查询的结果返回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;balance&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没钱……<br>哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level 1-面向资源</strong></p>
<p>现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。<br>比如还是下单，请求的内容不变，但是我们多了一条消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个斜杠和orders，这是什么意思？<br>这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作。<br>接着还是会返回订单的编号给我们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们还是要查询会员卡余额，这次请求的资源变成了cards：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="string">&quot;447031335&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level2 -打上标签</strong></p>
<p>接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求。<br>其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示，修改用PATCH表示。<br>来，我们再来重复上面那个过程，来一杯拿铁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增，返回的内容还是一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是查询会员卡余额，这次也简化了很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;447031335&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个请求我们还可以进一步优化为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /cards/<span class="number">447031335</span></span><br></pre></td></tr></table></figure>

<p>直接把要查询的卡号写在后面了。<br>没错，接着，取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>Level 3 -完美服务</strong></p>
<p>忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/&#123;orderId&#125;</span><br></pre></td></tr></table></figure>

<p>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……后面两人吵着吵着还打了起来…<br>噗，真是悲剧…<br>有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这次返回时多了些内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;link&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;rel&quot;</span>: <span class="string">&quot;cancel&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/order/123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了。<br>Level3的Restful API，给使用者带来了很大的遍历，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。<br>现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，这个模型并不是一种规范，只是用来理解Restful的工具。所以，做到了Level2，也就是面向资源和使用Http动词，就已经很Restful了。</p>
<p><strong>Levels的意义</strong></p>
<p>Level1解释了如何通过分治法（Divide and Conquer）来处理复杂问题，将一个大型的服务端点（Service Endpoint）分解成多个资源。</p>
<p>Level 2引入了一套标准的动词，用来以相同的方式应对类似的场景，移除不要的变化。</p>
<p>Level 3引入了可发现性（Discoverability），它可以使协议拥有自我描述（Self-documenting）的能力。</p>
<p><strong>从应用角度来分析：</strong></p>
<p>一、REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计RESTful API;</p>
<p>二、Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。</p>
<p>URL定位资源，用HTTP动词（GET，POST，DELETE，DETC）描述操作。</p>
<p>1、看Url就知道要什么<br>2、看http method就知道干什么<br>3、看http status  code就知道结果如何</p>
<p><a target="_blank" rel="noopener" href="http://api.qc.com/v1/newsfeed">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;</p>
<p>三、用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：</p>
<p>GET用来获取资源</p>
<p>POST用来新建资源</p>
<p>PUT用来更新资源</p>
<p>DELETE用来删除资源</p>
<p>比如：<br>DELETE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 删除某人的好友 （在http parameter指定好友id）<br>POST <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 添加好友<br>UPDATE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 更新个人资料</p>
<p>四、Server和Client之间传递某资源的一个表现形式，比如用json，xml传输文本，或者用jpg，webP传输图片等。当然还可以压缩HTTP传输时的数据。</p>
<p>五、用HTTP Status Code传递Server的状态信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">java并发volatile关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 14:00:00 / 修改时间：18:29:13" itemprop="dateCreated datePublished" datetime="2021-02-08T14:00:00+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>摘要：</strong>在java并发编程中，要想使并发程序能够正确地执行，必须要保证三条原则，即：原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致运行不正确。volatile关键字被用来保证可见性，即保证共享变量的内存可见性解决缓存一致性问题。一旦一个共享变量被volatile关键字修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。在多线程环境下，volatile关键字主要用于及时感知共享共享变量的修改，并使得其他线程可以立即得到变量的最新值，例如，用于修饰状态标记量和Double-Check中。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与内存模型紧密相关，因此在讲述volatile关键字之前，我们有必要先去了解与内存模型相关的概念和知识，然后回头再分析volatile关键字的实现原理，最后再给出volatile关键字的使用场景。</p>
<h2 id="一、内存模型的相关概念"><a href="#一、内存模型的相关概念" class="headerlink" title="一、内存模型的相关概念"></a>一、内存模型的相关概念</h2><p>由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。</p>
<p>也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行这个语句时，会先从主存当中读取 i 的值，然后复制一份到高速缓存当中，然后CPU执行指令对 i 进行加1操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如，同时有两个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。</p>
<p>最终结果i的值是1，而不是2.这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，<strong>如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 \</strong>缓存不一致** 的问题。**</p>
<p>为了解决缓存不一致性问题，在 <strong>硬件层面</strong> 上通常来说有以下两种解决方法：</p>
<p>　　1）通过在 <strong>总线加 LOCK# 锁</strong> 的方式 <strong>（在软件层面，效果等价于使用 synchronized 关键字）</strong>；</p>
<p>　　2）通过 <strong>缓存一致性协议</strong> <strong>（在软件层面，效果等价于使用 volatile 关键字）</strong>。</p>
<p>在早期的CPU当中，是通过在总线上加Lock锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问，从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中，如果一个线程在执行i=i+1，如果在执行这段代码的过程中，在总线上发出了LOCK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i的所在的内存读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以，就出现了缓存一致性协议，其中最出名的就是Intel的MESI协议。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的吃变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。因此，当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="二、并发编程中的三个概念"><a href="#二、并发编程中的三个概念" class="headerlink" title="二、并发编程中的三个概念"></a>二、并发编程中的三个概念</h2><p>原子性问题、可见性问题、有序性问题</p>
<p>1、原子性</p>
<p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>银行转账的例子</p>
<p>2、可见性</p>
<p>可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>3、有序性</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 int型 变量，定义了一个 boolean型 变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1 是在 语句2 前面的，那么 JVM 在真正执行这段代码的时候会保证 语句1 一定会在 语句2 前面执行吗？不一定，为什么呢？这里可能会发生 <strong>指令重排序（Instruction Reorder）</strong>。</p>
<p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。</p>
<p>比如上面的代码中，语句1 和 语句2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中， 语句2 先执行而 语句1 后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>那么可不可能是这个执行顺序呢： 语句2　-&gt;　语句1　-&gt;　语句4　-&gt;　语句3</p>
<p>　　答案是不可能，因为处理器在进行重排序时会考虑指令之间的 <strong>数据依赖性</strong>，如果一个指令 Instruction 2 必须用到 Instruction 1 的结果，那么处理器会保证 Instruction 1 会在 Instruction 2 之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面，看一个例子：</p>
<p>虽然 <strong>重排序不会影响单个线程内程序执行的结果</strong>，但是多线程呢？下面，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 语句1 和 语句2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在 线程1 执行过程中先执行 语句2，而此时 线程2 会以为初始化工作已经完成，那么就会跳出 while循环 ，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，<strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="三、java内存模型"><a href="#三、java内存模型" class="headerlink" title="三、java内存模型"></a>三、java内存模型</h2><p><strong>在 Java虚拟机规范 中，试图定义一种 *Java内存模型（Java Memory Model，JMM）* 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</strong>那么，Java内存模型 规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在 Java内存模型 中，也会存在缓存一致性问题和指令重排序的问题。</strong></p>
<p>java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>　　执行线程必须先在自己的工作线程中对 变量i 所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。那么，Java语言本身对原子性、可见性以及有序性 提供了哪些保证呢？</p>
<p>1、原子性</p>
<p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的：要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子，请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>乍一看，有些朋友可能会说上面的四个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是线程执行这个语句的会直接将数值10写入到工作内存中；</p>
<p>语句2实际上包含两个操作，它先要去读取x的值，再将x的值写入工作内存。虽然，读取x的值以及将x的值写入工作内存这两个操作都是原子性操作，但是合起来就不是原子性操作了；</p>
<p>同样的，x++和x=x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以，上面四个语句只有语句1的操作具备原子性。也就是说，只有简单的读取，赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过，这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p>2、可见性</p>
<p>对于可见性，java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronzied和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修饰刷新到主存当中，因此可以保证可见性。</p>
<p>3、有序性</p>
<p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在java中，可以通过volatile关键字来保证一定的“有序性”。另外，我们千万不能想当然地认为，可以通过synchronized和Lock来保证有序性，也就是说，不能由于synchonized和Lock可以让线程串行地同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 <strong>happens-before 原则</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>先行发生原则：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测代中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ul>
<h2 id="四、深入剖析volatile关键字"><a href="#四、深入剖析volatile关键字" class="headerlink" title="四、深入剖析volatile关键字"></a>四、深入剖析volatile关键字</h2><p>1、volatile关键字的两层语义</p>
<p>一旦一个共享变量被volatile修饰后，那么就具备了两层语义：</p>
<p><strong>1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 \</strong>立即可见** 的；**</p>
<p><strong>2）禁止进行指令重排序。</strong></p>
<p>先看一段代码，假如 线程1 先执行，线程2 后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p><img src="https://img-blog.csdn.net/20170116141631367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程读取数据模型"></p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，如上图所示，每个线程在运行过程中都有自己的工作内存，那么 线程1 在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么，当 线程2 更改了 stop变量 的值之后，可能会出现以下两种情形：</p>
<ul>
<li>线程2对变量的修改没有立即刷入到主存当中；</li>
<li>即使线程2对变量的修改立即反映到主存中，线程1也可能由于没有立即知道线程2对stop变量的更新而一直循环下去。</li>
</ul>
<p>这两种情形都会导致线程1处于死循环。但是，用volatile关键字修饰后就变得不一样了，如下图所示：</p>
<p>1、使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>2、使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；</p>
<p>3、由于线程1的工作内存中缓存变量stop的缓存行无效，所以，线程1再次读取变量stop的值时会去主存读取。</p>
<p>综上，<strong>在 线程2 修改 stop 值时（当然这里包括两个操作，修改 线程2 工作内存中的值，然后将修改后的值写入内存），会使得 线程1 的工作内存中缓存变量 stop 的缓存行无效，然后 线程1 读取时，会发现自己的缓存行无效从而去对应的主存读取最新的值 。**</strong>简化一下，通过使用 volatile 关键字，如下图所示，线程会及时将变量的新值更新到主存中，并且保证其他线程能够立即读到该值。**这样，线程1 读取到的就是最新的、正确的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java数组综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 11:45:40 / 修改时间：13:59:39" itemprop="dateCreated datePublished" datetime="2021-02-08T11:45:40+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、要点概览"><a href="#一、要点概览" class="headerlink" title="一、要点概览"></a>一、要点概览</h2><ul>
<li>数组与容器</li>
<li>数组的创建与初始化</li>
<li>数组与泛型</li>
<li>数组与可变参数列表</li>
<li>Arrays工具类的使用功能</li>
</ul>
<h2 id="二、数组与容器"><a href="#二、数组与容器" class="headerlink" title="二、数组与容器"></a>二、数组与容器</h2><p>早期java数组的几个特点：</p>
<ul>
<li><p>效率</p>
<p>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。由于ArrayList可以实现空间的自动分配且更为灵活，所以，通常应首选ArrayList而不是数组，但是ArrayList的效率比数组低的多。</p>
</li>
<li><p>类型</p>
<p>在 JDK 1.5 之前，Java 并未引进泛型。所以，泛型之前的容器类在处理对象时，都将它们视作没有任何具体类型，即将这些对象都当作 Object 来处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体的类型。这意味着你可以通过编译期的类型检查来防止插入错误类型和抽取不当类型。当然，无论在编译时还是运行时，Java都会阻止你向对象发送不恰当的消息。所以，并不是说哪种方法更不安全，只是若编译时就能够指出错误，会显得更为优雅。</p>
</li>
<li><p>保存基本类型的能力</p>
<p>数组可以持有基本类型，而泛型之前的容器则不能。JDK1.5之后，java引进了泛型和自动包装机制，这使得现在的容器除了性能之外的各个方面都使得数组相形见绌。</p>
</li>
</ul>
<h2 id="三、数组的创建与初始化"><a href="#三、数组的创建与初始化" class="headerlink" title="三、数组的创建与初始化"></a>三、数组的创建与初始化</h2><p>1、数组基础</p>
<ul>
<li>数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用或基本类型的值；</li>
<li>对象数组保存的是引用，基本类型数组直接保存基本类型的值；</li>
<li>“[]”语法是访问数组对象的唯一方式；</li>
</ul>
<p>2、创建与初始化</p>
<ul>
<li><p>作为数组初始化的一部分隐式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=&#123;...&#125;;	<span class="comment">//花括号内对象的个数就是数组大小</span></span><br><span class="line">System.out.println(strs.length);	<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用new表达式显式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=<span class="keyword">new</span> String[<span class="number">5</span>];	<span class="comment">//创建方式2</span></span><br><span class="line">String[] ss = <span class="keyword">new</span> String[]&#123;...&#125;;	<span class="comment">//创建方式3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3、多维数组</p>
<p>多维数组的本质：数组的元素仍是数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方式 1</span></span><br><span class="line"><span class="keyword">int</span>[][] a = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;, </span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;, </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式 2</span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//粗糙数组：每个向量具有任意长度</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-D array with varied-length vectors: </span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123; </span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)][]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) </span><br><span class="line">        a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="四、数组与泛型"><a href="#四、数组与泛型" class="headerlink" title="四、数组与泛型"></a>四、数组与泛型</h2><ul>
<li><p>数组与泛型不能很好的结合，也就是说，不能实例化具有参数化类型的数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[] first = <span class="keyword">new</span> T[<span class="number">3</span>];    <span class="comment">// ERROR  </span></span><br><span class="line">A&lt;String&gt;[] arrays = <span class="keyword">new</span> A&lt;String&gt;[<span class="number">4</span>];    <span class="comment">// ERROR: Cannot create a generic array of A&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以创建泛型数组引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;String&gt;[] arrays;	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组是协变的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs=<span class="keyword">new</span> String[<span class="number">3</span>];	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>总之，泛型容器总是比泛型数组更好的选择。</p>
<h2 id="五、数组与可变参数类型"><a href="#五、数组与可变参数类型" class="headerlink" title="五、数组与可变参数类型"></a>五、数组与可变参数类型</h2><p>1、可变参数类型概念</p>
<p>Java SE5 添加了可变参数类型 ( Variable Argument Type )，形式为 “Type… args”，<strong>只可用作方法的参数</strong>。<strong>可变参数列表适用于参数个数不确定但类型确定的情形 ( java 把可变参数当做数组处理 )。</strong>特别需要注意的是，<strong>可变参数列表必须位于最后一项 (即最多只支持一个可变参数)。</strong>当可变参数列表个数多余一个时，必将有一个不是最后一项，所以只支持一个可变参数。因为可变参数列表的参数个数不确定，所以当其后边还有相同类型参数时，Java 无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();  </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1   </span></span><br><span class="line"><span class="comment">        1 2 3   </span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~  </span></span><br></pre></td></tr></table></figure>

<p>可变参数列表具有以下特点：</p>
<ul>
<li>只能出现在方法参数列表的最后；</li>
<li>…位于变量类型和变量名之间，前后有无空格都可以；</li>
<li>调用可变参数所在的方法时，编译器会为该可变参数隐式创建一个数组，从而我们可以在方法体中以数组的形式访问可变参数列表。</li>
</ul>
<p>2、可变参数类型与数组的兼容性</p>
<ul>
<li>编译器认为数组类型和可变参数类型是相同的，即二者不能重载；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//ERROR : Duplicate method dealArray(int[]) in type TestVarArgus </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();   </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>可变参数是兼容数组类型参数的，但是数组类型参数却无法兼容可变参数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 1 ： 给参数为可变参数类型的方法传递数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line"></span><br><span class="line">        dealArray(intArray);  <span class="comment">// OK</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 2 ： 给参数为数组类型的方法传递可变参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// ERROR</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其实，对于示例代码 2 而言，只是需要一个定义为 dealArray(int, int, int）的方法或者一个定义为 dealArray(int… ）的方法。所以，自然就无法去匹配具有数组类型的参数 dealArray( int[] ) 方法了。</p>
<ul>
<li>参数匹配原则：能匹配定长的方法，那么优先匹配该方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//含有不定参数的那个重载方法是最后被选中的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bad&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> count2)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bingo&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">    dealArray(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">        Bingo </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Arrays工具类的实用功能"><a href="#六、Arrays工具类的实用功能" class="headerlink" title="六、Arrays工具类的实用功能"></a>六、Arrays工具类的实用功能</h2><p>1、复制数组</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Introduction</th>
<th>Note</th>
</tr>
</thead>
<tbody><tr>
<td>System.arraycopy(<strong>Object src,</strong> int srcPos, <strong>Object dest,</strong> int destPos, int length)</td>
<td>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</td>
<td>若复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝(浅复制)；<strong>该方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确切类型；**</strong>须明确自行新建立一个数组对象，作为副本**</td>
</tr>
<tr>
<td>copyOf(T[] original, int newLength)</td>
<td>复制指定的数组，<strong>截取或用 null 填充</strong></td>
<td><strong>底层调用的还是 System.arraycopy；返回一个新的数组对象，若新数组的长度超过原数组的长度，则保留数组默认值</strong></td>
</tr>
</tbody></table>
<p>注意</p>
<p>对于以上两个方法：</p>
<ul>
<li>若赋值对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝；</li>
<li>这两个方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确认类型。</li>
</ul>
<p>2、数组的字符串方式表示</p>
<p>方法：Arrays.toString(Object[] a)    //Arrays.deepToString(Object[] a)</p>
<p>作用：返回指定数组内容字符串表示形式：前者适用于一维数组，或者适用于多维数组</p>
<p>3、数组的比较</p>
<p>方法：Arrays.equals(Object[] a, Object[] a2)    //deepEquals(Object[] a, Object[] a2)</p>
<p>作用：比较两个数组：元素类型相同，元素个数相等，对应位置的元素相同；</p>
<p>注意：</p>
<ul>
<li>通过对每个元素使用equals()作比较来判断；</li>
<li>对于基本类型，使用的是基本类型的包装器类的equals()方法；</li>
<li>使用equals()方法比较原则：是不是同一个对象，是不是同一个类型，是不是具有相同的内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line">Arrays.fill(a1, <span class="number">47</span>); </span><br><span class="line">Arrays.fill(a2, <span class="number">47</span>); </span><br><span class="line">print(Arrays.equals(a1, a2));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>4、数组的排序</p>
<p>使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组进行排序，只要该对象实现了Comparable接口或具有相关联的Comparator。</p>
<p><strong>方法：</strong> Arrays.sort(Object[] a) / Arrays.sort(Object[] a, int fromIndex, int toIndex)<br>　　　Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) / Arrays.sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> <strong>对数组内元素进行升序排序 (默认)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = Generated.array(<span class="keyword">new</span> String[<span class="number">20</span>], <span class="keyword">new</span> RandomGenerator.String(<span class="number">5</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 String 内置的比较器（已实现 Comparable 接口）：字典序（大写字母开头的词都放在前面输出，之后才是小写字母开头的词）</span></span><br><span class="line">Arrays.sort(sa);   <span class="comment">// ... ,WHkjU, YNzbr, bkIna, cQrGs, ...</span></span><br><span class="line">.</span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： Collections.reverseOrder() ： 现有顺序的逆序</span></span><br><span class="line">Arrays.sort(sa, Collections.reverseOrder()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： String.CASE_INSENSITIVE_ORDER : 忽略大小写将单词一起进行排序</span></span><br><span class="line">Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); </span><br></pre></td></tr></table></figure>

<p>5、在已排序的数组中查找</p>
<p><strong>若数组已经 \</strong>排好序*<em>，就可以使用该方法执行快速查找；*</em>若对未排序的数组使用该方法，将产生不可预料的结果。****</p>
<p><strong>方法：</strong> binarySearch(Object[] a, Object key) / binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> 使用 <strong>二分搜索法</strong> 来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的自然顺序对数组进行<strong>升序排序（通过 sort(Object[]) 方法）</strong>; 使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过 sort(T[], Comparator) 方法）对数组进行<strong>多态**</strong>升序排序**。</p>
<p>注意：</p>
<ul>
<li>对已经有序的数组进行查找；</li>
<li>若找到了目标，方法返回的值不小于0；否则，它产生的负返回值表示在此排序下应插入的位置；</li>
<li>“sort(Object[])” 与 “binarySearch(Object[] a, Object key)” 对应，“sort(T[], Comparator)” 与 binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) 对应。</li>
</ul>
<p><strong>若数组包含重复元素，则该方法无法保证找到的是哪一个元素；若需要对无重复元素的数组进行排序，可使用 TreeSet(保持排序顺序) 或 LinkedHashSet(保持插入顺序)进行排序。除非它们成为程序的瓶颈，否则不需要自己维护数组。</strong></p>
<p>6、填充数组</p>
<p><strong>方法：</strong> fill(Object[] a, Object val)<br><strong>作用：</strong> <strong>只能使用同一个值填充各个位置，而针对对象而言，就是复制同一个对象的引用进行填充</strong></p>
<p>7、数组与容器的转化</p>
<p><strong>方法：</strong> asList(T… a)<br><strong>作用：</strong> 返回一个 <strong>受指定数组支持的固定大小的列表</strong><br><strong>注意：</strong></p>
<ul>
<li>所得到的 List 是固定大小的，因为<strong>其底层表示即为该数组，因此不能调整大小。</strong>因此，调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException (可选操作)。</li>
<li>因此，<strong>Arrays.asList() 的真正意义在于：将其结果作为构造器参数传递给任何 Collection （或者使用 addAll 方法、Collections.addAll 静态方法），这样可以生成一个动态的容器。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java异常模型综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 16:28:12 / 修改时间：20:28:49" itemprop="dateCreated datePublished" datetime="2021-02-04T16:28:12+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、异常的引入及基础"><a href="#一、异常的引入及基础" class="headerlink" title="一、异常的引入及基础"></a>一、异常的引入及基础</h2><p>发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间编译器并不能找出所有的错误，余下的错误只有在运行期才能发现和解决，这类错误就是 <strong>Throwable。</strong> 这就需要错误源能够通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确的处理这个问题，这就是Java的错误报告机制 —— 异常机制。该机制使得程序把 <strong>在正常执行过程中做什么事的代码</strong> 与 <strong>出了问题怎么办的代码</strong> 相分离。</p>
<p>在对异常的处理方面，Java 采用的是 <strong>终止模型</strong> 。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。相对于终止模型，另一种异常处理模型为 <strong>恢复模型</strong>，它使异常被处理之后能够继续执行程序。虽然该模型很吸引人，但不是很实用，其主要原因是它所导致的耦合：恢复性处理程序需要了解异常的抛出地点，这势必要包含依赖于抛出位置的非通用代码，从而大大增加了代码编写和维护的难度。</p>
<p>在异常情形中，异常的抛出伴随着以下三件事的发生：</p>
<ul>
<li>首先，同java中其他对象的创建一样，将使用new在堆上创建异常对象；</li>
<li>其次，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用；</li>
<li>最后，异常处理机制接管程序，并开始寻找对应的异常处理程序，并将程序从错误状态中恢复。</li>
</ul>
<h2 id="二、java标准异常"><a href="#二、java标准异常" class="headerlink" title="二、java标准异常"></a>二、java标准异常</h2><p>1、基本概念</p>
<p><img src="https://img-blog.csdn.net/20160916105959789" alt="这里写图片描述"></p>
<p>- <strong>Throwable：所有的异常类型的根类</strong></p>
<p>　　在 Java 中，<strong>Throwable 是所有的异常类型的根类。</strong>Throwable 有两个直接子类：<strong>Exception</strong> 和 <strong>Error</strong>。二者都是 Java 异常处理的重要子类，各自都包含大量子类。<br>　<br>- <strong>Error：程序本身无法处理的错误</strong></p>
<p>　　<strong>Error 是程序无法处理的错误，表示运行应用程序中较严重问题。</strong>这些错误大部分与代码编写者执行的操作无关，而与代码运行时的 JVM 、资源等有关。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<strong>这些错误是不可查的，并且它们在应用程序的控制和处理能力之外。</strong>在 Java 中，错误通过Error的子类描述。</p>
<ul>
<li><p><strong>Exception：程序本身可以处理的错误</strong></p>
<p>　　Exception 通常是Java程序员所关心的，其在Java类库、用户方法及运行时故障中都可能抛出。它由两个分支组成： <strong>运行时异常（派生于 RuntimeException 的异常）</strong> 和 <strong>其他异常</strong> 。<strong>划分这两种异常的规则是：由程序错误（一般是逻辑错误，如错误的类型转换、数组越界等，应该避免）导致的异常属于RuntimeException；而程序本身没有问题，但由于诸如I/O这类错误（eg：试图打开一个不存在的文件）导致的异常就属于其他异常。</strong></p>
</li>
</ul>
<hr>
<p>此外，Java的异常(包括Exception和Error)通常可分为 <strong>受检查的异常（checked exceptions）</strong> 和 <strong>不受检查的异常（unchecked exceptions）</strong> 两种类型。</p>
<ul>
<li><p><strong>不受检查异常：派生于 Error 或 RuntimeException 的所有异常</strong></p>
<p>　　<strong>不可查异常是编译器不要求强制处理的异常</strong>，包括运行时异常（RuntimeException与其子类）和错误（Error）。也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
</li>
<li><p><strong>受检查异常：除去不受检查异常的所有异常</strong></p>
<p>　　<strong>受检查异常是编译器要求必须处理的异常。</strong>这里所指的处理方式有两种： <strong>捕获并处理异常</strong> 和<strong>声明抛出异常</strong> 。也就是说，当程序中可能出现这类异常，要么用 try-catch 语句捕获它，要么用 throws 子句声明抛出它，否则编译不会通过。</p>
</li>
<li><p><strong>准则：**</strong>如果程序出现RuntimeException异常，那么一定是程序员的问题**</p>
</li>
<li><p><strong>异常和错误的区别：</strong>异常能被程序本身处理，错误则无法处理</p>
</li>
</ul>
<h2 id="三、java异常处理机制"><a href="#三、java异常处理机制" class="headerlink" title="三、java异常处理机制"></a>三、java异常处理机制</h2><p>1、异常处理</p>
<p>在java应用程序中，异常处理机制为：抛出异常与捕获异常。</p>
<p><strong>抛出异常：</strong>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处理异常的代码并执行。</p>
<p><strong>捕获异常：</strong>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常地方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着java程序的终止。</p>
<hr>
<p>对于运行时异常、错误或受检查的异常，java技术所要求的异常处理方式有所不同：</p>
<ul>
<li><p>由于<strong>运行时异常是不受检查的</strong>，Java规定：运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常；</p>
</li>
<li><p>对于<strong>方法运行中可能出现的Error</strong>，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error是不可恢复的，也属于合理的应用程序不该捕捉的异常；</p>
</li>
<li><p>对于<strong>所有受检查的异常</strong>，Java规定：异常必须被捕捉，或者进行异常说明。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常；</p>
<p>　　任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的 throw 语句抛出异常。</p>
<p>　　<strong>总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error。</strong></p>
</li>
</ul>
<p>2、异常说明</p>
<p>对于受检查异常而言，java提供了相应的语法，使你能告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> TooBig, TooSmall, DivZero </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>表示方法f可能会抛出TooBig，TooSmall，DivZero三种异常，而</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;... ...&#125;</span><br></pre></td></tr></table></figure>

<p>表示方法g不会抛出任何异常</p>
<p>代码必须与异常说明保持一致。若方法中的代码产生了受检查异常却没有进行处理，编译器就会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中表明此方法产生异常。不过，我们可以声明方法将抛出异常，但实际上并不抛出。</p>
<p>3、捕获异常</p>
<p><strong>监控区域：</strong>它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码，由try…catch…子句实现。</p>
<p>（1）try子句</p>
<p>​    如果方法内部抛出了异常，这个方法将在抛出异常的过程中结束。若不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。其中，在这个块里，尝试各种方法调用的部分称为try块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>(2) catch子句-异常处理程序</p>
<p>抛出的异常必须得到处理，而且针对每个要捕获的异常，都必须准备相应的异常处理程序。异常处理程序必须紧跟在try块之后，以catch关键字表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 id1)|&#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type1 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 id2) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type2 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type3 id3) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type3 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>异常处理程序可能用不到标识符（id1,id2,…），因为异常的类型本身就已经给出了足够的信息来处理异常，但标识符不可省。<strong>当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入对应的catch自居执行，此时认为异常得到处理。一旦catch子句结束，则处理程序的查找结束</strong>（与 switch…case…不同）。</p>
<p>特别需要注意的是：</p>
<ul>
<li>异常匹配原则：抛出异常时，异常处理系统会按照代码的书写顺序找出最近匹配的处理程序。一旦找到，它就认为异常将得到处理，然后停止查找；</li>
<li>不可屏蔽派生类异常：捕获基类异常的catch子句必须放在捕获其派生类异常的catch子句之后，否则编译不会通过；</li>
<li>catch子句必须与try子句连用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">java的抽象特性：抽象类与接口深度解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 15:47:32 / 修改时间：16:24:10" itemprop="dateCreated datePublished" datetime="2021-02-04T15:47:32+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>要点</strong></p>
<ul>
<li>抽象类</li>
<li>接口</li>
<li>抽象类与接口的区别</li>
</ul>
<h2 id="一、抽象"><a href="#一、抽象" class="headerlink" title="一、抽象"></a>一、抽象</h2><p>对于面向对象编程来说，抽象是它的四大特征之一。在java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。接口和抽象类为我们提供了一种将接口与实现分离的更加结构化的方法。</p>
<h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h2><p>1）概念基础</p>
<p>所有的对象都是通过类来描述的，但是并不是所有的类都是可以描述对象（对象=状态+行为）的。如果一个类没有足够的信息来描述一个具体的对象，那么我们就可以将这样的类设为抽象类。抽象类只能被public和默认修饰符修饰。</p>
<p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰 <strong>(特别需要注意的是，抽象类也可以不包含抽象方法，即其中所有的方法都是具体方法)**。</strong>因为抽象类中含有未具体实现的方法，所以不能用抽象类创建对象。**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就称为abstract类了。</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要三点区别：</p>
<ul>
<li>抽象方法不能是private的，否则，其不能被子类继承，子类也无法实现该方法，从而这样做没有任何意义；</li>
<li>抽象类不能用来创建对象</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</li>
</ul>
<p>2）本质</p>
<ul>
<li>抽象类与具体类的唯一区别：含有抽象方法的类一定是抽象类；</li>
<li>抽象类的根本作用是为了继承，所以抽象类的抽象方法不能被private修饰；</li>
<li>抽象类比具体类仅多一点抽象因素：行为层面的抽象（可以包含抽象方法）；</li>
</ul>
<h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><p>1）概念基础</p>
<p>接口（interface），在软件工程中，接口泛指别人调用的方法或者函数。它是对行为的抽象。接口只能被public和默认修饰符修饰。在java中，定义一个接口的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口中可以含有 变量和方法。</strong>但是要注意，接口中的 <strong>变量</strong> 会被隐式地指定为 <strong>public static final变量（并且只能是public static final变量，\</strong>而且 public static final 可省，即默认就是public static final 的）*<strong>* ，而 <strong>方法</strong> 会被隐式地指定为 <strong>public abstract方法且只能是 public abstract 方法\</strong>（public abstract 可省，即默认就是 public abstract 的）**</strong>，<strong>并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</strong>从这里可以隐约看出接口和抽象类的区别，<strong>接口是一种极度抽象的类型，它比抽象类更加“抽象”。</strong></p>
<p>要让一个类遵循某组特地的接口需要使用 <strong>implements</strong> 关键字，具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<p>2）本质</p>
<ul>
<li>接口是一种行为契约，是对行为的抽象；</li>
</ul>
<h2 id="四、接口与抽象类的区别"><a href="#四、接口与抽象类的区别" class="headerlink" title="四、接口与抽象类的区别"></a>四、接口与抽象类的区别</h2><p>1、语法层面上的区别</p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract（可省）方法；</li>
<li>抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法、而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161210225212635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>2、设计层面上的区别</p>
<p>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。</strong>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它可以跨越不同的类，是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说 <strong>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</strong></p>
<p>门和警报的例子：门都有open()和close()两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>
<p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>
<p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>
<p>　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、小结</p>
<ul>
<li>抽象类是对一种事物的抽象，接口是对行为的抽象；</li>
<li>抽象类是一种模板，接口是一种契约</li>
<li>抽象类的抽象程序介于普通类和接口之间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">java原生类型与包装器类型深度剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 10:04:19 / 修改时间：15:46:20" itemprop="dateCreated datePublished" datetime="2021-02-04T10:04:19+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>要点：</strong></p>
<ul>
<li>原生类型与包装器类型</li>
<li>字面值概念和种类</li>
<li>基本类型、自动转型与强制转型</li>
<li>自动装箱与拆箱机制（Autoboxing and Unboxing）</li>
</ul>
<h2 id="一、原生类型与包装器类型"><a href="#一、原生类型与包装器类型" class="headerlink" title="一、原生类型与包装器类型"></a>一、原生类型与包装器类型</h2><p>八种基本数据类型</p>
<p>注意：</p>
<ul>
<li>未带有字符串标识的整数默认为int类型，未带有字符串后缀标识的浮点数默认为double类型；</li>
<li>只有byte，char，short，int四种基本类型纪其包装类可以用于switch语句（只有enum类型和int类型可以应用到switch），其他类型编译会报错；</li>
<li>char(两个字节)可以用单引号标识单个字符（可以是汉字），如：‘良’，‘A’；</li>
<li>整数可以由二进制（以0B/0b开头）、八进制（以0开头的整数）、十进制、十六进制表示；</li>
</ul>
<h2 id="二、字面值"><a href="#二、字面值" class="headerlink" title="二、字面值"></a>二、字面值</h2><p>字面值大体上可以分为整型字面值、浮点型字面值、字符串字面值、特殊字面值四种。</p>
<p>1、整型字面值</p>
<ul>
<li>整型字面值可以使用十进制、十六进制、八进制和二进制来表示。当然，基数不能超出进制的范围。</li>
<li>一般情况下，字面值创建的是int类型，但是int字面值可以赋值给byte、short、char、long和int。当然，前提是字面值在目标范围以内(java会自动完成转换)；如果试图将超出范围的字面值赋给某一类型，编译通不过，需要强制类型转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b0 = <span class="number">128</span>;       <span class="comment">// Type mismatch: cannot convert from int to byte</span></span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">12</span>;       <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">byte</span> b2 = (<span class="keyword">byte</span>)<span class="number">300</span>；<span class="comment">// OK 需要强制转换，但表示的数字是截取后的数字（300二进制为100101100，截取后为00101100，即44）</span></span><br><span class="line"><span class="keyword">char</span> c0 = <span class="number">5</span>;       <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="keyword">char</span>(-<span class="number">3</span>);       <span class="comment">// 编译通过,但打印值为 ？（char 为无符号的）</span></span><br><span class="line">System.out.println(c1);   <span class="comment">// ？</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建long类型，需要在字面值最后面加上L或者l。整型字面值包括int字面值和long字面值两种。</li>
<li>java中，字符字面值用单引号括起来。</li>
</ul>
<p>2、浮点字面值</p>
<p>浮点字面值简单的理解可以理解为小数，分为float字面值和double字面值。默认为double类型，如果在小数后面加上F或者f，则表示是个float字面值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">10</span>；     <span class="comment">// OK，自动类型转换</span></span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">11.4</span>;    <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">1.23E3</span>;    <span class="comment">// OK  </span></span><br><span class="line"><span class="keyword">double</span> d4 = <span class="number">10D</span>;    <span class="comment">// OK  </span></span><br><span class="line"><span class="keyword">double</span> d5 = <span class="number">0.4D</span>;     <span class="comment">// OK </span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">10</span>;      <span class="comment">// OK，自动类型转换</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">11.1F</span>;      <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">11.1</span>;      <span class="comment">// Type mismatch: cannot convert from double to float</span></span><br></pre></td></tr></table></figure>

<p>3、字符及字符串字面值</p>
<p>java中字符字面值用单引号括起来，如‘@’，‘1’。字符串字面值使用双引号，字符串字面值中同样可以包含字符字面值中的转义字符序列。</p>
<p>4、特殊字面值</p>
<p>null是一种特殊的类型（type），可以将它赋给任何引用类型变量，表示这个变量不引用任何东西。如果一个引用类型变量为null，表示这个变量不可用。</p>
<p>还有一种特殊的class literal，用type name加上.class表示，例如String.class。class literal用于表示类型本身。</p>
<h2 id="三、自动转型与强制转型"><a href="#三、自动转型与强制转型" class="headerlink" title="三、自动转型与强制转型"></a>三、自动转型与强制转型</h2><p>1、自动转型</p>
<p>自动转型总原则：byte,short，char（同级）-&gt;int-&gt;long-&gt;float-&gt;double（由低精度到高精度）</p>
<ul>
<li><p>从位数低的类型向位数高的类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">c = b;  <span class="comment">// Error，同级</span></span><br><span class="line">c = s;  <span class="comment">// Error，同级</span></span><br><span class="line">s = c;  <span class="comment">// Error，同级</span></span><br><span class="line">i = c;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从整型向浮点型的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d=<span class="number">1</span>;</span><br><span class="line">f=i;	<span class="comment">//OK</span></span><br><span class="line">f=t;	<span class="comment">//OK</span></span><br><span class="line">d=f;	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2、运算符对基本类型的影响</p>
<p>1）当使用+,-,*,/,%,==,&gt;,&lt;等等运算符对基本类型进行运算时，遵循如下规则：</p>
<p>​    两个操作数中，先考虑吧是否有一个是double类型的。如果有，另一个操作数和结果将会转换成double类型。再依次考虑float，long。除此之外，两个操作数都将会被转换成int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">10</span> ;  <span class="comment">//OK，会检查发现10没有超过byte类型的最大值</span></span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">12</span>;   <span class="comment">//OK，会检查发现12没有超过byte类型的最大值</span></span><br><span class="line"><span class="keyword">byte</span> b = b1 + b2; <span class="comment">//Error，byte类型在计算时会自动提升为int类型，此时就会报错，因为b1+b2实际上是int类型，但是左侧的变量为byte类型。</span></span><br><span class="line"><span class="keyword">short</span> s1=<span class="number">1</span>; <span class="comment">//OK，会检查发现1没有超过short类型的最大值</span></span><br><span class="line">s1=s1+<span class="number">1</span>;    <span class="comment">//Error，因为s1+1 结果int，但左侧变量为 short，报错</span></span><br><span class="line">s1++;      <span class="comment">//OK，不会报错，与s1=s1+1不同！！！，会检查发现2没有超过short类型的最大值</span></span><br><span class="line">s1=<span class="number">1</span>+<span class="number">1</span>;   <span class="comment">//OK，1+1 是个编译时可以确定的常量，&#x27;+&#x27;运算在编译时就被执行了，而不是在程序执行的时候，这个语句的效果等同于s1=2</span></span><br></pre></td></tr></table></figure>

<p>2）当使用+=，-=,*=,/=,%=,i++,++i运算符对基本类型进行运算时，遵循如下规则：</p>
<p><strong>运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，且运算结果与运算符左边数值类型相同。</strong>自增(减)运算也类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1=<span class="number">1</span>; <span class="comment">// OK，会检查发现1没有超过short类型的最大值</span></span><br><span class="line"><span class="keyword">short</span> s2;</span><br><span class="line"></span><br><span class="line">s1+=<span class="number">1</span>;    <span class="comment">// OK，正确，1首先被强制转换为short型，然后再参与运算，并且结果也是short类型</span></span><br><span class="line"></span><br><span class="line">s2 = ++s1;     <span class="comment">// OK，正确，s2的值为2</span></span><br></pre></td></tr></table></figure>

<p>2、强制转型</p>
<p>​    强制转型的格式是在需要转型的数据前加上“（）”，然后在括号内加入需要转化的数据类型。主要发生以下两种情形：</p>
<ul>
<li>由高精度向低精度转换</li>
<li>一种类型到另一种类型转换，则必须使用强制类型转化（同级之间：byte，short,char）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> t = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>;</span><br><span class="line">i = (<span class="keyword">int</span>) f;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">t = (<span class="keyword">long</span>) f;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">b = (<span class="keyword">byte</span>) i;  <span class="comment">// OK，由高精度向低精度转换</span></span><br><span class="line">i = b; <span class="comment">// OK，由低精度向高精度转换，自动转型</span></span><br><span class="line">System.out.println(c==s);  <span class="comment">// OK，true，c 和 s 自动转型为int,然后比较</span></span><br><span class="line">b = (<span class="keyword">byte</span>) s;  <span class="comment">// OK，一种类型到另一种类型转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) b;  <span class="comment">// OK，一种类型到另一种类型转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) s;   <span class="comment">// OK，一种类型到另一种类型转换</span></span><br></pre></td></tr></table></figure>

<p>特别需要注意的是，强制转换常常会导致二进制位的截取，甚至会导致意想不到的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">System.out.println(b);           <span class="comment">// -128(即-0)</span></span><br></pre></td></tr></table></figure>

<h2 id="四、自动装箱与拆箱（Autoboxing-and-Unboxing）"><a href="#四、自动装箱与拆箱（Autoboxing-and-Unboxing）" class="headerlink" title="四、自动装箱与拆箱（Autoboxing and Unboxing）"></a>四、自动装箱与拆箱（Autoboxing and Unboxing）</h2><p>1、什么是装箱？什么是拆箱？</p>
<p>java为每种基本数据类型都提供了对应的包装器类型。在java SE5之前，如果要创建一个数值为10的Integer对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>而从java SE5之后就提供了自动装箱的特性，如果要创建一个数值为10的Integer对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个过程会自动根据数值创建对应的Integer对象，这就是装箱。</p>
<p>那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i=<span class="number">10</span>;	<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n=i;	<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>2、装箱和拆箱是如何实现的</p>
<p>上一小节了解装箱的基本概念之后，这一小节来了解一下装箱和拆箱是如何实现的。我们就以Integer类为例，下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</p>
<p>对于其他的包装器类，比如Double、Character，也同样适用。</p>
<p>因此，可以用一句话总结装箱和拆箱的实现过程；</p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的（xxx代表对应的基本数据类型）。</p>
<p>3、valueOf、xxxValue方法在JDK中的实现</p>
<p>（1）在Byte、Charater、Short、Integer、Long中的实现（以Integer为例）</p>
<ul>
<li>public static Integer valueOf(int i): 类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;                                         <span class="comment">// 静态代码块  </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Use Long.decode here to avoid invoking methods that</span></span><br><span class="line">                <span class="comment">// require Integer&#x27;s autoboxing cache to be initialized</span></span><br><span class="line">                <span class="keyword">int</span> i = Long.decode(integerCacheHighPropValue).intValue();</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - -low);</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)                      <span class="comment">// 初始化  </span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会被自动调用：如果整型字面值在[-128,127]之间，便返回IntegerCache.cache中已经存在的对象的引用；否则，创建一个新的Integer对象并返回。</p>
<ul>
<li><p>public int intValue():实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Integer对象会自动调用其intValue方法，返回该对象对应的int值。</p>
</li>
</ul>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">        System.out.println(i1==i2);          <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3==i4);          <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在Float、Double中的实现（以Double为例）</p>
<ul>
<li><p>public static Double valueOf(double d):  类方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会自动调用，从而创建相应的Double对象并返回。</p>
</li>
<li><p>public int intValue()：实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Double对象会自动调用其doubleValue方法，返回该对象对应的double值。</p>
</li>
</ul>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Double i1=<span class="number">100.0</span>;</span><br><span class="line">        Double i2=<span class="number">100.0</span>;</span><br><span class="line">        Double i3=<span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现呢？原因很简单，在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<p>（3）在Boolean中的实现</p>
<ul>
<li>public static Boolean valueOf(boolean b): 类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在装箱时，valueOf方法会被自动调用，从而创建相应的Boolean对象并返回。</p>
<ul>
<li><p>public boolean booleanValue():实例方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码可以看出，在拆箱时，Boolean对象会自动调用其booleanValue方法，返回该对象对应的boolean值。</p>
<p>下面代码可以很好说明这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(i1==i2);          <span class="comment">// true</span></span><br><span class="line">        System.out.println(i3==i4);          <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，有限可列举，共享[-128,127];</li>
<li>Double、Float的valueOf方法的实现是类似的，无限不可列举，不共享；</li>
<li>Boolean的valueOf方法的实现不同于以上的整型和浮点型，只有两个值，有限可列举，共享；</li>
</ul>
</li>
</ul>
<p>4、Integer i = new Integer(xxx)和Integer i=xxx；的区别</p>
<ul>
<li>第一种方式不会触发自动装箱的过程，而第二种方式会触发；</li>
<li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下（[-128,127]）要优于第一种情况（注意这并不是绝对的）。</li>
</ul>
<p>5、“==”运算符</p>
<p>当使用“==”运算符在基本类型和其包装类型对象之间比较时，涉及到自动装箱、拆箱机制，遵循如下规则：</p>
<p>1）、只要两个操作数中有一个是基本类型或表达式，就是比较它们的数值是否相等。</p>
<p>2）、否则，就是判断这两个对象的内存地址是否相等，即是否是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i01=<span class="number">59</span>;</span><br><span class="line">        <span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">        Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">        Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line">        System.out.println(i01==i02);  <span class="comment">// true，拆箱</span></span><br><span class="line">        System.out.println(i01==i03);  <span class="comment">// true，同一对象</span></span><br><span class="line">        System.out.println(i03==i04);  <span class="comment">// false，不同对象</span></span><br><span class="line">        System.out.println(i02==i04);  <span class="comment">// true，拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(c==d);  <span class="comment">// true</span></span><br><span class="line">        System.out.println(e==f);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(c==(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(g==(a+b));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a+b));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a+h));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个和第二个输出结果没有什么疑问；</li>
<li>第三个打印语句由于 a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等；</li>
<li>对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较；</li>
<li>对于g==(a+b)，会分别触发 Integer 和 Long 的自动拆箱过程，<strong>然后 int 自动转为 long</strong>，进行比较；</li>
<li>对于g.equals(a+b)，最终会归结于 Long对象与Integer对象的比较，由于二者不为同一类型，直接返回 false ;</li>
<li>对于g.equals(a+h)，最终会归结于 Long对象与Long对象的比较，由于 -128 &lt;= 3 &lt;= 127, 二者为同一对象，直接返回 true 。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/" class="post-title-link" itemprop="url">java String综述2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 10:29:46" itemprop="dateCreated datePublished" datetime="2021-02-02T10:29:46+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-03 19:09:03" itemprop="dateModified" datetime="2021-02-03T19:09:03+08:00">2021-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="六、字符串常量池"><a href="#六、字符串常量池" class="headerlink" title="六、字符串常量池"></a>六、字符串常量池</h2><p>字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(str1==str2);	<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个初始为空的字符串池，它由类String私有地维护。当以字面值形式创建一个字符串时，总是先检查字符串池是否含存在该对象，若存在，则直接返回。此外，通过new操作符创建的字符串对象不指向字符串池中的任何对象。</p>
<p>2、手动入池</p>
<p>​    一个初始为空的字符串池，它由类String私有地维护。当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。特别地，手动入池遵循以下规则：</p>
<p>​    对于任意两个字符串s和t，当且仅当s.equals(t)为true时，s.intern() == t.intern()才为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String str3 = s2.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println( str1 == str2 );   <span class="comment">//false</span></span><br><span class="line">        System.out.println( str1 == str3 );   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于String str1=“abc”，str1引用的是常量池（方法区）的对象；而String str2=new String(“abc”)，str2引用的是堆中的对象，所以内存地址不一样。但是由于内容一样，所以str1和str3指向同一对象。</p>
<p>3、实例</p>
<p>1）情景一：字符串常量池</p>
<p>Java虚拟机（JVM）中存在着一个字符串常量池，其中保存着很多String对象，并且这些String对象可以被共享使用，因此提高了效率。之所以字符串具有字符串常量池，是因为String对象是不可变的，因此可以被共享。字符串常量池由String类维护，我们可以通过intern()方法使字符串池手动入池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 在字符串池创建了一个对象  </span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s2 : &quot;</span>+(s1==s2));    </span><br><span class="line"><span class="comment">//↑ true 指向同一个对象，  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2)));    </span><br><span class="line"><span class="comment">//↑ true  值相等  </span></span><br></pre></td></tr></table></figure>

<p>2）情景二：关于new String(“…”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 创建了两个对象，一个存放在字符串池中，一个存在与堆区中；  </span></span><br><span class="line"><span class="comment">//↑ 还有一个对象引用s3存放在栈中  </span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3 == s4 : &quot;</span>+(s3==s4));  </span><br><span class="line"><span class="comment">//↑false   s3和s4栈区的地址不同，指向堆区的不同地址；  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4)));  </span><br><span class="line"><span class="comment">//↑true  s3和s4的值相同  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s3 : &quot;</span>+(s1==s3));  </span><br><span class="line"><span class="comment">//↑false 存放的地区都不同，一个方法区，一个堆区  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3)));  </span><br><span class="line"><span class="comment">//↑true  值相同 </span></span><br></pre></td></tr></table></figure>

<p>通过new String(“…”)来创建字符串时，在该构造函数的参数值为字符串字面值的前提下，若该字面值不在字符串常量池中，那么会创建两个对象：一个在字符串常量池中，一个在堆中；否则，只会在堆中创建一个对象。对于不在同一区域的两个对象，二者的内存地址必定不同。</p>
<p>3）情景三：字符串连接符“+”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;ab&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str3 = <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象                                         </span></span><br><span class="line">String str4 = str2+str3;                                        </span><br><span class="line">String str5 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;str4 = str5 : &quot;</span> + (str4==str5)); <span class="comment">// false  </span></span><br></pre></td></tr></table></figure>

<p>局部变量str2，str3指向字符串常量池中的两个对象。在运行时，第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</p>
<p>　(1). 调用 String 类的静态方法 <strong>String.valueOf()</strong> 将 str2 转换为字符串表示；</p>
<p>　(2). JVM 在堆中创建一个 StringBuilder对象，同时用str2指向转换后的字符串对象进行初始化；　</p>
<p>　(3). 调用StringBuilder对象的append方法完成与str3所指向的字符串对象的合并；</p>
<p>　(4). 调用 StringBuilder 的 toString() 方法在堆中创建一个 String对象；</p>
<p>　(5). 将刚刚生成的String对象的堆地址存赋给局部变量引用str4。</p>
<p>而引用str5指向的是字符串常量池中字面值”abcd”所对应的字符串对象。由上面的内容我们可以知道，引用str4和str5指向的对象的地址必定不一样。这时，内存中实际上会存在五个字符串对象： 三个在字符串常量池中的String对象、一个在堆中的String对象和一个在堆中的StringBuilder对象。</p>
<p>4）情景四：字符串的编译期优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str11 = <span class="string">&quot;abcd&quot;</span>;   </span><br><span class="line">System.out.println(<span class="string">&quot;str1 = str11 : &quot;</span>+ (str1 == str11));   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">final</span> String str8 = <span class="string">&quot;cd&quot;</span>;  </span><br><span class="line">String str9 = <span class="string">&quot;ab&quot;</span> + str8;  </span><br><span class="line">String str89 = <span class="string">&quot;abcd&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str9 = str89 : &quot;</span>+ (str9 == str89));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">//↑str8为常量变量，编译期会被优化  </span></span><br><span class="line">String str6 = <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">String str7 = <span class="string">&quot;a&quot;</span> + str6;  </span><br><span class="line">String str67 = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str7 = str67 : &quot;</span>+ (str7 == str67));     <span class="comment">// false</span></span><br><span class="line"><span class="comment">//↑str6为变量，在运行期才会被解析。</span></span><br></pre></td></tr></table></figure>

<p>java编译器对于类似“常量+字面值”的组合，其值在编译的时候就能够被确定了。在这里，str1和str9的的值在编译时就可以被确定，因此它们分别等价于：String str1=”abcd”；和String str9=”abcd”；</p>
<p>java编译器对于含有“String”引用的组合，则在运行期会产生新的对象（通过调用StringBuilder类的toString()方法），因此这个对象存储在堆中。</p>
<p>4、小结</p>
<ul>
<li>使用字面值形式创建的字符串与通过new创建的字符串一定是不同的，因为二者的存储位置不同：前者在方法区，后者在堆；</li>
<li>我们在使用诸如String str=”abc”；的格式创建字符串对象时，总是想当然地认为，我们创建了String类的对象str。但是事实上，对象可能并没有被创建。唯一可以肯定的是，指向String对象的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑；</li>
<li>字符串常量池的理念是享元模式；</li>
<li>java编译器对“常量+字面值”的组合是当成常量表达式直接求值来优化的；对于含有”String 引用”的组合，其在编译期不能被确定，会在运行期创建新对象。</li>
</ul>
<h2 id="七、三个字符串类"><a href="#七、三个字符串类" class="headerlink" title="七、三个字符串类"></a>七、三个字符串类</h2><p>1、String与StringBuilder</p>
<p>简要的说， <strong>String 类型 和 StringBuilder 类型的主要性能区别在于 String 是不可变的对象。</strong> 事实上，在对 String 类型进行“改变”时，实质上等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。由于频繁的生成对象会对系统性能产生影响，特别是当内存中没有引用指向的对象多了以后，JVM 的垃圾回收器就会开始工作，继而会影响到程序的执行效率。所以，<strong>对于经常改变内容的字符串，最好不要声明为 String 类型</strong>。但如果我们使用的是 StringBuilder 类，那么情形就不一样了。因为，我们的每次修改都是针对 StringBuilder 对象本身的，而不会像对String操作那样去生成新的对象并重新给变量引用赋值。所以，<strong>在一般情况下，推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下</strong>。</p>
<p>在某些特别情况下，String对象的字符串拼接可以直接被JVM在编译期确定下来，这时StringBuilder在速度上就不占任何优势了。</p>
<p>因此，在绝大部分情况下，在效率方面：StringBuilder&gt;String</p>
<p>2、StringBuffer与StringBuilder</p>
<p>首先需要明确的是，StringBuffer 始于 JDK 1.0，而 StringBuilder 始于 JDK 5.0；此外，从 JDK 1.5 开始，对含有字符串变量 (非字符串字面值) 的连接操作(+)，JVM 内部是采用 StringBuilder 来实现的，而在这之前，这个操作是采用 StringBuffer 实现的。</p>
<p>　　<strong>JDK的实现中 StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder。</strong>AbstractStringBuilder的实现原理为：AbstractStringBuilder中采用一个 <strong>char数组</strong> 来保存需要append的字符串，char数组有一个初始大小，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是 <strong>2</strong> 倍。</p>
<p>　　<strong>StringBuffer 和 StringBuilder 都是可变的字符序列，但是二者最大的一个不同点是：StringBuffer 是线程安全的，而 StringBuilder 则不是。StringBuilder 提供的API与StringBuffer的API是完全兼容的，即，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，但是后者一般要比前者快。**</strong>因此，可以这么说，StringBuilder 的提出就是为了在单线程环境下替换 StringBuffer 。**</p>
<p>　　在单线程环境下，优先使用 StringBuilder。</p>
<p>3、实例</p>
<p>1）编译时优化与字符串连接符的本质</p>
<p>先来看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2 + s3;</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量s的创建等价于String s=”abc”；而变量s4的创建相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder(s1);</span><br><span class="line">temp.append(s2).append(s3);</span><br><span class="line">String s4 = temp.toString();</span><br></pre></td></tr></table></figure>

<p>但事实上，是不是这样子呢？我们将其反编译一下，来看看Java编译器究竟做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将上述 Test2 的 class 文件反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;            <span class="comment">// 编译期优化</span></span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//底层使用 StringBuilder 进行字符串的拼接</span></span><br><span class="line">        String s4 = (<span class="keyword">new</span> StringBuilder(String.valueOf(s1))).append(s2).append(s3).toString();   </span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的反编译结果，很好的印证了我们在第六节中提出的字符串连接符的本质。</p>
<p>2）另一个例子：字符串连接符的本质</p>
<p>由上面的分析结果，我们不难推断出 String 采用连接运算符（+）效率低下原因分析，形如这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            s+=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被编译器编译为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            s = (<span class="keyword">new</span> StringBuilder(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，每做一次 字符串连接操作 “+” 就产生一个 StringBuilder 对象，然后 append 后就扔掉。下次循环再到达时，再重新 new 一个 StringBuilder 对象，然后 append 字符串，如此循环直至结束。事实上，如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 <strong>N - 1</strong> 次创建和销毁对象的时间。所以，<strong>对于在循环中要进行字符串连接的应用，一般都是用StringBulider对象来进行append操作。</strong></p>
<h2 id="八、字符串与正则表达式：匹配、替换与验证"><a href="#八、字符串与正则表达式：匹配、替换与验证" class="headerlink" title="八、字符串与正则表达式：匹配、替换与验证"></a>八、字符串与正则表达式：匹配、替换与验证</h2><p>正则表达式：</p>
<p><strong>用一个字符串来描述一个特征，然后去验证另一个字符串是否符合这个特征。</strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。 Java 内置了对正则表达式的支持，其相关的类库在 java.util.regex 包下</p>
<p>1、java转义与正则表达式转义</p>
<p>要想匹配某些特殊字符，比如 “\”，需要进行两次转义，即Java转义与正则表达式转义。对于下面的例子，需要注意的是，split()函数的参数必须是“正则表达式”字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a\\b&quot;</span>;</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>2、使用Pattern与Matcher构造功能强大的正则表达式对象</p>
<p>Pattern与Matcher的组合就是Java对正则表达式的主要内置支持，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;.\\\\.&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;a\\b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.matches());</span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    a\b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="九、String与（深）克隆"><a href="#九、String与（深）克隆" class="headerlink" title="九、String与（深）克隆"></a>九、String与（深）克隆</h2><p>1、克隆的定义与意义</p>
<p>克隆就是制造一个对象的副本。一般地，根据所要克隆的对象的成员变量中是否含有引用类型，可以将克隆分为两种：浅克隆（Shallow Clone）和深克隆（Deep Clone），默认情况下使用Object中的clone方法进行克隆就是浅克隆，即完成对象域对域的拷贝。</p>
<p>（1）Object中的clone()方法</p>
<p><img src="https://img-blog.csdn.net/20170313093548412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在使用clone()方法时，若该类未实现 Cloneable 接口，则抛出 java.lang.CloneNotSupportedException 异常。下面我们以Employee这个例子进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆完成...&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        ~Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: P1_1.Employee</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>(2).Cloneable接口</p>
<p>Cloneable接口是一个标识性接口，即该接口不包含任何方法，但是如果一个类想合法的进行克隆，那么就必须实现这个接口。JDK描述如下：</p>
<ul>
<li>A class implements the Cloneable interface to indicate to the java.lang.Object.clone() method that it is <strong>legal</strong> for that method to make a field-for-field copy of instances of that class.</li>
<li><strong>Invoking Object’s clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown.</strong></li>
<li>By convention, classes that implement this interface should <strong>override</strong> Object.clone (which is protected) with <strong>a public method</strong>.</li>
<li><strong>Note that this interface does *not* contain the clone() method.</strong> Therefore, it is not possible to clone an object merely by virtue of the fact that it implements this interface. Even if the clone method is invoked reflectively, there is no guarantee that it will succeed.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Clone与Copy</p>
<p>假设现在有一个Employee对象，Employee tobby = new Employee(“CMTobby”,5000)，<strong>通常, 我们会有这样的赋值Employee tom=tobby，这个时候只是简单了copy了一下reference</strong>，tom 和 tobby 都指向内存中同一个object，这样tom或者tobby对对象的修改都会影响到对方。打个比方，如果我们通过tom.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。如果我们希望得到tobby所指向的对象的一个精确拷贝，同时两者互不影响，那么我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法</p>
<p>3、Shallow Clone与Deep Clone</p>
<p>Clone是如何完成的呢？Object中的clone()方法在对某个对象实施克隆时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了，以Employee为例，它里面有一个域hireDay不是基本类型的变量，而是一个reference变量，经过Clone之后克隆类只会产生一个新的Date类型的引用，它和原始引用都指向同一个 Date 对象，这样克隆类就和原始类共享了一部分信息，显然这种情况不是我们愿意看到的</p>
<p>这个时候，我们就需要进行 Deep Clone 了，以便对那些引用类型的域进行特殊的处理，例如本例中的hireDay。我们可以重新定义 clone方法，对hireDay做特殊处理，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       Employee cloned = (Employee) <span class="keyword">super</span>.clone();  </span><br><span class="line">       <span class="comment">// Date 支持克隆且重写了clone()方法，Date 的定义是：</span></span><br><span class="line">       <span class="comment">// public class Date implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;</span></span><br><span class="line">       cloned.hireDay = (Date) hireDay.clone() ;   </span><br><span class="line">       <span class="keyword">return</span> cloned;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>因此，Object 在对某个对象实施 Clone 时，对其是一无所知的，它仅仅是简单执行域对域的Copy。 其中，对八种基本类型的克隆是没有问题的，但当对一个引用类型进行克隆时，只是克隆了它的引用。因此，克隆对象和原始对象共享了同一个对象成员变量，故而提出了深克隆 ： 在对整个对象浅克隆后，还需对其引用变量进行克隆，并将其更新到浅克隆对象中去。</strong></p>
<p>4、一个克隆的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Employee </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((hireDay == <span class="keyword">null</span>) ? <span class="number">0</span> : hireDay.hashCode());</span><br><span class="line">        result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        temp = Double.doubleToLongBits(salary);</span><br><span class="line">        result = prime * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee other = (Employee) obj;</span><br><span class="line">        <span class="keyword">if</span> (hireDay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.hireDay != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hireDay.equals(other.hireDay))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.doubleToLongBits(salary) != Double</span><br><span class="line">                .doubleToLongBits(other.salary))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; : &quot;</span> + String.valueOf(salary) + <span class="string">&quot; : &quot;</span> + hireDay.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类 Manger </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manger</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String edu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manger</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay, String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, hireDay);</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEdu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdu</span><span class="params">(String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getSalary() + <span class="string">&quot; : &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.getHireDay() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getEdu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">super</span>.hashCode();</span><br><span class="line">        result = prime * result + ((edu == <span class="keyword">null</span>) ? <span class="number">0</span> : edu.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(obj))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manger other = (Manger) obj;</span><br><span class="line">        <span class="keyword">if</span> (edu == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.edu != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!edu.equals(other.edu))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Manger manger = <span class="keyword">new</span> Manger(<span class="string">&quot;Rico&quot;</span>, <span class="number">20000.0</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;NEU&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        Manger clonedManger = (Manger) manger.clone();</span><br><span class="line">        <span class="comment">// 输出克隆的manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象的克隆对象 = &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象和其克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改、输出manger</span></span><br><span class="line">        manger.setEdu(<span class="string">&quot;TJU&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原克隆对象= &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象和原克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象的克隆对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象和其克隆对象是否相等：  true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        修改后的Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : TJU</span></span><br><span class="line"><span class="comment">        原克隆对象= Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        修改后的Manger对象和原克隆对象是否相等：  false</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>5、Clone()方法的保护机制</p>
<p>　<strong>在Object中clone()是被申明为 \</strong>protected** 的，这样做是有一定的道理的。**以 Employee 类为例，如果我们在Employee中重写了protected Object clone()方法， ，就大大限制了可以“克隆”Employee对象的范围，即可以保证只有在和Employee类在同一包中类及Employee类的子类里面才能“克隆”Employee对象。进一步地，如果我们没有在Employee类重写clone()方法，则只有Employee类及其子类才能够“克隆”Employee对象。</p>
<p>6、注意事项</p>
<p>Clone()方法的使用比较简单，注意以下几点：</p>
<ul>
<li><p>什么时候使用shallow Clone，什么时候使用deep Clone？</p>
<p>这个主要看具体对象的域是什么性质的，基本类型还是引用类型</p>
</li>
<li><p>调用Clone()方法的对象所属的类(Class)必须实现Clonable接口，否则在调用Clone方法的时候会抛出CloneNotSupportedException；</p>
</li>
<li><p>所有数组对象都实现了Clonable接口，默认支持克隆；</p>
</li>
<li><p>如果我们实现了Clonable接口，但没有重写Object类的clone方法，那么执行域对域的拷贝；</p>
</li>
<li><p>明白String在克隆中的特殊性</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
