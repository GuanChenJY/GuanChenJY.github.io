<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/java-String%E7%BB%BC%E8%BF%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/java-String%E7%BB%BC%E8%BF%B01/" class="post-title-link" itemprop="url">java String综述1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-01 15:45:06 / 修改时间：20:37:34" itemprop="dateCreated datePublished" datetime="2021-02-01T15:45:06+08:00">2021-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、java内存模型与常量池"><a href="#一、java内存模型与常量池" class="headerlink" title="一、java内存模型与常量池"></a>一、java内存模型与常量池</h2><p>1、java内存模型</p>
<ul>
<li><p>程序计数器</p>
<p>多线程时，当线程数超过CPU数量或CPU内核数量，线程之间就要根据时间片轮询抢夺CPU时间资源。因此，每个线程要有一个独立的程序计数器，记录下一条要运行的指令，其为线程私有的内存区域。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。</p>
</li>
<li><p>虚拟机栈</p>
<p>线程私有的，与线程在同一时间创建，是管理java方法执行的内存模型。栈中主要存放一些基本类型的变量数据（int,short,long,byte,float,double,boolean,char）和对象引用。每个方法执行时都会创建一个帧栈来存储方法的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。使用jclasslib工具可以查看class类文件的结构。</p>
</li>
<li><p>本地方法区</p>
<p>和虚拟机栈功能相似，但管理的不是java方法，是本地方法，本地方法是用C实现的。</p>
</li>
<li><p>java堆</p>
<p>线程共享的，存放所有对象实例和数组，是垃圾回收的主要区域。堆是一个运行时数据区，类的对象从中分配空间，这些对象通过new、newarray，anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆可以分为新生代和老年代（tenured）。新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。新生代又可进一步细分为eden、survivorSpace0、survivorSpace1(s1,tospace)。刚创建的对象都放入eden，s0和s1都至少经过一次GC并幸存。如果幸存对象经过一定实践仍存在，则进入老年代（tenured）。</p>
</li>
<li><p>方法区</p>
<p>线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码，也成为永久代。如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收。</p>
</li>
</ul>
<p>2、常量池</p>
<p>常量池属于类信息的一部分，而类信息反映到JVM内存模型中对应于方法区，也就是说，常量池位于方法区。常量池主要存放两大常量：字面量（Literal）和符号引用（Symbolic ）。其中，字面量主要包括字符串字面量，整型字面量和声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h2 id="二、常量与变量"><a href="#二、常量与变量" class="headerlink" title="二、常量与变量"></a>二、常量与变量</h2><ul>
<li><p>一般把内存地址不变，值可以改变的东西称为变量，换句话说，在内存地址不变的前提下内存的内容是可变的，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Human_1 h =<span class="keyword">new</span> Human_1(<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">        Human_1 h2=h;</span><br><span class="line">        System.out.printf(<span class="string">&quot;h: %s\n&quot;</span>,h.toString());</span><br><span class="line">        Syytem.out.printf(<span class="string">&quot;h2: %s\n\n&quot;</span>,h.toString());</span><br><span class="line">        h.id=<span class="number">3</span>;</span><br><span class="line">        h.age=<span class="number">32</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;h:%s\n&quot;</span>,h.toString());</span><br><span class="line">        System.out.printf(<span class="string">&quot;h2:%s\n\n&quot;</span>,h.toString());</span><br><span class="line">        </span><br><span class="line">        System.out.println(h==h2);	<span class="comment">//引用值不变，即对象内存底子不变，但内容改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般把若内存地址不变，则值也不可以改变的东西称为常量，典型的String就是不可变的，所以称之为常量（constant）。此外，我们可以通过final关键字来定义常量，但严格来说，只有基本类型被其修饰后才是常量（对基本类型来说是其值不可变，而对于对象变量来说其引用不可再变）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、String定义与基础"><a href="#三、String定义与基础" class="headerlink" title="三、String定义与基础"></a>三、String定义与基础</h2><ol>
<li><p>String的声明</p>
<p>由JDK中关于String的声明可以知道：</p>
<ol>
<li>不同字符串可能共享同一个底层char数组，例如字符串String s=”abc”与s.substring(1)就共享同一个char数组：char[] c={‘a’,’b’,’c’}。其中，前者的offset和count的值分别为0和3，后者的offset和count的值分别为1和2.</li>
<li>offset和count两个成员变量不是多余的，比如，在执行substring操作时。</li>
</ol>
</li>
<li><p>JDK中关于String的描述</p>
<p>The String class represents character Strings. All string literals(字符串字面值) in java programs, such as “abc”, are implemented as instances of this class. Strings are constant(常量); their values cannot be changed after they are created. String buffers[StringBuilder OR StringBuffer] support mutable strings. Because String objects are immutable, they can be shared(享元模式).</p>
</li>
<li><p>String类所内置的操作</p>
<p>The class String includes methods for examining individual characters of the sequence, for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode standard version specified by the java.lang.Character class.</p>
</li>
</ol>
<p>4、字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持</p>
<p>　　The Java language provides special support for the <strong>string concatenation operator (+)</strong>, and for conversion of other objects to strings. String concatenation is implemented through the <strong>StringBuilder(JDK1.5 以后) OR StringBuffer(JDK1.5 以前)</strong> class and <strong>its append method</strong>. String conversions(转化为字符串) are implemented through the method <strong>toString</strong>, defined by class Object and inherited by all classes in Java.</p>
<p>注意：</p>
<ul>
<li><p>String不属于八种基本数据类型，String的实例是一个对象。因为对象的默认值是null，所以String的默认值也是null；但它又是一种特殊的对象，有其他对象没有的一些特性(String的不可变性导致其像八种基本类型一样，比如，作为方法参数时，像基本类型的传值效果一样)。例如，以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String s=str;</span><br><span class="line">        str+=<span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        changeStr(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        1234</span></span><br><span class="line"><span class="comment">        1234 </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~ </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new String()和new String(“”都是声明一个新的空字符串)，是空串不是null；</p>
</li>
</ul>
<h2 id="四、String的不可变性"><a href="#四、String的不可变性" class="headerlink" title="四、String的不可变性"></a>四、String的不可变性</h2><p>1、什么是不可变对象？</p>
<p>众所周知，在java中，String类是不可变类（基本类型的包装类都是不可改变的）的典型代表，也是Immutable设计模式的典型应用。String变量一旦初始化后就不能更改，禁止改变对象的状态，从而增加共享对象的坚固性、减少对象访问的错误，同时还避免了在多线程共享时进行同步的需要。什么是不可变的对象呢？可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态指的是不能改变对象内的成员变量，包括：</p>
<ul>
<li>基本数据类型的值不能改变；</li>
<li>引用类型的变量不能指向其他的对象；</li>
<li>引用类型指向的对象的状态也不能改变；</li>
</ul>
<p>除此之外，还应具有以下特点：</p>
<ul>
<li>除了构造函数之外，不应该有其他任何函数（至少是任何public函数）修改任何成员变量；</li>
<li>任何使成员变量获得新值的函数都应该将新的值保存在新的对象中，而保持原来的对象不被修改。</li>
</ul>
<p>2、区分引用和对象</p>
<p>对于java初学者，对于String是不可变对象总是存有疑惑。看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);    <span class="comment">// s = ABCabc</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);    <span class="comment">// s = 123456</span></span><br></pre></td></tr></table></figure>

<p>首先创建了一个String对象s，然后让s的值为”ABCabc“，然后又让s的值为”1234560“。从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？其实这里存在一个误区：s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。也就是说，s只是一个引用，它指向了一个具体的对象，当s=”123456”；这句代码执行过之后，又创建了一个新的对象”123456“，而引用s重新指向了这个心的对象，原来的对象”ABCabc”还在内存中存在，并没有改变。</p>
<p>Java和C++的一个不同点是，<strong>在 Java 中，引用是访问、操纵对象的唯一方式： 我们不可能直接操作对象本身，所有的对象都由一个引用指向，必须通过这个引用才能访问对象本身</strong>，包括获取成员变量的值，改变对象的成员变量，调用对象的方法等。而在C++中存在引用，对象和指针三个东西，这三个东西都可以访问对象。其实，Java中的引用和C++中的指针在概念上是相似的，他们都是存放的对象在内存中的地址值，只是在Java中，引用丧失了部分灵活性，比如Java中的引用不能像C++中的指针那样进行加减运算。</p>
<p>3、为什么String对象是不可变的？</p>
<p>在JDK1.6中，String的成员变量有以下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">string</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0&lt;/string&gt;</span></span><br></pre></td></tr></table></figure>

<p>在JDK1.7中，String类做了一些改动，主要是改变了substring方法执行时的行为，这和本文的主题不相关。JDK1.7中String类的主要成员变量就剩下了两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">string</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0&lt;/string&gt;</span></span><br></pre></td></tr></table></figure>

<p>在java中，String类其实就是对字符数组的封装。JDK6中，value是String封装的数组，offset是String在这个value数组中的起始位置，count是String所占的字符的个数。在JDK7中，只有一个value变量，也就是value中的所有字符都是属于String这个对象的。这个改变不影响本文的讨论。除此之外还有一个hash成员变量，是该String对象的哈希值的缓存，这个成员的变量也和本文的讨论无关。在java中，数组也是对象。所以value也只是一个引用，它指向一个真正的数组对象。其实执行了String s =”ABCabc”；这句代码之后，真正的内存布局应该是这样的：</p>
<p>value、offset和count这三个变量都是private的，并且没有提供setValue，setOffset和setCount等公共方法来修改这些值，所以在String类的外部无法修改String。也就是说一旦初始化就不能修改，并且在String类的外部不能访问这三个成员。此外，value，offset和count这三个变量都是final的，也就是说在String类内部，一旦这三个值初始化了，也不能被改变。所以，可以认为String对象是不可变的了。</p>
<p>那么在String中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括substring， replace， replaceAll， toLowerCase等。例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;ABCabc&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);    <span class="comment">// a = ABCabc</span></span><br><span class="line"></span><br><span class="line">a = a.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);    <span class="comment">//a = aBCabc</span></span><br></pre></td></tr></table></figure>

<p>那么a的值看似改变了，其实也是同样的误区。再次说明， a只是一个引用， 不是真正的字符串对象，在调用a.replace(‘A’, ‘a’)时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用a。</p>
<p>我们可以自己查看其他方法，都是在方法内部重新创建新的String对象，并且返回这个新的对象，原来的对象是不会被改变的。这也是为什么像replace， substring，toLowerCase等方法都存在返回值的原因。也是为什么像下面这样调用不会改变对象的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String ss = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;ss = &quot;</span> + ss);     <span class="comment">// ss = 123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ss.replace(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ss = &quot;</span> + ss);     <span class="comment">//ss = 123456</span></span><br></pre></td></tr></table></figure>

<p>4、String对象真的不可变吗？</p>
<p>String的成员变量是private final的，也就是初始化之后不可改变。那么在这几个成员中，value比较特殊，因为他是一个引用变量，而不是真正的对象。value是final修饰的，也就是说final不能再指向其他数组对象，那么我能改变value指向的数组吗？比如，将数组中的某个位置上的字符变为下划线”_”。至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个value引用，更不能通过这个引用去修改数组，那么用什么方式可以访问私有成员呢？没错，用反射，可以反射出String对象中的value属性，进而改变通过获得的value引用改变数组的结构。下面是实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">&quot;Hello World&quot;</span>; </span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">//Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化，也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般不这么做。这个反射的实例还可以说明一个问题：如果一个对象，它组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final的，但是这个Wheel对象内部的状态可以改变，那么就不能很好的保证Car对象不可变。</p>
<h2 id="五、String对象创建方式"><a href="#五、String对象创建方式" class="headerlink" title="五、String对象创建方式"></a>五、String对象创建方式</h2><p>1、字面值形式：JVM会自动根据字符串常量池中字符串的实际情况来决定是否创建新对象（要么不创建，要么创建一个对象，关键要看常量池中有没有）</p>
<p>JDK中明确指出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] =&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br></pre></td></tr></table></figure>

<p>这该种方式先在栈中创建一个对String类的对象引用变量s，然后去查找 “abc”是否被保存在字符串常量池中。<strong>若”abc”已经被保存在字符串常量池中，则在字符串常量池中找到值为”abc”的对象，然后将s 指向这个对象</strong>; 否则，<strong>在 \</strong>堆** 中创建char数组 data，然后在 *<em>堆*</em> 中创建一个String对象object，它由 data 数组支持，紧接着这个String对象 object 被存放进字符串常量池，最后将 s 指向这个对象。**</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    String s0 = <span class="string">&quot;kvill&quot;</span>;        <span class="comment">// 1</span></span><br><span class="line">    String s1 = <span class="string">&quot;kvill&quot;</span>;        <span class="comment">// 2</span></span><br><span class="line">    String s2 = <span class="string">&quot;kv&quot;</span> + <span class="string">&quot;ill&quot;</span>;     <span class="comment">// 3</span></span><br><span class="line">    System.out.println(s0 == s1);       <span class="comment">// true  </span></span><br><span class="line">    System.out.println(s0 == s2);       <span class="comment">// true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行第 1 行代码时，“kvill” 入池并被 s0 指向；执行第 2 行代码时，s1 从常量池查询到” kvill” 对象并直接指向它；所以，s0 和 s1 指向同一对象。 由于 ”kv” 和 ”ill” 都是字符串字面值，所以 s2 在编译期由编译器直接解析为 “kvill”，所以 s2 也是常量池中”kvill”的一个引用。 所以，我们得出 s0==s1==s2;</p>
<p>2.通过new创建字符串对象：一概在堆中创建新对象，无论字符串字面值是否相等（要么创建一个，要么创建两个对象，关键要看常量池中有没有）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String original=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s=<span class="keyword">new</span> String(original);</span><br></pre></td></tr></table></figure>

<p>所以，<strong>通过 new 操作产生一个字符串（“abc”）时，会先去常量池中查找是否有“abc”对象，如果没有，则创建一个此字符串对象并放入常量池中。然后，在堆中再创建“abc”对象，并返回该对象的地址。</strong>所以，<strong>对于 String str=new String(“abc”)**：</strong>如果常量池中原来没有”abc”，则会产生两个对象（一个在常量池中，一个在堆中）；否则，产生一个对象。**</p>
<p>用new String()创建的字符串对象位于堆中，而不是常量池中，它们有自己独立的地址空间，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    String s0 = <span class="string">&quot;kvill&quot;</span>;  </span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">&quot;kvill&quot;</span>);  </span><br><span class="line">    String s2 = <span class="string">&quot;kv&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;ill&quot;</span>);  </span><br><span class="line">    String s = <span class="string">&quot;ill&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;kv&quot;</span> + s;    </span><br><span class="line">    System.out.println(s0 == s1);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s0 == s2);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s1 == s2);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s0 == s3);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s1 == s3);       <span class="comment">// false  </span></span><br><span class="line">    System.out.println(s2 == s3);       <span class="comment">// false  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>例子中，s0 还是常量池中”kvill”的引用，s1 指向运行时创建的新对象”kvill”，二者指向不同的对象。对于s2，因为后半部分是 new String(“ill”)，所以无法在编译期确定，在运行期会 new 一个 StringBuilder 对象， 并由 StringBuilder 的 append 方法连接并调用其 toString 方法返回一个新的 “kvill” 对象。此外，s3 的情形与 s2 一样，均含有编译期无法确定的元素。因此，以上四个 “kvill” 对象互不相同。StringBuilder 的 toString 为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value,<span class="number">0</span>,count);	<span class="comment">//new的方式创建字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数String(String original)的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据源字符串的底层数组长度与该字符串本身长度是否相等决定是否共用支撑数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = original.count;</span><br><span class="line">    <span class="keyword">char</span>[] originalValue = original.value;</span><br><span class="line">    <span class="keyword">char</span>[] v;</span><br><span class="line">    <span class="keyword">if</span> (originalValue.length &gt; size) &#123;</span><br><span class="line">        <span class="comment">// The array representing the String is bigger than the new</span></span><br><span class="line">        <span class="comment">// String itself. Perhaps this constructor is being called</span></span><br><span class="line">        <span class="comment">// in order to trim the baggage, so make a copy of the array.</span></span><br><span class="line">        <span class="keyword">int</span> off = original.offset;</span><br><span class="line">        v = Arrays.copyOfRange(originalValue, off, off + size);  <span class="comment">// 创建新数组并赋给 v</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The array representing the String is the same</span></span><br><span class="line">        <span class="comment">// size as the String, so no point in making a copy.</span></span><br><span class="line">        v = originalValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.count = size;</span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以知道，<strong>所创建的对象在大多数情形下会与源字符串 original 共享 char数组 。</strong>但是，<strong>什么情况下不会共享呢？</strong><br>　　<br>　　Take a look at <strong>substring</strong> , and you’ll see how this can happen.</p>
<p>　　Take for instance String s1 = “Abcd”; String s2 = s1.substring(3). Here s2.size() is 1, but s2.value.length is 4. <strong>This is because s1.value is the same as s2.value. This is done of performance reasons (substring is running in O(1), since it doesn’t need to copy the content of the original String).</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Abcd&quot;</span>;       <span class="comment">// s1 的value为Abcd的数组，offset为 0，count为 4</span></span><br><span class="line">String s2 = a.substring(<span class="number">3</span>);      <span class="comment">// s2 的value也为Abcd的数组，offset为 3，count为 1</span></span><br><span class="line">String c = <span class="keyword">new</span> String(s2);      <span class="comment">// s2.value.length 为 4，而 original.count = size = 1, 即 s2.value.length &gt; size 成立</span></span><br></pre></td></tr></table></figure>

<p><strong>Using substring can lead to a memory leak.</strong> Say you have a really long String, and you only want to keep a small part of it. If you just use substring, you will actually keep the original string content in memory. <strong>Doing</strong> <strong>String snippet = new String(reallyLongString.substring(x,y))</strong> , <strong>prevents you from wasting memory backing a large char array no longer needed.</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/java%E4%B8%AD%E7%9A%84-equals%E4%B8%8EhashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/java%E4%B8%AD%E7%9A%84-equals%E4%B8%8EhashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/" class="post-title-link" itemprop="url">java中的==,equals与hashCode的区别与联系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-01 10:30:44 / 修改时间：14:35:11" itemprop="dateCreated datePublished" datetime="2021-02-01T10:30:44+08:00">2021-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>1、概念</p>
<ul>
<li>==：该操作符生成的是一个boolean结果，它计算的是操作数的值之间的关系</li>
<li>equals：Object的实例方法，比较两个对象的content是否相同</li>
<li>hashCode：Object的native方法，获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数。</li>
</ul>
<h2 id="二、关系操作符"><a href="#二、关系操作符" class="headerlink" title="二、关系操作符 =="></a>二、关系操作符 ==</h2><p>1、操作数的值</p>
<ul>
<li><p>基本数据类型</p>
<p>在java中有八种基本数据类型：</p>
<p>​    浮点型：float(4 byte)，double(8 byte)</p>
<p>​    整型：byte(1 byte)，short(2 byte)，int（4 byte）,long(8 byte)</p>
<p>​    字符型：char(2 byte)</p>
<p>​    布尔型：boolean（JVM规范没有明确规定其所占空间的大小，仅规定其只能够取字面值“true”和”false”</p>
<p>对于这八种基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符==来进行比较时，比较的就是“值”本身。要注意的是，浮点型和整型都是有符号类型的，而char是无符号类型的。</p>
</li>
<li><p>引用类型变量</p>
<p>在java中，引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址。比如下面这行代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1;</span><br></pre></td></tr></table></figure>

<p>这句话声明了一个引用类型的变量，此时它没有和任何对象关联。</p>
<p>而通过new来产生一个对象，并将这个对象和str1进行绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么str1就指向了这个对象，此时引用变量str1中存储的是它指向在内存中的存储地址，并不是“值”本身，也就是说并不是直接存储的字符串“hello”。这里面的引用和C/C++中的指针很类似。</p>
</li>
</ul>
<p>2、小结</p>
<p>因此，对于关系操作符==：</p>
<ul>
<li>若操作的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等。</li>
<li>若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。也就是说，若此时返回true，则该操作符作用的一定是同一个对象。</li>
</ul>
<h2 id="三、equals方法"><a href="#三、equals方法" class="headerlink" title="三、equals方法"></a>三、equals方法</h2><p>1、来源</p>
<p>​    equals方法是基类Object中的实例方法，因此对所有继承于Object的类都会有该方法。</p>
<p>在Object中的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2、equals方法的作用</p>
<p>初衷：判断两个对象的content是否相同</p>
<p>为了更直观地理解equals方法的作用，先看Object类中equals方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p>
<p>但是String类重写了equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>&#123;	<span class="comment">//方法签名与Object类中的一致</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == anObject)&#123;	<span class="comment">//先判断引用是否相同（是否为同一对象）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String)&#123;	<span class="comment">//再判断类型是否一致，</span></span><br><span class="line">        <span class="comment">//最后判断内容是否一致</span></span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        <span class="keyword">int</span> n=count;</span><br><span class="line">        <span class="keyword">if</span> (n==anotherString.count)&#123;</span><br><span class="line">            <span class="keyword">char</span> v1[]=value;</span><br><span class="line">            <span class="keyword">char</span> v2[]=anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i=offset;</span><br><span class="line">            <span class="keyword">int</span> j=anotherString.offset;</span><br><span class="line">            <span class="keyword">while</span> (n--!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i++]!=v2[j++])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于诸如“字符串”比较时用的什么方法，内部实现如何？“之类的回答即为：</p>
<p>使用equals方法，内部实现分为三个步骤：</p>
<ul>
<li>先比较引用是否相同（是否为同一对象）</li>
<li>再判断类型是否一致（是否为同一类型）</li>
<li>最后比较内容是否一致</li>
</ul>
<p>java中所有内置的类的equals方法的实现步骤均是如此，特别是诸如Integer、Double等包装器类。</p>
<p>3、equals重写原则</p>
<p>对象内容的比较才是设计equal()的真正目的，java语言对equals()的要求如下，这些要求是重写该方法时必须遵循的：</p>
<ul>
<li>对称性：如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”；</li>
<li>自反性：x.equals(x)必须返回是”true“；</li>
<li>类推性：如果x.equals(y)返回是”true“，而且y.equals(z)返回是”true“，那么z.equals(x)也应该返回是”true“</li>
<li>一致性：如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true“;</li>
<li>对称性：如果x.equals(y)返回是”true“，那么y.equals(x)也应该返回是”true”。</li>
<li>任何情况下，x.equals(null) ，永远返回都是”false“；x.equals(和x不同类型的对象)永远返回是”false”.</li>
</ul>
<p>4、小结</p>
<p>因此，对于equals方法：</p>
<ul>
<li>其本意是比较两个对象的content是否相同</li>
<li>必要的时候，我们需要重写该方法，避免违背本意，且要遵循上述原则</li>
</ul>
<h2 id="四、hashCode方法"><a href="#四、hashCode方法" class="headerlink" title="四、hashCode方法"></a>四、hashCode方法</h2><p>1、hashCode的来源</p>
<p>​    hashCode方法是基类Object中的实例native方法，因此对所有继承于Object的类都会有该方法。</p>
<p>​    在Object类中的声明（native方法暗示这些方法是有实现体的，但不提供实现体，因为其实现体是由非java语言在外面实现的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>2、哈希相关概念</p>
<p>首先了解一下哈希表</p>
<ul>
<li><p>概念：哈希就是把任意长度的输入（又叫做预映射，pre-image），通过散列算法，变换成固定长度的输出（int），该输出就是散列值。这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间。不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值，简单的说，就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
</li>
<li><p>应用-数据结构：数组的特点是存址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。哈希表有一种拉链法，可以理解为链表的数组。如图：</p>
<p><img src="https://img-blog.csdn.net/20160907231114726" alt="这里写图片描述"></p>
</li>
</ul>
<p>左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。其中，将根据元素特征计算元素数组下标的方法就是散列法。</p>
<ul>
<li>拉链法的适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。</li>
<li>要点：hash函数选择，针对字符串，整数，排列，具体相应的hash方法；碰撞处理，一种是open hashing，也称为拉链法，另一种就是closed hashing，也称开地址法，open addressing。</li>
</ul>
<p>3、hashCode简述</p>
<p>在java中，由Object类定义的hashCode方法会针对不同的对象返回不同的整数。</p>
<p><strong>hashCode 的常规协定是：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法 <strong>不要求</strong> 一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ul>
<p>HashCode只是在需要用到哈希算法的数据结构中才有用，比如HashSet，HashMap和Hashtable。</p>
<p>java中的集合（Collection）有三类，一类是List，一类是Queue，再有一类就是Set。前两个集合内的元素是有序的，元素可以重复；最后一个集合内的元素无序，但元素不可重复。</p>
<p>那么, 这里就有一个比较严重的问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是 <strong>Object.equals</strong> 方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。 也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了<strong>哈希表的原理</strong>。 这样，我们对每个要存入集合的元素使用哈希算法算出一个值，然后根据该值计算出元素应该在数组的位置。所以，当集合要添加新的元素时，可分为两个步骤：</p>
<ul>
<li>先调用这个元素的hashCode方法，然后根据所得到的值计算出元素应该在数组的位置。如果这个位置上没有元素，那么直接将它存储在这个位置上；</li>
<li>如果这个位置上已经有元素了，那么调用它的equals方法与新元素进行比较：相同的话就不存了，否则将其存在这个位置对应的链表中（Java中HashSet，HashMap和Hashtable的实现总将元素放到链表的表头）。</li>
</ul>
<p>4、equals与hashCode</p>
<p><strong>前提：</strong> 谈到hashCode就不得不说equals方法，二者均是Object类里的方法。由于Object类是所有类的基类，所以一切类里都可以重写这两个方法</p>
<ul>
<li><strong>原则 1 ：</strong> 如果 x.equals(y) 返回 “true”，那么 x 和 y 的 hashCode() 必须相等 ；</li>
<li><strong>原则 2 ：</strong> 如果 x.equals(y) 返回 “false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等 ；</li>
<li><strong>原则 3 ：</strong> 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ；</li>
<li><strong>原则 4 ：</strong> <strong>一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用 ；</strong></li>
<li><strong>原则 5 ：</strong> <strong>当一个对象类型作为集合对象的元素时，那么这个对象应该拥有自己的equals()和hashCode()设计，而且要遵守前面所说的几个原则。</strong></li>
</ul>
<p>5、实现例证</p>
<p>hashCode()在Object类中定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明这是一个本地方法，它的实现是根据本地机制相关的。</p>
<p>String类是这样重写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];     <span class="comment">//成员变量1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;      <span class="comment">//成员变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;       <span class="comment">//成员变量3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0    //非成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">int</span> len = count;         <span class="comment">//用到成员变量3</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> off = offset;         <span class="comment">//用到成员变量2</span></span><br><span class="line">        <span class="keyword">char</span> val[] = value;       <span class="comment">//用到成员变量1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span>*h + val[off++];       <span class="comment">//递推公式</span></span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><ul>
<li>hashCode是系统用来快速检索对象而使用</li>
<li>equals方法本意是用来判断引用的对象是否一致</li>
<li>重写equals方法和hashCode方法时，equals方法中用到的成员也必定会在hashCode方法中用到，只不过前者作为比较项，后者作为生成摘要的信息项，本质上所用到的数据是一样的，从而保证二者的一致性</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/31/java%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/java%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">java继承、多态与类的复用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-31 19:53:17" itemprop="dateCreated datePublished" datetime="2021-01-31T19:53:17+08:00">2021-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-01 10:05:39" itemprop="dateModified" datetime="2021-02-01T10:05:39+08:00">2021-02-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文结合Java的类的复用对面向对象两大特征继承和多态进行了全面的介绍。首先，我们介绍了继承的实质和意义，并探讨了继承，组合和代理在类的复用方面的异同。紧接着，我们根据继承引入了多态，介绍了它的实现机制和具体应用。此外，为了更好地理解继承和多态，我们对final关键字进行了全面的介绍。在此基础上，我们介绍了Java中类的加载及初始化顺序。最后，我们对面向对象设计中三个十分重要的概念–重载、覆盖与隐藏进行了详细的说明。</p>
<p><strong>要点：</strong></p>
<ul>
<li>继承</li>
<li>组合、继承、代理</li>
<li>多态</li>
<li>final关键字</li>
<li>类加载及初始化顺序</li>
<li>重载、覆盖与隐藏</li>
</ul>
<h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>继承是所有OOP语言不可缺少的部分，在java中，使用extends关键字来表示继承关系。当创建一个类时，总是在继承，如果没有明确指出要继承的类，就总是隐式地从根类Object进行继承。如果两个类存在继承关系，则子类会自动继承父类的方法和变量，在子类中可以直接调用父类的方法和变量。需要指出的是，在java中，只允许单继承，也就是说，一个类最多只能显式地继承于一个父类。但是，一个类却可以被多个类继承，也就是说，一个类可以拥有多个子类。此外，<strong>我们需要特别注意以下几点：</strong></p>
<p>1、成员变量的继承</p>
<p>当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：</p>
<ul>
<li>子类能够继承父类的public和protected成员变量，不能够继承父类的private成员变量，但可以通过父类相应的getter/setter方法进行访问；</li>
<li>对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承，否则，子类不能够继承；</li>
<li>对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。</li>
</ul>
<p>2、成员方法的继承</p>
<p>同样地，当子类继承了某个类之后，便可以使用父类中的成员方法，但是子类并不是完全继承父类的所有方法。具体的原则如下：</p>
<ul>
<li>子类能够继承父类的public和protected成员方法，不能够继承父类的private成员方法；</li>
<li>对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承，否则，子类不能够继承；</li>
<li>对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。</li>
</ul>
<p><strong>程序示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String gentle = <span class="string">&quot;Father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String gentle = <span class="string">&quot;Son&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.gentle;	<span class="comment">//在子类中访问父类中同名成员变</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        Student student= <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;####&quot;</span> + student.gentle);</span><br><span class="line">        Person p = student;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****&quot;</span> + p.gentle);	<span class="comment">//隐藏：编译时决定，不会发生多态</span></span><br><span class="line">        </span><br><span class="line">        Sytem.out.println(<span class="string">&quot;----&quot;</span> + student.print());</span><br><span class="line">        System.out.println(<span class="string">&quot;----&quot;</span> + p.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。</p>
<p>3、基类的初始化与构造器</p>
<p>导出类就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但是，继承并不只是复制基类的接口。当创建一个导出类对象时，该对象会包含一个基类的子对象。这个子对象与我们用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部。</p>
<p>因此，对基类子对象的正确初始化是至关重要的，并且java也提供了相应的方法来保证这一点：导出类必须在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力。当基类含有默认构造时，java会自动在导出类的构造器插入对该基类默认构造器的调用，因为编译器不必考虑要传递什么样的参数的问题。但是，若父类不含有默认构造器，或者导出类想调用一个带参数的父类构造器，那么在导出类的构造器中就必须使用super关键字显式的进行调用相应的基类的构造器，并且该调用语句必是导出类构造器的第一条语句。</p>
<h2 id="二、组合，继承，代理"><a href="#二、组合，继承，代理" class="headerlink" title="二、组合，继承，代理"></a>二、组合，继承，代理</h2><p>组合、继承和代理三种技术都可以实现代码的复用。</p>
<p><strong>（1）组合（has-a）</strong></p>
<p><strong>通过在新的类中加入现有类的对象即可实现组合。</strong>即，新的类是由现有类的对象所组成。<strong>该技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。</strong>也就是说，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。</p>
<p><strong>（2）继承 （is-a）</strong></p>
<p>继承可以使我们按照现有类的类型来创建新类。即，我们采用现有类的形式并在其中添加新代码。通常，这意味着我们在使用一个通用类，并为了某种特殊需要而将其特殊化。本质上，组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。</p>
<p><strong>（3）代理（继承与组合之前的一种中庸之道：像组合一样使用已有类的功能，同时像继承一样使用已有类的接口)</strong></p>
<p>代理是继承与组合之前的一种中庸之道，java并没有提供对它的直接支持。在代理中，我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴漏了该成员对象的接口/方法。（就像继承）</p>
<p><strong>程序示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太空船需要一个控制模块，那么，构造太空船的一种方式是使用继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> <span class="keyword">extends</span> <span class="title">SpaceShipControls</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpaceShip</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpaceShip protector = <span class="keyword">new</span> SpaceShip(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">        protector.forward(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，SpaceShip 并不是真正的 SpaceShipControls 类型，即便你可以“告诉” SpaceShip 向前运动（forward()）。<strong>更准确的说，SpaceShip 包含 SpaceShipControls ，与此同时， SpaceShipControls 的所有方法在 SpaceShip 中都暴露出来。</strong> <strong>代理（SpaceShip 的运动行为由 SpaceShipControls 代理完成）</strong> 正好可以解决这种问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpaceShip 的行为由 SpaceShipControls 代理完成</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> SpaceShipControls controls = <span class="keyword">new</span> SpaceShipControls(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理方法: </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.back(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.down(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.forward(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.left(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.right(velocity); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        controls.turboBoost(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123; </span><br><span class="line">        controls.up(velocity); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        SpaceShipDelegation protector = <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>); </span><br><span class="line">        protector.forward(<span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，使用代理时可以拥有更多的控制力，因为我们可以选择只提供在成员对象中方法的某个子集。</p>
<h2 id="三、final关键字"><a href="#三、final关键字" class="headerlink" title="三、final关键字"></a>三、final关键字</h2><p>　许多编程语言都需要某种方法来向编译器告知一块数据是恒定不变的。有时，数据的恒定不变是很有用的，比如：</p>
<ul>
<li>一个永不改变的编译时常量；</li>
<li>一个在运行时被初始化的值，而你不希望它被改变。</li>
</ul>
<p>对于编译期常量这种情况，编译器可以将该常量值带入任何可能用到它的计算式中，也即是说，可以在编译时执行计算式，这减轻了一些运行时负担。在java中，这类常量必须满足两个条件：</p>
<ul>
<li>是基本类型，并且用final修饰；</li>
<li>在对这个常量进行定义的时候，必须对其进行赋值。</li>
</ul>
<p>此外，当用final修饰对象引用时，final使其引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。然而，对象本身是可以被修改的，这同样使用于数组，因为它也是对象。</p>
<p>特别需要注意的是，我们不能因为某数据是final的，就认为在编译时就可以知道它的值。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i4=rand.nextInt(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、空白final</p>
<p>　　Java允许生成 <strong>空白final</strong> , 即：<strong>声明final但又未给定初值的域。</strong>但无论什么情况，编译器都会确保空白final在使用前被初始化。但是，<strong>空白final在关键字final的使用上提供了更大的灵活性:</strong> <strong>一个类中的 final域 就可以做到根据对象而有所不同，却又保持其恒定不变的特性</strong></p>
<p>必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。</p>
<p>2、final参数</p>
<p>final参数主要应用于局部内部类和匿名内部类中。</p>
<p>3、final方法</p>
<p><strong>final关键字作用域方法时，用于锁定方法，以防任何继承类修改它的含义。**</strong>这是出于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。**</p>
<p>　　<strong>对于成员方法，只有在明确禁止覆盖时，才将方法设为final的。</strong></p>
<p>4、final类</p>
<p>当讲某个类定义为final时，就表明你不打算继承该类，而且也不允许别人这样做。换句话说，出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全考虑，你不希望它有子类。</p>
<p>需要注意的是，final类的域可以根据实际情况选择是否为final的。不论是否被定义为final，相同的规则都适用于定义final的域。然而，由于final类禁止继承，所以final类中的所有方法都隐式指定为final的，因为无法覆盖它们。在final类中可以给方法添加final修饰，但这不会增添任何意义。</p>
<p>5、final与private</p>
<p><strong>类中所有的private方法都隐式地指定为final的。</strong>由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰，但这并不会给该方法添加任何额外的意义。</p>
<p>特别需要注意的是，覆盖只有在某方法是基类接口的一部分时才会出现。如果一个方法是private的，它就不是基类接口中的一部分，而仅仅是一些隐藏于类中的程序代码。但若在类中以相同的名称生成一个非private方法，此时我们并没有覆盖该方法，仅仅是生成了一个新的方法。由于private方法无法触及并且能有效隐藏，所以除了把它看成是由于它所归属的类的组织结构的原因而存在外，其他任何情况都不需要考虑它。</p>
<p>6、final与static</p>
<ul>
<li>static修饰变量时，其具有默认值，且可改变，且其只能修饰成员变量和成员方法。</li>
<li>一个static final域只占据一段不能改变的存储空间，且只能在声明时进行初始化。因为其是final的，因而没有默认值；且又是static的，因此在类没有实例化时，其已被赋值，所以只能在声明时初始化。</li>
</ul>
<h2 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h2><p>继承允许将对象视为它自己本身的类型或基类型加以处理，从而使同一份代码可以毫无差别地运行在这些不同的类型之上。其中，多态方法调用允许一种类型表现出其他相似类型之间的区别，只要这些类型由同一个基类所导出。所以，多态的作用主要体现在两个方面：</p>
<ul>
<li>多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来，从而实现将改变的事物与未变的事物分离开来；</li>
<li>消除类型之间的耦合关系</li>
</ul>
<p>1、实现机制</p>
<p>方法的覆盖很好的体现了多态，但是当使用一个基类引用去调用一个覆盖方法时，到底该调用哪个方法才正确呢？</p>
<p>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。但是，显然，这种机制并不能解决上面的问题，因为在编译时编译器并不知道上述基类引用到底指向哪个对象。解决的办法就是后期绑定（动态绑定/运行时绑定）：在运行时根据对象的具体类型进行绑定。</p>
<p>事实上，在java中，除了static方法和final方法外，其他所有的方法都是后期绑定。这样，一个方法声明为final后，可以防止其他人覆盖该方法，但更重要的一点是：这样做可以有效地关闭动态绑定，或者说，告诉编译器不需要对其进行动态绑定，以便为final方法调用生成更有效的代码。</p>
<p>基于动态绑定机制，我们就可以编写只与基类打交道的代码了，并且这些代码对所有的导出类都可以正确运行。或者说，发送消息给某个对象，让该对象去断定该做什么事情。</p>
<p>2、向下转型与运行时类型识别</p>
<p>由于向上转型会丢失具体的类型信息，所以我们可能会想，通过向下转型也应该能够获取类型信息。然而，向上转型是安全的，因为基类不会具有大于导出类的接口。因此，我们通过基类接口发送的消息都能被接受，但是对于向下转型，我们就无法保证了。</p>
<p>要解决这个问题，必须有某种方法来确保向下转型的正确性，使我们不至于贸然转型到一种错误的类型，进而发出该对象无法接受的消息。在java中，运行时类型识别（RTTI）机制可以处理这个问题，它保证java中所有的转型都会得到检查。所以，即使我们只是进行一次普通的加括弧形式的类型转换，再进入运行期时仍会对其进行检查，以便保证它的确是我们希望的那种类型。如果不是，我们就会得到一个类型转换异常：ClassCastException。</p>
<p>3、多态的应用举例</p>
<ul>
<li>策略模式</li>
<li>适配器模式</li>
</ul>
<h2 id="五、类加载及初始化顺序"><a href="#五、类加载及初始化顺序" class="headerlink" title="五、类加载及初始化顺序"></a>五、类加载及初始化顺序</h2><p>类加载及初始化顺序：父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造函数-&gt;子类非静态代码块-&gt;子类构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String STR = <span class="string">&quot;Super Class Static Variable&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Static Block:&quot;</span> + STR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Constructor Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Super Class Block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInit</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String STR = <span class="string">&quot;Class Static Variable&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class Static Block:&quot;</span> + STR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class Block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        ObjectInit a = <span class="keyword">new</span> ObjectInit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">        Super Class Static Block:Super Class Static Variable</span></span><br><span class="line"><span class="comment">        Class Static Block:Class Static Variable</span></span><br><span class="line"><span class="comment">        Super Class Block</span></span><br><span class="line"><span class="comment">        Super Class Constructor Method</span></span><br><span class="line"><span class="comment">        Class Block</span></span><br><span class="line"><span class="comment">        Constructor Method</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在运行该程序时，所发生的第一件事就是试图访问ObjectInit.main方法（一个static方法），于是加载器开始启动并加载ObjectInit类。在对其加载时，编译器注意到它有一个基类（由关键字extends得知），于是先进行加载其基类。如果该基类还有其自身的基类，那么先加载这个父基类，如此类推（本例中是先加载Object类，再加载SuperClass类，最后加载ObjectInit类）。接下来，根基类中的static域和static代码块会被执行，然后是下一个导出类，以此类推这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否正确初始化。到此为止，所有的类都已加载完毕，对象就可以创建了。首先，初始化根基类所有的普通成员变量和代码块，然后执行根基类构造器以便创建一个基对象，然后是下一个导出类，依次类推，知道初始化完成。</p>
<h2 id="六、重载、覆盖与隐藏"><a href="#六、重载、覆盖与隐藏" class="headerlink" title="六、重载、覆盖与隐藏"></a>六、重载、覆盖与隐藏</h2><p>1、重载与覆盖</p>
<p>重载：如果在一个类中定义了多个同名的方法，但它们有不同的参数（包含三方面：参数个数，参数类型和参数顺序），则称为方法的重载。其中，不能通过访问权限、返回类型和抛出异常进行重载。</p>
<p>覆盖：子类中定义的某个方法与其父类中某个方法具有相同的方法签名（包含相同的名称和参数列表），则称为方法的覆盖。子类对象使用这个方法时，将调用该方法在子类中的定义，对它而言，父类中该方法的定义被屏蔽了。</p>
<p>总的来说，重载和覆盖是java多态性的不同表现。前者是一个类中多态性的一种表现，后者是父类与子类之间多态性的一种表现。</p>
<p>2、实现机制</p>
<p>重载是一种参数多态机制，即通过方法参数的差异实现多态机制。并且，其属于一种静态绑定机制，在编译时已经知道具体执行哪个方法。</p>
<p>覆盖是一种动态绑定的多态机制。即，在父类与子类中具有相同签名的方法具有不同的具体实现，至于最终执行哪个方法根据运行时的实际情况而定。</p>
<p><strong>覆盖与隐藏</strong></p>
<p>定义：</p>
<p>覆盖：指运行时系统调用当前对象引用<strong>运行时类型</strong>中定义的方法，属于运行期绑定。</p>
<p>隐藏：指运行时系统调用当前对象引用<strong>编译时类型</strong>中定义的方法，即被声明或者转换为什么类型就调用对应类型中的方法或变量，属于编译器绑定。</p>
<p>范围：</p>
<p>覆盖：只针对示例方法。</p>
<p>隐藏：只针对静态方法和成员变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/27/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">路由协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-27 11:07:45 / 修改时间：16:15:32" itemprop="dateCreated datePublished" datetime="2021-01-27T11:07:45+08:00">2021-01-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><h2 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h2><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p><strong>工作原理：</strong>RIP是内部网关协议IGP中最先得到广泛使用的协议，它的中文名称叫做路由信息协议，但很少被使用。RIP是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议，其最大优点是简单。</p>
<p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。RIP协议将“距离”定义如下：</p>
<p>从一路由器到直接连接的网络的距离定义为1.从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1.“加1”是因为到达目的网络后就进行直接交付，而到直接连接的网络的距离已经定义为1.</p>
<p>RIP协议的“距离”也称为<strong>“跳数”</strong>，因为每经过一个路由器，跳数就加1.RIP认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。因此“距离”等于16时即相当于不可达。可见RIP只适用于小型互联网。</p>
<p><strong>RIP协议的特点是：</strong></p>
<p>1、仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。</p>
<p>2、路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就是说，交换的信息是：我到本自治系统中所有网络的最短距离，以及到每个网络应经过的下一跳路由器。</p>
<p>3、按固定的时间间隔交换路由信息，例如，每隔30秒。然后路由器根据收到的路由信息更新路由表。当网拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</p>
<p><strong>距离向量算法</strong></p>
<p>对<strong>每一个相邻路由器</strong>发送过来的RIP报文，进行以下步骤：</p>
<p>1、对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X，并并把所有的“距离”字段的值加1.每一个项目都有三个关键数据，即：到目的网络N，距离是d，下一跳路由器是X。</p>
<p>2、对修改后的RIP报文中的每一个项目，进行以下步骤：</p>
<p>​    若原来的路由表中没有目的网络N，则把该项目添加到路由表中。</p>
<p>​    否则（即在路由表中有目的网络N，这时就再查看下一跳路由器地址）</p>
<p>​        若下一跳路由器地址是X，则把收到的项目替换源路由表中的项目</p>
<p>​        否则(即这个项目是：到目的网络N，但下一跳路由器不是X)</p>
<p>​            若收到的项目中的距离d小于路由表中的距离，则进行更新</p>
<p>​            否则什么也不做。</p>
<p>3、若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为16.</p>
<p>4、返回。Bellman-Ford算法。</p>
<h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p><strong>OSPF协议的基本特点</strong></p>
<p>这个协议的名字是<strong>开放最短路径优先（Open Shortest Path First）</strong>。OSPF最主要的特征就是使用<strong>分布式的链路状态协议</strong>，而不是像RIP那样的距离向量协议。和RIP协议相比，OSPF的三个要点和RIP的都不一样：</p>
<p>1、向本自治系统中所有路由器发送信息，这里使用的方法是泛洪法（flooding），这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。</p>
<p>2、发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息。</strong>所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</p>
<p>3、只有当链路状态发生变化时，路由器才向所有路由器洪泛法发送此信息。而不像RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</p>
<p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库（link-state database）</strong>，这个数据库实际上就是<strong>全网的拓扑结构图</strong>。</p>
<p><strong>OSPF的五种分组类型</strong></p>
<p>OSPF共有以下五种分组类型：</p>
<p>1、类型1，<strong>问候（Hello）分组</strong>，用来发现和维持临站的可达性。</p>
<p>2、类型2、<strong>数据库描述（Database Description）</strong>分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</p>
<p>3、类型3，<strong>链路状态请求（Link State Request）</strong>分组，向对方请求发送某些链路状态项目的详细信息。</p>
<p>4、类型4，<strong>链路状态更新（Link State Update）</strong>分组，用泛洪法对全网更新链路状态。这种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组工有五种不同的链路状态。</p>
<p>5、类型5，<strong>链路状态确认（Link State Acknowledgment）</strong>分组，对链路更新分组的确认。</p>
<h2 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h2><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>内部网关协议主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为以下的两个原因：</p>
<p>第一，<strong>互联网的规模太大，使得自治系统AS之间路由选择非常困难。</strong></p>
<p>第二、<strong>自治系统AS之间的路由选择必须考虑有关策略。</strong></p>
<p>由于上述情况，边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。BGP采用了路径向量（path vector）路由选择协议，它与距离向量协议（如RIP）和链路状态协议（如OSPF）都有很大的区别。</p>
<p>一个GP发言人与其他BGP发言人要交换路由信息，就要先建立TCP连接（端口号为179），然后在此连接上交换BGP报文以建立BGP会话(session)，利用BGP会话 交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用TCP连接能提供可靠的服务，也简化了路由选择协议。使用TCP连接交换路由信息的两个BGP发言人，彼此成为对方的临站或对等站。</p>
<h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/26/java%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/26/java%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">java堆内存设置原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-26 10:54:56 / 修改时间：14:39:36" itemprop="dateCreated datePublished" datetime="2021-01-26T10:54:56+08:00">2021-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM堆内存分为2块：Permanent Space和Heap Space.</p>
<ul>
<li>Permanent即持久代（Permanent Generation），主要存放的是java类定义信息，与垃圾收集器要收集的java对象关系不大。</li>
<li>Heap={Old + New = {Eden, from, to}}，Old即老年代（Old Generation），New即年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</li>
</ul>
<h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2><p>所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from和to）。</p>
<p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p>
<p>2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来的对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有一个从Survivor区过来的对象。<strong>而且，因为需要交换的原因，Survivor区至少有一个是空的。</strong>特殊的情况下，根据程序需要，Survivor区是可以配置为多个的，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p>针对年轻代的垃圾回收即Young GC.</p>
<h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h2><p>在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>针对年老代的垃圾回收即Full GC.</p>
<h2 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h2><p>用于存放静态类型数据，如Java Class，Method等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如Hibernate CGLib等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</p>
<p>所以，当一组对象生成时，<strong>内存申请过程</strong>如下：</p>
<p>1、JVM会试图为相关java对象在年轻代的Eden区中初始化一块内存区域。</p>
<p>2、当Eden区空间足够时，内存申请结束。否则执行下一步。</p>
<p>3、JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。</p>
<p>4、Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。</p>
<p>5、当年老代空间足够时，JVM会在年老代进行完全的垃圾回收（Full GC）.</p>
<p>6、Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现”Out of Memory”.</p>
<p><strong>OOM(“Out of Memory”)异常一般主要有如下2种原因：</strong></p>
<p>1、年老代溢出，表现为：java.lang.OutOfMemoryError：javaheapspace。这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄漏及使用不当问题。例如循环上万次的字符串处理、创建上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间端的垃圾回收，也无法处理其他请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具。</p>
<p>2、持久代溢出，表现为：java.lang.OutOfMemoryError：PermGenspace.通常由于持久代设置过小，动态加载了大量java类而导致溢出，解决办法唯有将参数 -XX：MaxPermSize调大（一般256m能满足绝大多数应用程序需求）。将部分java类放到容器共享区（例如tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li>-Xmx3550m:设置JVM最大堆内存为3550M.</li>
<li>-Xms3550m:设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li>
<li>-Xss128k: 设置每个线程的栈大小。JDK5.0以后每个线程大小为1M，之前每个线程栈大小为256K.应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减少这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大时将会在很大程度上降低系统的性能。</li>
<li>-Xmn2g: 设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为每个堆大小的3/8.</li>
<li>-XX：NewSize=1024m：设置年轻代初始值为1024M.</li>
<li>-XX:MaxNewSize=1024m:设置年轻代最大值为1024M.</li>
<li>-XX：PermSize=256m:设置持久代最大值为256M.</li>
<li>-XX：MaxPermSize=256m:设置持久代最大值为256M。</li>
<li>-XX：NewRatio=4:设置年轻代（包括1个Eden和2个Survivor）与年老代的比值。表示年轻代比年老代为1：4.</li>
<li>-XX：SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2：4，即1个Survivor区占整个年轻代大小的1/6.</li>
<li>-XX:MaxTenuringThreshold=7 :表示一个对象如果在Survivor区移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年老代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li>
</ul>
<h2 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h2><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</p>
<p>默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><ul>
<li>-XX+UseSerialGC:设置串行收集器</li>
</ul>
<h3 id="并行收集器（吞吐量优先）"><a href="#并行收集器（吞吐量优先）" class="headerlink" title="并行收集器（吞吐量优先）"></a>并行收集器（吞吐量优先）</h3><ul>
<li>-XX+UseParallelGC:设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li>
<li>-XX：ParallelGCThreads=20:配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数据相等。</li>
<li>-XX:+UseParallelOldGC:配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li>
<li>-XX：MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li>
<li>-XX+UseAdaptiveSizePolicy:设置此选型后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直</li>
</ul>
<h3 id="并发收集器（响应时间优先）"><a href="#并发收集器（响应时间优先）" class="headerlink" title="并发收集器（响应时间优先）"></a>并发收集器（响应时间优先）</h3><ul>
<li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li>
<li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li>
<li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li>
<li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li>
<li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li>
<li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li>
</ul>
<h3 id="其他垃圾回收参数"><a href="#其他垃圾回收参数" class="headerlink" title="其他垃圾回收参数"></a>其他垃圾回收参数</h3><ul>
<li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li>
<li>-XX:-DisableExplicitGC：不响应 System.gc() 代码。</li>
<li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 <code>java.lang.Thread.setPriority() </code>生效，不启用则无效。</li>
<li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li>
<li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于</li>
</ul>
<h2 id="辅助信息参数设置"><a href="#辅助信息参数设置" class="headerlink" title="辅助信息参数设置"></a>辅助信息参数设置</h2><ul>
<li>-XX:-CITime：打印消耗在JIT编译的时间。</li>
<li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li>
<li><strong>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</strong></li>
<li><strong>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</strong></li>
<li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li>
<li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li>
<li>-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li>
<li>-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li>
<li>-XX:-PrintCompilation：当一个方法被编译时打印相关信息。</li>
<li>-XX:-PrintGC：每次GC时打印相关信息。</li>
<li>-XX:-PrintGCDetails：每次GC时打印详细信息。</li>
<li>-XX:-PrintGCTimeStamps：打印每次GC的时间戳。</li>
<li>-XX:-TraceClassLoading：跟踪类的加载信息。</li>
<li>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li>
<li>-XX:-TraceClassResolution：跟踪常量池。</li>
<li>-XX:-TraceClassUnloading：跟踪类的卸载信息。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/18/%E7%89%B9%E6%AE%8A%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E7%89%B9%E6%AE%8A%E6%A0%91/" class="post-title-link" itemprop="url">特殊树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-18 15:38:10 / 修改时间：17:11:16" itemprop="dateCreated datePublished" datetime="2021-01-18T15:38:10+08:00">2021-01-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>概念：</strong></p>
<p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；</p>
<p><strong>特点：</strong></p>
<p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p>
<p>1、非叶子节点只能允许最多两个子节点存在。</p>
<p>2、每一个非叶子节点数据分布规则为左边的子节点小当前的值，右边的子节点大于当前节点的值（这里值是基于自己的算法规则而定的，比如hash值）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-28e39093993f673de576f57ea614d604_720w.jpg" alt="img"></p>
<p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度，一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法有比如Treap、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p>
<p><img src="https://pic4.zhimg.com/80/v2-2b52d4e523f374f41b5429cd587443db_720w.jpg" alt="img"></p>
<p>总结平衡二叉树特点：</p>
<ul>
<li>非叶子节点最多拥有两个子节点</li>
<li>非叶子节值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1</li>
<li>没有值相等重复的节点；</li>
</ul>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>概念：</strong>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树，数据库索引技术里大量使用B树和B+树的数据结构。</p>
<p><strong>规则：</strong></p>
<ul>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1,且&lt;=M,且M&gt;=2,空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路，当M=2则是2叉树，M=3则是3叉）</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（ceil()是一个朝正无穷方向取整的函数，如ceil()1.1结果为2）</li>
<li>所有叶子节点均在同一层，叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针，只不过其指针地址都为null对应下图最后一层节点的空格子；</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_720w.jpg" alt="img"></p>
<p><strong>B树的查询流程：</strong></p>
<p>如上图查找字母E的流程如下：</p>
<p>1、获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的节点点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p>
<p>2、拿到关键字D和G，D&lt;E&lt;G所以直接找到D和G中间的节点；</p>
<p>3、拿到E和F，因为E=E所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
<p><strong>B树的插入节点流程</strong></p>
<p>定义一个5阶树（平衡5路查找树），现在我们要把3、8、31、11、23、29、50、28这些数字构建出一个5阶数出来；</p>
<p>遵循规则;</p>
<p>1、节点拆分规则：当前是要组成一个5路查找树，那么此时m=5，关键字数必须&lt;=5-1(这里关键字数&gt;4就要进行节点拆分)</p>
<p>2、排序规则，满足节点本身比左边节点大，比右边节点小的排序规则；</p>
<p>先插入3、8、31、11</p>
<p><img src="https://pic4.zhimg.com/80/v2-e1d65c9c6236d4768c89e8e103e12583_720w.jpg" alt="img"></p>
<p>再插入23、29</p>
<p><img src="https://pic1.zhimg.com/80/v2-66cdb6187cbc5227fd8c4aabe7282e6c_720w.jpg" alt="img"></p>
<p>再插入50、28</p>
<p><img src="https://pic1.zhimg.com/80/v2-3057eaab2b1764dd51c2a8658791cc98_720w.jpg" alt="img"></p>
<p><strong>B树节点的删除</strong></p>
<p><strong>规则：</strong></p>
<p>1、节点合并规则：当前是要组成一个5路查找树，那么此时m=5，关键字数必须大于等于ceil（5/2）;</p>
<p>2、满足节点本身比左边节点大，比右边节点小的排序规则；</p>
<p>3、关键字数小于二时先从子节点取，子节点没有符合条件时就向父节点取，取中间值往父节点放；</p>
<p><img src="https://pic2.zhimg.com/80/v2-a0f981fc847772cb28869927cd4fe66d_720w.jpg" alt="img"></p>
<p><strong>特点：</strong>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘块大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度；</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><strong>概念</strong></p>
<p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。</p>
<p><strong>规则：</strong></p>
<p>1、B+根B树不同，B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</p>
<p>2、B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>3、B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>4、非叶子节点的子节点数=关键字数</p>
<p><img src="https://pic4.zhimg.com/80/v2-5f069fd820637db1b877fdd6799a2b67_720w.jpg" alt="img"></p>
<p><strong>特点：</strong></p>
<ul>
<li>B+树的层级更少；相较于B树每个非叶子节点存储的关键字数更多，树的层级更少所以插叙数据更快；</li>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定；</li>
<li>B+树天然具备排序功能:B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
<li>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/14/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98/" class="post-title-link" itemprop="url">牛客刷题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 15:01:53" itemprop="dateCreated datePublished" datetime="2021-01-14T15:01:53+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-03 19:08:58" itemprop="dateModified" datetime="2021-02-03T19:08:58+08:00">2021-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1.Statement的作用</strong></p>
<ul>
<li>用于执行不带参数的简单SQL语句</li>
<li>Prepared Statement对象用于执行预编译SQL语句。</li>
<li>Callable Statement对象用于执行对存储过程的调用。</li>
</ul>
<p><strong>2.在java中，对于不再使用的内存资源，如调用完成的方法，“垃圾回收器”会自动将其释放么？</strong></p>
<p>不会。方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放。JVM内存可简单分为三个区：</p>
<ul>
<li>堆区，用于存放所有对象，是线程共享的。（数组也属于对象）</li>
<li>栈区，用于存放基本数据类型的数据和对象的引用，是线程私有的。</li>
<li>方法区，用于存放类信息、常量、静态变量、编译后的字节码等，是线程共享的</li>
</ul>
<p>gc主要针对堆区。</p>
<p><strong>3.字符流</strong></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537222061_12B6233B6EA3C9956865918F5E9B7240" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190603/652334996_1559537178275_256EC3581646F19915DBB5C9F4D80330" alt="img"></p>
<p><strong>4.java创建对象的方式</strong></p>
<p>5种方式：</p>
<ul>
<li>使用new关键字</li>
<li>使用反射的Class类的newInstance方法</li>
<li>使用反射的Constructor类的newInstance（）方法</li>
<li>使用对象克隆clone（）方法</li>
<li>使用反序列化（ObjectInputStream）的readObject()方法</li>
</ul>
<p><strong>5.java包的作用</strong></p>
<p>为了更好地组织类，java提供了包机制，用于区别类名的命名空间。</p>
<p>包的作用：</p>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。java使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</li>
</ul>
<p><strong>6.File类的常用方法和说明</strong></p>
<p>1.访问文件名相关方法：</p>
<ul>
<li><p>String getName(); 返回此File对象所表示的文件名和路径名（如果是路径，则返回最后一级子路径名）。</p>
</li>
<li><p>String getPath(); 返回此File对象所对应的路径名。</p>
</li>
<li><p>File getAbsolutePath(); 返回此File对象所对应的绝对路径名。</p>
</li>
<li><p>String getParent(); 返回此File对象所对应目录（最后一级子目录）的父路径名。</p>
</li>
<li><p>boolean renameTo(File newName); 重命名此File对象所对应的文件或目录，如果重命名成功，则返回true:否则返回false.<strong>（A）</strong></p>
</li>
</ul>
<p>2.文件检测相关方法</p>
<ul>
<li>boolean exists(); 判断File对象所对应的文件或目录是否存在。</li>
<li>boolean canWrite(); 判断File对象所对应的目录或文件是否可写。</li>
<li>boolean canRead(); 判断File对象所对应的目录或文件是否可读。</li>
<li>boolean isFile(); 判断File对象所对应的是否是文件，而不是目录。</li>
<li>boolean isDirectory(); 判断File对象所对应的是否是目录，而不是文件。</li>
<li>boolean isAbsolute(); 判断File对象所对应的文件或目录是否是绝对路径。该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在UNIX/Linux/BSD等系统上，如果路径名开头是一条斜线（/）,则表明该File对象对应一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是绝对路径。</li>
</ul>
<p>3.获取常规文件信息</p>
<ul>
<li>long lastModified(); 返回文件最后修改时间。</li>
<li>long length(); 返回文件内容的长度。</li>
</ul>
<p>4.文件操作相关的方法</p>
<ul>
<li>boolean createNewFile(); 当此File对象所对应的文件不存在时，该方法将新建的一个该File对象所指定的新文件，如果创建成功则返回true；否则返回false.<strong>(C)</strong></li>
<li>boolean delete(); 删除File对象所对应的文件或路径。</li>
<li>static File CreateTempFile(String prefix,String suffix);在默认的临时文件目录创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。preFix参数必须至少是3个字节长。建议前缀使用一个短的、有意义的字符串。建议前缀使用一个短的、有意义的字符串，比如”hjb“ 或”main”. suffix参数可以为null,在这种情况下，将使用默认的后缀”.tmp”.</li>
<li>static File CreateTempFile(String prefix,String suffix,File directory);在directory所指定的目录中创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。</li>
<li>void deleteOnExit(); 注册一个删除钩子，指定当Java虚拟机退出时，删除File对象随对应的文件和目录。</li>
</ul>
<p>5.目录操作相关方法<strong>（D）</strong></p>
<ul>
<li>boolean mkdir(); 试图创建一个File对象所对应的目录，如果创建成功，则返回true;否则返回false. 调用该方法时File对象必须对应一个路径，而不是一个文件。</li>
<li>String[] list(); 列出File对象的所有子文件名和路径名，返回String数组。</li>
<li>File[] listFiles(); 列出File对象的所有子文件和路径，返回File数组。</li>
<li>static File[] listRoots(); 列出系统所有的根路径。这是一个静态方法，可以直接通过File类来调用。</li>
</ul>
<p><strong>7.几种内部类</strong></p>
<p>在java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类。</p>
<p>1、成员内部类</p>
<ul>
<li>该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；</li>
<li>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量或外部类.this.成员方法】</li>
<li>在外部类中如果要访问内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</li>
<li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；</li>
<li>内部类可以拥有private访问权限，protected访问权限，public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限。</li>
</ul>
<p>2、局部内部类</p>
<ul>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问权限于方法内或者该作用域内；</li>
<li>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</li>
</ul>
<p>3、匿名内部类</p>
<ul>
<li>一般使用匿名内部类的方法来编写事件监听代码；</li>
<li>匿名内部类是不能有访问修饰符和static修饰符的；</li>
<li>匿名内部类是唯一一种没有构造器的类；</li>
<li>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</li>
</ul>
<p>4、内部静态类</p>
<ul>
<li>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</li>
<li>不能使用外部类的非static成员变量或者方法。</li>
</ul>
<p><strong>8.关于值相等</strong></p>
<p>1、int与Integer、new Integer()进行==比较时，结果永远为true；</p>
<p>2、Integer与new Integer()进行==比较时，结果永远为false</p>
<p>3、Integer与Integer进行==比较时，看范围；在大于等于-128小于等于127的范围内为true，在此范围外为false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1=<span class="number">127</span>;</span><br><span class="line">Integer a2=<span class="number">127</span>;</span><br><span class="line">System.out.println(a1==a2);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3=<span class="number">127</span>;</span><br><span class="line">Integer a4=<span class="keyword">new</span> Integer;</span><br><span class="line">System.out.println(a3==a4);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a5=<span class="number">128</span>;</span><br><span class="line">Integer a6=<span class="number">128</span>;</span><br><span class="line">System.out.println(a5==a6);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a7=<span class="number">128</span>;</span><br><span class="line">Integer a8=<span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">System.out.println(a7==a8);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Integer与Integer比较</span></span><br><span class="line">Integer a9=<span class="number">127</span>;</span><br><span class="line">Integer a10=<span class="number">127</span>;</span><br><span class="line">System.out.println(a9==a10);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer a11=<span class="number">128</span>;</span><br><span class="line">Integer a12=<span class="number">128</span>;</span><br><span class="line">System.out.println(a11==a12);	<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//new Integer()与Integer比较</span></span><br><span class="line">Integer a13=<span class="number">127</span>;</span><br><span class="line">Integer a14=<span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(a13==a14);	<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer a15=<span class="number">128</span>;</span><br><span class="line">Integer a16=<span class="number">127</span>;</span><br><span class="line">System.out.println(a15==a16);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>9.执行顺序</strong></p>
<p>父类静态代码块-&gt;子类静态代码块-&gt;父类构造代码块-&gt;父类构造函数-&gt;子类构造代码块-&gt;子类构造函数</p>
<p><strong>10.String,StringBuilder,StringBuffer</strong></p>
<p>StringBuilder，StringBuffer，String都是final的，但是为什么StringBuilder，StringBuffer可以进行修改呢，因为不可变包括的是，引用不可变及对象不可变，而这三个都是属于引用不可变，（也就是地址不要变，里面的内容随心所欲），而StringBuilder，StringBuffer中都包含append方法，可对对象中的内容进行增加。</p>
<p><strong>11.HashMap与HashTable区别</strong></p>
<p>HashMap是map接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap允许null key和null value，而Hashtable不允许。</p>
<p>HashTable是线程安全Collection。</p>
<p>区别如下：</p>
<ul>
<li>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</li>
<li>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。</li>
<li>HashTable继承自Dictionary类，而HashMap是java1.2引进的Map interface的一个实现。</li>
<li>HashTable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap就必须为之提供外同步。</li>
</ul>
<p><strong>12 识别合法的构造方法</strong></p>
<p>构造方法可以被重载，一个构造方法可以通过this关键字调用另一个构造方法，this语句必须位于构造方法的第一行；方法的重载：重载构成的条件：方法的名称相同，但参数类型或参数个数不同，才能构成方法的重载。</p>
<p>当一个类中没有定义任何构造方法，java将自动提供一个缺省构造方法；</p>
<p>子类通过super关键字调用父类的一个构造方法；</p>
<p>当子类的某个构造方法没有通过super关键字调用父类的构造方法，通过这个构造方法创建子类对象时，会自动先调用父类的缺省构造方法。</p>
<p>构造方法不能被static,final,synchronized,abstract,native修饰，但可以被public,private,protected修饰；</p>
<p>构造方法不是类的成员方法；</p>
<p>构造方法不能被继承</p>
<p><strong>13、解决哈希冲突</strong></p>
<p>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLoaclMap中的散列值分散的十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清楚无用的对象，使用传数组更加方便。</p>
<p><strong>14、switch支持的类型</strong></p>
<p>以java8为准，switch支持10种类型 基本类型：byte,char,short,int 对于包装类：Byte,Short,Character,Integer String Enum</p>
<p>实际只支持int类型 java实际只用支持int类型的switch语句，那其他的类型是如何支持的 a、基本类型byte char short原因：这些基本数字类型可自动向上转为int，实际还是用的int。b、基本类型包装类Byte,Short，Character，Integer原因：java的自动拆箱机制可看这些对象自动转为基本类型 c、String类型原因：实际switch比较的string.hashCode值，它是一个int类型</p>
<p><strong>15、JVM内存结构</strong></p>
<p>程序计数器是一个以<strong>线程私有</strong>的一块较小的内存空间，用于记录所属线程所执行的字节码的行号指示器；字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20190627/284864965_1561601257798_221440388796170.png" alt="img"></p>
<p><strong>16、面向对象的五大基本原则</strong></p>
<p>单一职责原则（SRP）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>
<p>开放封闭原则（OCP）：软件实体应该是可扩展的，而不可修改的。也就是，对外扩展开放，对修改封闭的。</p>
<p>里氏替换原则（LSP）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p>
<p>依赖倒置原则（DIP）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>
<p>接口隔离原则（ISP）：使用多个小的转么的接口，而不要使用一个大的总接口</p>
<p><strong>17、Collections</strong></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20160418/854180_1460986378682_4B1F66BFB4ADEB24A093A20778555B52" alt="img"></p>
<hr>
<p><strong>18、java内部类</strong></p>
<ul>
<li><p>为什么使用内部类</p>
<ul>
<li><p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个实现，所以无论外围类是否已经继承了某个实现，对于内部类都没有影响</p>
<p>1.1 使用内部类最大的优点就在于能够非常好的解决多重继承的问题，使用内部类还能够为我们带来如下特性:</p>
<ul>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的’”is-a”‘关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
</li>
</ul>
</li>
<li><p>内部类分类：</p>
<ul>
<li><p>成员内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age =<span class="number">99</span>;</span><br><span class="line">    String name=<span class="string">&quot;CoCo&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner in=o.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.Inner类定义在Outer类的内部，相当于Outer类的一个成员变量的位置，Inner类可以使用任意访问控制符，如public、protected、private等</p>
<p>2、Inner类中定义的show()方法可以直接访问Outer类中的数据，而不受访问控制符的影响，如直接访问Outer类中的私有属性age</p>
<p>3、定义了成员内部类，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象，</p>
<p>即：内部类 对象名=外部类对象.new 内部类（）；</p>
<p>4、编译上面的程序后，会发现产生了两个.class文件：Outer.class，Outer$Inner.class{}.</p>
<p>5、成员内部类中不能存在任何static的变量和方法，可以定义常量：</p>
<ul>
<li>因为非静态内部类是要依赖于外部类的实例，而静态变量和方法是不依赖于对象的，仅与类相关。</li>
<li>简而言之：在加载静态域时，根本没有外部类，所以在非静态内部类中不能定义静态域或方法，编译不通过；非静态内部类的作用域是实例级别</li>
<li>常量是在编译器就确定的，放到所谓的常量池了。</li>
</ul>
<p>注意：外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法；如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用this关键字，如Outer.this.name</p>
</li>
<li><p>静态内部类：是static修饰的内部类</p>
<p>1、静态内部类不能直接访问外部类的非静态成员，但可以通过new 外部类().成员的方式访问</p>
<p>2、如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</p>
<p>3、创建静态内部类的对象时，不需要外部类的对象，可以直接创建内部类 对象名 = new 内部类();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age =<span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> String name=<span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        String name=<span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Outer.name);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Inner i=<span class="keyword">new</span> Inner();</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类</p>
<p>1、局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符</p>
<p>2、只能访问方法中定义的final类型的局部变量，因为：</p>
<p>​    当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在，直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量；使用final修饰符不仅会保持对象的引用不会改变，而且编译器还会持续维护这个对象在回调方法中的生命周期。局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了字节的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数；</p>
</li>
<li><p>匿名内部类：</p>
<p>1、匿名内部类是直接使用new来生成一个对象的引用；</p>
<p>2、对于匿名内部类的使用是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用；</p>
<p>3、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是二者不可兼得，同时也只能继承一个类或者实现一个接口；</p>
<p>4、匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法；</p>
<p>5、匿名内部类中不能存在任何的静态成员变量和静态方法，匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<p>6、匿名内部类初始化：使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.niuke;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">s5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass() &#123;</span><br><span class="line">            <span class="keyword">int</span> number=num+<span class="number">3</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        s5 out=<span class="keyword">new</span> s5();</span><br><span class="line">        InnerClass innerClass=out.getInnerClass(<span class="number">2</span>,<span class="string">&quot;shen&quot;</span>);</span><br><span class="line">        System.out.println(innerClass.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>19、java daemon线程</strong></p>
<p>java的线程分为两类：用户线程和daemon线程。</p>
<p>用户线程：用户线程可以简单的理解为用户定义的线程，当然包括majavain线程。</p>
<p>daemon线程：daemon线程是为我们创建的用户线程提供服务的线程，比如说JVM的GC等等，这样的线程有一个非常明显的特征：当用户线程运行结束的时候，daemon线程将会自动退出。</p>
<p>daemon线程的特点：</p>
<p>1、守护线程创建的过程中需要先调用setDaemon方法进行设置，然后再启动线程。否则会报出IllegalThreadStateException异常。</p>
<p>2、由于daemon线程的终止条件是当前是否存在用户线程，所以我们不能指派daemon线程来进进行一些业务操作，而只能服务用户线程。</p>
<p>3、daemon线程创建的子线程仍然是daemon线程。</p>
<p><strong>20、JVM参数配置</strong></p>
<p>举例所示：-Xms1G -Xms2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,</p>
<p>-Xms1G    设置java堆最小值为1G</p>
<p>-Xmx2G    设置java堆最大值为2G</p>
<p>-Xmn500M    设置新生代大小为500M（一个Eden区，两个Survivor区）</p>
<p>-XX：MaxPermSize=64M    设置永久代大小为64M</p>
<p>-XX：+UseConcMarkSweepGC    设置使用CMS收集器</p>
<p>-XX：SurvivorRatio=3    设置Eden区与Survivor区大小的比例。</p>
<p><strong>21、实现会话跟踪的机制</strong></p>
<p>Cookies、URL重写，隐藏式表单域，Session机制。</p>
<p>Cookies是使用最广泛的会话跟踪机制，Cookies是由服务器创建，并把Cookies信息保存在用户机器上的硬盘上，下次用户再次访问该站点服务器的时候，保存在用户机器上硬盘的Cookies信息就被送回给服务器。一般Cookies一般不多于4KB，且用户的敏感信息如信用卡账号密码不应该保存在Cookies中。</p>
<p>URL重写:URL重写用于在每个URL结尾附加标识会话的数据，与标识符关联的服务器保存有关与会话的数据，如我们访问某个新闻的时候，在地址栏我们一般会看到这样的信息：<a target="_blank" rel="noopener" href="http://www.xxx.com/news?id=??%EF%BC%8C%E9%80%9A%E5%B8%B8%E7%9A%84%E8%AF%9Did%E5%90%8E%E9%9D%A2%E7%9A%84%E9%97%AE%E5%8F%B7%E8%A1%A8%E7%A4%BA%E8%AF%A5%E6%9D%A1%E6%96%B0%E9%97%BB%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%B0%E9%97%BB%E8%A1%A8%E7%9A%84id%E3%80%82URL%E9%87%8D%E5%86%99%E8%83%BD%E5%A4%9F%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%81%9C%E7%94%A8cookies%E6%88%96%E8%80%85%E4%B8%8D%E6%94%AF%E6%8C%81cookies%E7%9A%84%E6%97%B6%E5%80%99%E4%BB%8D%E7%84%B6%E8%83%BD%E5%A4%9F%E5%8F%91%E6%8C%A5%E4%BD%9C%E7%94%A8%E3%80%82">http://www.XXX.com/news?id=??，通常的话id后面的问号表示该条新闻在后台数据库中的新闻表的id。URL重写能够在客户端停用cookies或者不支持cookies的时候仍然能够发挥作用。</a></p>
<p>隐藏表单域：</p>
<p>通常，在表单中我们使用隐藏表单域的时候会有这么一句代码：<input type="hidden" name="XXX" value="XXX"/>。通过给type属性赋值为hidden值来实现隐藏，这样用户在浏览的时候看不到这行代码的数据，但是当用户通过查看源代码还是可以看到的。</p>
<p>Session机制</p>
<p>这个机制要慎用，特别是对于访问量很大的站点，因为这种机制是把session信息保存在服务器端。如果访问量特别大的话，对于服务器的承受力的要求有多高是可想而知的。</p>
<p><strong>22、J2EE常用名词解释</strong></p>
<p>1、web容器：给处于其中的应用程序组件（JSP，Servlet）提供一个环境，使JSP，Servlet直接和容器中的环境变量接口交互，不必关注其他系统问题。主要有web服务器来实现。例如，tomcat,weblogic,websphere等。该容器提供的接口严格遵守J2EE规范中的web application标准。我们把遵守以上标准的web服务器就叫做J2EE中的WEB容器。</p>
<p>2、Web container：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其他的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container由web服务器或者J2EE服务器提供。</p>
<p>3、EJB容器：Enterprise java Bean容器。更具有行业领域特色，他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。这个规范指定了一个Enterprise bean的运行时环境，包括安全、一致性、生命周期、事务、配置、和其他的服务。</p>
<p>4、JNDI：（java Naming &amp; Directory interface）java命名目录服务。主要提供的功能是：提供一个目录系统，让其他各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</p>
<p>5、JMS（java Message Service）java消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</p>
<p>6、JTA（java Transaction API） java事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</p>
<p>7、JAF：（java Action FrameWork）java安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</p>
<p>8、RMI/IIOP：（Remote Method Invocation/internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。</p>
<p><strong>23、异常的种类</strong></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt="img"></p>
<p>1、粉红色的是受检查的异常（checked exceptions），其必须被try{}catch语句块所捕获，或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕获处理，命名为Checked Exception是因为java编译器要进行检查，以确保这个规则得到遵守。</p>
<p>2、绿色的异常是运行时异常（runtime exceptions），需要程序员自己分析代码决定是否捕获和处理，比如空指针，被0除…</p>
<p>3、声明为Error的，属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。</p>
<p><strong>24、equals和==的比较</strong></p>
<p>== 比较的是<strong>地址和值</strong>。</p>
<p>equals比较的是值。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190701/300975041_1561974792932_428A93CE2102F1DFD863C72B9733057F" alt="img"></p>
<p>s1==s2，比较的是地址和值，由上图得知两个引用指向的是同一个地址，<strong>所以返回true</strong></p>
<p>s3==s4，比较的是两个new出来开辟的空间对象地址，所以值相同，但地址不同，<strong>返回false</strong></p>
<p>s1.equals(s3)，比较的是内容，<strong>返回true</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;uml&quot;</span>;	</span><br><span class="line">String s2=<span class="string">&quot;uml&quot;</span>;</span><br><span class="line">String s3=<span class="keyword">new</span> String(<span class="string">&quot;uml&quot;</span>);</span><br><span class="line">String s4=<span class="keyword">new</span> String(<span class="string">&quot;uml&quot;</span>);</span><br><span class="line">System.out.println(s1==s2);	<span class="comment">//true</span></span><br><span class="line">System.out.println(s3==s4);	<span class="comment">//false</span></span><br><span class="line">System.out.println(s1.equals(s2));	<span class="comment">//true</span></span><br><span class="line">System.out.println(s3.equals(s4));	<span class="comment">//true</span></span><br><span class="line">System.out.println(s1.equals(s3));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>25、volatile</strong></p>
<p>1、java的内存模型</p>
<p>java内存模型规定了所有的变量都存储在主内存中，但是每个线程会有自己的工作内存，线程的工作内存保存了该线程中使用了的变量（从主内存中拷贝的），线程对变量的操作都必须在工作内存中进行，不同线程之间无法直接访问对方工作内存中的变量，线程间变量值从传递都要经过主内存完成</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180827/9780880_1535335958506_5721C0ED3C89479FA5F09D1F8E722D00" alt="图片说明"></p>
<p>2、什么是原子性</p>
<p>一个操作是不可中断的，要么全部执行成功要么全部执行失败，比如银行转账</p>
<p>3、什么是可见性</p>
<p>当多个线程访问同一变量时，一个线程修改了这个变量的值，其他线程就能够立即看到修改的值</p>
<p>4、什么是有序性</p>
<p>程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;	<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这两句代码1会比2先执行，但是JVM在真正执行时不一定是1在2之前，这里涉及一个概念叫做指令重排，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。比如上面的代码语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>在指令重排时会考虑指令之间的数据依赖性，比如2依赖了1的数值，那么处理器会保证1在1之前执行。</p>
<p>但是在多线程的情况下，指令重排就会有影响了。</p>
<p>5、volatile到底做了什么</p>
<ul>
<li>禁止了指令重排</li>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这个新值对其他线程是立即可见的。</li>
<li>不保证原子性（线程不安全）</li>
</ul>
<p><strong>26、final finally finalize</strong></p>
<p>1、final</p>
<p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既声明为abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在new一个对象时初始化（即只能在声明变量或构造器或代码块内初始化），而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能覆盖（重写）。</p>
<p>2、finally</p>
<p>在异常处理时提供finally块来执行清除操作，如果抛出一个异常，那么相匹配的catch子句就会执行，然后控制就会进入finally块。</p>
<p>3、finalize</p>
<p>方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</p>
<p><strong>27、内存泄漏</strong></p>
<p>内存泄漏（Memory Leak）是指一个不再被使用的对象或者变量还在内存中占有存储空间。在C/C++语言中，内存泄漏出现在开发人员忘记释放已分配的内存就会造成内存泄漏。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄漏的问题。</p>
<p>内存泄漏主要有两种情况：1.在堆中申请的空间没有释放。2.对象已不再被使用，但是仍然在内存中保留着。GC机制的引入只能解决第一种情况，对于第2中情况无法保证不再使用的对象会被释放。Java语言中的内存泄漏主要指第2种情况。</p>
<p>内存泄漏的原因：1. 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄漏。2.各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄漏。3. 释放对象往往没有相应的删除，可能会导致内存泄漏。</p>
<p>内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。内存泄漏（Memory Leak）最终会导致内存溢出。</p>
<p><strong>28、标识符</strong></p>
<p>1、标识符由26个英文字符大小写（a<del>z,A</del>Z）、数字（0~9）、下划线(_)和美元符号($)组成；</p>
<p>2、不能以数字开头，不能是关键字；</p>
<p>3、严格区分大小写；</p>
<p>4、标识符可以为任意长度；</p>
<p><strong>29、接口和抽象类的区别</strong></p>
<p>1、接口的方法默认为public abstract，接口中的变量默认为public static final，在java8之前所有的方法不能有实现抽象类中可以有非抽象方法；</p>
<p>2、一个类可以实现多个接口，但只能继承一个抽象类</p>
<p>3、一个类实现接口，要实现该接口的所有抽象方法。</p>
<p>4、接口不能被实例化，但可以声明，但是必须引用一个实现该接口的对象。抽象类可以有构造方法，但是不能被直接通过new进行实例化。但可以通过子类继承，实例化子类的时候抽象类也会被实例化。这其实用到了多态，向上转型。父类引用指向子类对象。</p>
<p>5、从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>30、Integer对象的方法</strong></p>
<p>Integer.parseInt(“”)是将字符串类型转换为int的基础数据类型</p>
<p>Integer.valueOf(“”)是将字符串类型数据转换为Integer对象</p>
<p>Integer.intValue()；是将Integer对象中的数据取出，返回一个基础数据类型int</p>
<p><strong>31、Servlet的几个对象</strong></p>
<p>ServletContext对象：servlet容器在启动时会加载web应用，并为每个web应用创建唯一的servlet context对象，可以把ServletContext看成是一个web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContect对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问。</p>
<p>整个web应用只有唯一的一个ServletContext对象</p>
<p>ServletConfig对象：用于封装servlet的配置信息。从一个servlet被实例化后，对任何客户端在任何时候访问有效，但仅对servlet自身有效，一个servlet的ServletConfig对象不能被另一个servlet访问。</p>
<p><strong>32、IO流的分类</strong></p>
<p>按照流的流向分，可以分为输入流和输出流：</p>
<ul>
<li>输入流：只能从中读取数据，而不能向其写入数据。</li>
<li>输出流：只能向其写入数据，而不能向其读取数据。</li>
</ul>
<p>此处的输入，输出涉及一个方向的问题，数据从内存到硬盘，通常称为输出流—-也就是说，这里的输入，输出都是从程序运行所在的内存的角度来划分的。</p>
<blockquote>
<p>注：如果从硬盘的角度来考虑，上述应该是输入流才对；但划分输入/输出流时是从程序运行所在的内存角度来考虑的，因此上述为输出流而不是输入流。</p>
</blockquote>
<p><img src="https://uploadfiles.nowcoder.com/files/20170906/3766702_1504658512297_20160505173519730" alt="这是图片描述"></p>
<p>对于如图15.2所示的数据流向，数据从服务器通过网络流向客户端，在这种情况下，server端的内存负责将数据输出到网络里，因此server端的程序使用输出流；client端的内存负责从网络中读取数据，因此client端的程序应该使用输入流。</p>
<blockquote>
<p>注：java的输入流主要是InputStream和Reader作为基类，而输出流则是主要由outputStream和Writer作为基类。它们都是一些抽象基类，无法直接创建实例。</p>
</blockquote>
<p><strong>节点流：</strong>FileInputStream、FileOutputStream、FileReader、FileWriter、StringReader、StringWriter、ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、PipedInputStream、PipedOutputStream、PipedReaderPipedWriter</p>
<p><strong>处理流：</strong>BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、InputStreamReader、OutputStreamReader、DataInputStream、DataOutputStream、PrintWriter</p>
<p>节点流的前缀都是名词，如File、String、char等；处理流的前缀都是动词，如input、print、bufferd等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/12/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8gpu%E8%B7%91%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/12/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8gpu%E8%B7%91%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">记第一次用gpu跑程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-12 15:35:31 / 修改时间：16:03:35" itemprop="dateCreated datePublished" datetime="2021-01-12T15:35:31+08:00">2021-01-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、首先cmd执行<code>nvidia-smi</code>命令查看一下显卡配置。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20210112153848320.png" alt="image-20210112153848320"></p>
<p>可以看到服务器是有GPU并有一些后台应用使用了GPU资源。确定有GPU之后下一步就是想办法如何让自己的python程序跑在指定的GPU上。</p>
<p>2、keras使用CPU和GPU运算没有任何的语法差别，它能自动地判断能不能使用GPU运算，能的话就用GPU，不能则CPU（所以之前没配置GPU之前都是跑在CPU上）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>]=<span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p>在python程序头部敲上以上命令即可在GPU配置好的情况下使用0号GPU跑程序。</p>
<p>3、如何配置GPU呢？主要需要四个部分。</p>
<ul>
<li><code>tensorflow-gpu</code>（运行<code>pip install tensorflow-gpu==1.14.0</code>）</li>
<li>适合版本的NVDIA驱动（师傅已经安装好）</li>
<li>CUDA(待安装)</li>
<li>cuDNN（待安装）</li>
</ul>
<p>服务器上的环境配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensorflow-gpu: 1.14.0</span><br><span class="line">keras: 2.2.4</span><br><span class="line">nvidia driver: 451.67 (驱动显卡工作的程序)</span><br><span class="line">CUDA: 10.0 (英伟达开发的用于GPU运算的框架)</span><br><span class="line">cuDNN: 7.6.4 (专用于深度神经网络的库)</span><br></pre></td></tr></table></figure>

<p><strong>踩的坑：</strong></p>
<p>一开始下载<code>CUDA v11.0</code>和8.0.4的<code>cuDNN</code>。在执行train.py程序时报错<code>ImportError: Could not find cudart64_100.dll</code>。报错信息为<code>CUDA</code>与<code>tensorflow-gpu</code>的版本不匹配，所以这里将<code>CUDA</code>进行降级，重新下10.0的<code>CUDA</code>。</p>
<p>卸载过程主要就是将<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</code>中v11.0的文件夹进行删除并删除CUDA的两个环境变量。</p>
<p><code>cuDNN</code>也进行降级与<code>CUDA</code>的版本进行适配。</p>
<p>下载完成之后，将<code>cuDNN</code>中的bin、include、lib文件夹中文件拷贝到<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0</code>中对应的文件夹即可。</p>
<p>4、测试python程序</p>
<p>在train.py中引入上述的两行程序点击RUN。之后就可以看到飞快的训练速度了~</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20210112160308759.png" alt="image-20210112160308759"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/11/Pilot%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/Pilot%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">Pilot架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-11 15:18:24 / 修改时间：16:49:08" itemprop="dateCreated datePublished" datetime="2021-01-11T15:18:24+08:00">2021-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="司令官Pilot"><a href="#司令官Pilot" class="headerlink" title="司令官Pilot"></a>司令官Pilot</h1><h2 id="Pilot的架构"><a href="#Pilot的架构" class="headerlink" title="Pilot的架构"></a>Pilot的架构</h2><ul>
<li>平台适配器</li>
<li>抽象聚合层</li>
<li>xDS API</li>
</ul>
<p>在Pilot与Envoy代理之间维护着一条gRPC长连接，所有配置的分发都基于此连接的一个Stream。配置的下发采用异步方式，主要基于底层注册中心服务的变化或者配置规则的更新事件。</p>
<h3 id="Istio的服务模型"><a href="#Istio的服务模型" class="headerlink" title="Istio的服务模型"></a>Istio的服务模型</h3><p>Istio通用的服务模型包含Service（服务）和ServiceInstance(服务实例)。每个服务都有一个或多个实例，服务实例是服务的实际表现形式，类似于Kubernetes中service与endpoint的概念。</p>
<h3 id="xDS协议"><a href="#xDS协议" class="headerlink" title="xDS协议"></a>xDS协议</h3><p>xDS是一类发现服务的总称，包含LDS、RDS、CDS、EDS及SDS。</p>
<h2 id="Pilot的工作流程"><a href="#Pilot的工作流程" class="headerlink" title="Pilot的工作流程"></a>Pilot的工作流程</h2><p>Pilot主要职责是获取注册中心的配置规则或者服务。Pilot主要包含服务发现、配置规则发现及服务器三大模块。</p>
<h3 id="Pilot的启动与初始化"><a href="#Pilot的启动与初始化" class="headerlink" title="Pilot的启动与初始化"></a>Pilot的启动与初始化</h3><p>Pilot通过Pilot-discovery进程启动的，主要包括配置控制器、服务控制器、xDS服务器、HTTP服务器和性能监视器等模块。</p>
<p>1）xDS服务器用于处理Envoy代理的xDS请求，以及控制相关配置的生成及下发。</p>
<p>2） 配置控制器主要用于监视底层注册中心及更新配置规则，并通知xDS服务器异步更新xDS配置。</p>
<p>3） 服务控制器主要用于监视底层注册中心、更新服务及服务实例，并通知xDS服务器异步更新xDS配置。</p>
<p>4） HTTP服务器主要提供REST接口供管理员获取Debug信息；</p>
<p>5） 性能监视器主要提供性能分析的接口，可通过此接口获取进程运行时内存、CPU占用等。</p>
<p>Pilot的启动流程如下：</p>
<p>1、命令行参数解析，解析所需的配置文件、服务器地址等日志系统配置；</p>
<p>2、初始化Kubernetes客户端。在Kubernetes集群中，底层服务发现需要监视Kube-apiserver，所以这里需要创建Kubernetes客户端；</p>
<p>3、加载服务网格配置，主要是网络中所有的Envoy实例共享的一些全局配置，包括Mixer服务器地址、连接管理相关的设置及访问日志格式等；</p>
<p>4、加载服务网格网络配置，支持同一网络多网格之间的服务直接访问，例如Kubernetes多集群的场景；</p>
<p>5、初始化Config Controller(配置控制器)、Pilot核心模块，监视底层注册中心的配置规则，并异步通知xDS服务器；</p>
<p>6、初始化Service Controller（服务控制器）、Pilot核心模块，监视底层注册中心服务及服务实例，并异步通知xDS服务器；</p>
<p>7、初始化Pilot服务器，主要涉及xDS Server、HTTP服务器，处理所有xDS连接，生成xDS配置并下发；</p>
<p>8、初始化多集群服务发现，适用于多个Kubernetes集群共用同一套控制面的场景；</p>
<p>9、启动所有Pilot Server及控制器，开始监听底层平台及处理下游xDS请求。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>异步通知的实现依赖于回调函数，当有更新事件产生时，系统在捕获到事件的同时执行回调函数。如果事件回调函数的执行周期较长且事件更新频率较高，则为了保证事件接收不会阻塞，一般会先进行上半部处理，将事件发送到队列，然后通过下半部处理。</p>
<p>EnvoyXdsServer在初始化时会通过AppendServiceHandler及AppendInstanceHandler分别向Aggregator注册服务、服务实例的更新事件处理回调函数。Aggregator实际上是分别调用各Adapter的回调注册接口，然后将回调函数注册到各个Adapter上。</p>
<p>各平台的Adapter基于底层注册中心提供的资源监视方式来监控资源的变化。</p>
<h3 id="配置规则发现"><a href="#配置规则发现" class="headerlink" title="配置规则发现"></a>配置规则发现</h3><p><strong>Kubernetes适配器</strong></p>
<h3 id="Envoy的配置分发"><a href="#Envoy的配置分发" class="headerlink" title="Envoy的配置分发"></a>Envoy的配置分发</h3><p>从Pilot的角度来看，存在两种配置分发模式：主动模式和被动模式。主动模式指Pilot主动将配置下发到Sidecar，由config与服务更新事件触发。被动模式指由Pilot接收Sidecar的连接请求（DiscoveryRequest），然后做出响应（DiscoveryResponse）。主动模式是由底层注册中心的资源更新触发的，被动模式是由外部客户端的Envoy请求触发的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/07/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-07 14:07:56" itemprop="dateCreated datePublished" datetime="2021-01-07T14:07:56+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-11 19:22:21" itemprop="dateModified" datetime="2021-01-11T19:22:21+08:00">2021-01-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并查集的理解与实现"><a href="#并查集的理解与实现" class="headerlink" title="并查集的理解与实现"></a>并查集的理解与实现</h1><h2 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h2><p>并查集就是对集合三种常用操作的再一次抽象。分别是集合的合并（Union）、元素的搜索（Find）和对集合的分解。因为3种操作非常常用并且又不囿于集合，所以就把这一操作抽象成一个独立的数据结构。</p>
<p><strong>标准定义：</strong></p>
<p>在一些应用问题中，需要将n个不同的元素划分成一组不相交的集合。开始时每个元素自成一个单元素集合，然后按照一定规律将归于同一组元素的集合合并，在此过程需要反复查询某个元素归属于哪个集合的运算，适合于描述着类问题的抽象数据类型称为并查集（union-find set）</p>
<h2 id="并查集的3种操作"><a href="#并查集的3种操作" class="headerlink" title="并查集的3种操作"></a>并查集的3种操作</h2><p>并查集的三种操作是：</p>
<blockquote>
<p>(1)Union(Root1,Root2):把子集合Root2并入集合Root1中。要求这两个集合互不相交，否则不执行合并。</p>
<p>(2)Find(x):搜索单元素x所在的集合，并返回该集合的名字。</p>
<p>(3)UnionFindSets(s):构造函数，将并查集中s个元素初始化为s个只有一个单元素的子集合。</p>
</blockquote>
<h2 id="并查集的实现方案"><a href="#并查集的实现方案" class="headerlink" title="并查集的实现方案"></a>并查集的实现方案</h2><p>实现并查集的方式有多种，这里主要总结用<strong>树结构</strong>来实现并查集纪其相关操作。</p>
<p>用这种实现方式，每个集合用一棵树表示，树的每一个节点代表集合的一个单元素。所有各个集合的全集合构成一个森林，并用树与森林的父指针表示法来实现。其下标代表元素名。第一个数组元素代表包含集合元素I的树节点。树的根节点的下标代表集合名，根节点的父为-1，表示集合中元素个数。</p>
<p>下面看一个例子：<br>全集合是S = {0，1，2，3，4，5，6，7，8，9}，初始化每个元素自成为一个单元素子集合</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI1MTYzNDE0NDA4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>经过一段时间的计算，这些子集合并成3个集合，他们是全集合S的子集合：S1 = {0，6，7，8}，S2= {1，4，9}，S3 = {2，3，5}。则表示他们并查集的树形结构如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI1MTY0MjU5NzI1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>上面数组中的元素值有两种含义：<br>（1）负数表示当前节点是树的根节点，负数的绝对值表示树中节点的个数，也即集合中元素的个数。<br>（2）正数表示其所属的树的根节点，由树形表示很容易理解，这也是树的父指针表示的定义。<br>经过上面对相关数据的组织，再回头来看并查集的3中核心操作是怎样依托于树来实现的：</p>
<p>（1）将root2并入到root1中，其实就可以直接把root2的数组元素（就是他的父节点）改成root1的名字（就是他所在的数组下标）。<br>下面的图表示了合并两个子集合的过程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI1MTcwNzQzNDU4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>（2）查找x所属于的根节点（或者说是x所属于的集合），就可以一直找array[x]，直到array[x]小于0，则证明找到了根（所在集合）。<br>下面的图示意了查找一个节点所属集合的过程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI1MTcyMDAwOTU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>（3）将整个集合初始化为单元素集合，其实就是建立树的父指针数组的过程，把数组元素全初始化为-1，也就表示了每个元素都各占一个集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*树结构构建并查集，其中树用父指针形式表示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DefaultSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UFSets</span> &#123;</span>										<span class="comment">//集合中的各个子集合互不相交</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	UFSets(<span class="keyword">int</span> sz = DefaultSize);					<span class="comment">//构造函数       (并查集的基本操作)</span></span><br><span class="line">	~UFSets() &#123; <span class="keyword">delete</span>[] parent; &#125;					<span class="comment">//析构函数</span></span><br><span class="line">	UFSets&amp; <span class="keyword">operator</span> = (UFSets&amp; R);					<span class="comment">//重载函数：集合赋值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>;				<span class="comment">//两个子集合合并 (并查集的基本操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>;								<span class="comment">//搜寻x所在集合	 (并查集的基本操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">WeightedUnion</span><span class="params">(<span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>;		<span class="comment">//加权的合并算法 </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *parent;		<span class="comment">//集合元素数组(父指针数组)</span></span><br><span class="line">	<span class="keyword">int</span> size;			<span class="comment">//集合元素的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UFSets::UFSets(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">	<span class="comment">//构造函数，sz是集合元素的个数,父指针数组的范围0到sz-1</span></span><br><span class="line">	size = sz;										<span class="comment">//集合元素的个数</span></span><br><span class="line">	parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];							<span class="comment">//开辟父指针数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;				<span class="comment">//初始化父指针数组</span></span><br><span class="line">		parent[i] = <span class="number">-1</span>;								<span class="comment">//每个自成单元素集合</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UFSets::Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//函数搜索并返回包含元素x的树的根</span></span><br><span class="line">	<span class="keyword">while</span> (parent[x] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		x = parent[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFSets::Union</span><span class="params">(<span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//函数求两个不相交集合的并，要求Root1与Root2是不同的，且表示了子集合的名字</span></span><br><span class="line">	parent[Root1] += parent[Root2];					<span class="comment">//更新Root1的元素个数</span></span><br><span class="line">	parent[Root2] = Root1;							<span class="comment">//令Root1作为Root2的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UFSets::WeightedUnion</span><span class="params">(<span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//使用节点个数探查方法求两个UFSets集合的并</span></span><br><span class="line">	<span class="keyword">int</span> r1 = Find(Root1);							<span class="comment">//找到root1集合的根</span></span><br><span class="line">	<span class="keyword">int</span> r2 = Find(Root2);							<span class="comment">//找到root2集合的根</span></span><br><span class="line">	<span class="keyword">if</span> (r1 != r2) &#123;									<span class="comment">//两个集合不属于同一树</span></span><br><span class="line">		<span class="keyword">int</span> temp = parent[r1] + parent[r2];			<span class="comment">//计算总节点数</span></span><br><span class="line">		<span class="keyword">if</span> (parent[r2] &lt; parent[r1]) &#123;				<span class="comment">//注意比较的是负数，越小元素越多,此处是r2元素多</span></span><br><span class="line">			parent[r1] = r2;						<span class="comment">//r1作为r2的孩子 </span></span><br><span class="line">			parent[r2] = temp;						<span class="comment">//更新r2的节点个数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			parent[r2] = r1;						<span class="comment">//...</span></span><br><span class="line">			parent[r1] = temp;						<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>java实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 以i为根节点的子树的高度（引入了路径压缩以后该定义并不准确）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.rank=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent[i]=i;</span><br><span class="line">            <span class="keyword">this</span>.rank[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX=find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY=find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX==rootY)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] == rank[rootY])&#123;</span><br><span class="line">            parent[rootX]=rootY;</span><br><span class="line">            <span class="comment">//此时以rootY为根节点的树的高度仅加了1</span></span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY])&#123;</span><br><span class="line">            parent[rootX]=rootY;</span><br><span class="line">            <span class="comment">//此时以rootY为根节点的树的高度不变</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同理，此时以rootX为根节点的树的高度不变</span></span><br><span class="line">            parent[rootY]=rootX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x!=parent[x])&#123;</span><br><span class="line">            parent[x]=find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
