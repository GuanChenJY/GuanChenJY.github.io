<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">操作系统总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 16:00:26" itemprop="dateCreated datePublished" datetime="2021-02-24T16:00:26+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 09:23:41" itemprop="dateModified" datetime="2021-03-25T09:23:41+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、总体概念"><a href="#1、总体概念" class="headerlink" title="1、总体概念"></a>1、总体概念</h2><h2 id="1-1-操作系统的特性"><a href="#1-1-操作系统的特性" class="headerlink" title="1.1 操作系统的特性"></a>1.1 操作系统的特性</h2><p>四个特性：并发、共享、虚拟、异步。</p>
<ul>
<li>同一段时间内(时间片轮转算法)多个程序执行。</li>
<li>系统中的资源可以被内存中多个并发执行的进线程共同使用。</li>
<li>虚拟：通过时分复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个。</li>
<li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。（同步就是实时处理，比如打电话，异步就是分时处理，比如发短信）</li>
</ul>
<h2 id="1-2-操作系统的主要功能有哪些"><a href="#1-2-操作系统的主要功能有哪些" class="headerlink" title="1.2 操作系统的主要功能有哪些"></a>1.2 操作系统的主要功能有哪些</h2><p>操作系统的本质是对<strong>资源的管理</strong>，包括了：</p>
<ul>
<li><strong>处理器管理</strong>：以进程为单位分配资源</li>
<li><strong>存储器管理</strong>：也叫内存管理</li>
<li><strong>设备管理</strong>：完成所有的IO请求</li>
<li><strong>文件管理</strong>：包括磁盘存储空间管理，文件读写管理等等</li>
</ul>
<h2 id="1-3-什么是用户态和和心态"><a href="#1-3-什么是用户态和和心态" class="headerlink" title="1.3 什么是用户态和和心态"></a>1.3 什么是用户态和和心态</h2><p>从整体上讲，操作系统一般可分为<strong>内核（kernel）</strong>和<strong>外壳（shell）</strong>两大部分。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218111032.png" alt="img"></p>
<p>当程序运行在3级特权级上时，就可以称之为运行在<strong>用户态</strong>。反之则是<strong>内核态</strong>。0级特权直接控制硬件，12级特权是系统程序，包括驱动等等，3级特权是用户程序。</p>
<p>用户态切换到内核态有三种情况：</p>
<ul>
<li>系统调用：用户进程主动要求切换到内核态的一种方式。</li>
<li>异常：当前运行进程切换到处理此异常的内核相关程序中。</li>
<li>外围设备终端：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，下一条即将要执行的指令转而去执行与中断信号对应的处理程序。如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。</li>
</ul>
<h1 id="2、进程与线程"><a href="#2、进程与线程" class="headerlink" title="2、进程与线程"></a>2、进程与线程</h1><h2 id="2-1-进程线程协程区别"><a href="#2-1-进程线程协程区别" class="headerlink" title="2.1 进程线程协程区别"></a>2.1 进程线程协程区别</h2><p>对于操作系统来说，<strong>一个任务就是一个进程(Process)**，比如使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种</strong>进程内的多个子任务就是线程**（Thread）。</p>
<p>进程是进程实体的一次运行，是系统进行资源分配和调度的一个独立单位。由PCB、程序段和数据段组成。</p>
<p>PCB：保存进程运行期间相关的数据，是进程存在的唯一标志。程序段：能被进程调度程序调度到CPU运行的程序的代码段。数据段：存储程序运行期间的相关数据，可以是原始数据也可以是相关结果。</p>
<p>具体来说：</p>
<ul>
<li>进程是操作系统分配资源的单位，而<strong>线程是进程的一个实体</strong>，是CPU调度和分派的基本单位。</li>
<li>线程没有独立的内存单元，不能够独立执行，必须依存在应用程序中。</li>
</ul>
<p><strong>孤儿进程、僵尸进程、守护进程：</strong></p>
<p><strong>孤儿进程</strong>：如果<strong>父进程先退出,子进程还没退出</strong>那么子进程将被托孤给init进程,这时子进程的父进程就是init进程(1号进程).其实还是很好理解的</p>
<p> <strong>僵尸进程</strong>：如果我们了解过<code>linux</code>进程状态及转换关系,我们应该知道进程这么多状态中有一种状态是僵死状态,就是进程终止后进入僵死状态(zombie),等待告知父进程自己终止后才能完全消失.但是如果<strong>一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程</strong>.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.</p>
<p>  <strong>守护进程</strong>：同样我们需要了解一下什么是守护进程,<strong>守护进程就是在后台运行,不与任何终端关联的进程</strong>,通常情况下守护进程在系统启动时就在运行,它们以root用户或者其他特殊用户(apache和postfix)运行,并能处理一些系统级的任务.习惯上守护进程的名字通常以d结尾(sshd),但这些不是必须的.</p>
<p><strong>引入线程的好处：</strong>线程快！创建、终止、切换都很快！</p>
<p><strong>总结：</strong></p>
<ol>
<li>一个程序至少有一个进程,一个进程至少有一个线程。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li>
<li>虽然线程拥有单独的程序运行入口，出口，但不能独立执行。</li>
</ol>
<p>协程与线程的区别：协程不再被内核调度，<strong>而是交给了程序自己</strong>，因此golang中专门引入了GMP模式，设立了专门的逻辑处理器。</p>
<p><strong>多线程和多任务：</strong></p>
<p>多线程指的是在一个程序中可以定义多个线程同时运行它们，每个线程可以执行不同的任务。</p>
<p>多线程与多任务区别：多任务是针对操作系统而言的，代表着操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表着一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。</p>
<h2 id="2-2-进程有哪些状态，转换条件是什么？"><a href="#2-2-进程有哪些状态，转换条件是什么？" class="headerlink" title="2.2 进程有哪些状态，转换条件是什么？"></a>2.2 进程有哪些状态，转换条件是什么？</h2><p><strong>就绪状态</strong>：进程获得了除CPU之外的一切所需资源</p>
<p><strong>运行状态</strong>：一个CPU的一个核只能有一个进程处于运行状态。</p>
<p><strong>阻塞状态</strong>，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218102010.png" alt="img"></p>
<p><strong>注意区别就绪状态和等待状态：</strong>就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件</p>
<p><strong>进程调度方式：</strong>非剥夺调度方式、剥夺调度方式。</p>
<p>典型的调度算法：先来先服务、短作业优先、优先级调度、高响应比优先调度、时间片轮转调度、多级反馈队列调度。</p>
<p>先来先服务调度和短作业优先调度无法保证及时的接收和处理问题，就无法保证在规定的时间间隔内，响应每个用户的需求。也同样无法达到实时操作系统的及时性需求。优先级调度算法按照任务的优先级进行调度，对于更紧急的任务给予更高的优先级，适合实时操作系统。高相应比，时间片轮转，多级反馈队列都能保证每个任务在一定时间内分配到时间片，并轮流占用CPU，适合分时操作系统。</p>
<h2 id="2-3-进程间通信"><a href="#2-3-进程间通信" class="headerlink" title="2.3 进程间通信"></a>2.3 进程间通信</h2><p>也就是所谓的IPC(Inter-process communication)问题，主要是指<strong>进程间交换数据的方式</strong>。</p>
<p>进程是相互独立的，并不需要条件变量、互斥锁这些机制，要锁也是文件锁这种大锁。而线程需要互斥锁的原因是：<strong>线程之间的资源室共享的，需要程序员来完成变量级别的同步。</strong></p>
<p>进程间通信分为<strong>低级通信和高级通信</strong></p>
<ul>
<li>低级通信：信号量</li>
<li>高级通信：<ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ul>
</li>
</ul>
<p><strong>信号量</strong>是一个计数器，防止多个进程将资源拿光，防止某进程正在访问共享资源时，其他进程也访问该资源。</p>
<p><strong>管道</strong>是指用于<strong>连接一个读进程和一个写进程的一个共享文件</strong>，又名pipe文件，以<strong>字符流形式</strong>将数据写入文件。管道分为<strong>无名管道</strong>和<strong>有名管道</strong>：</p>
<ul>
<li>无名管道是半双工的通信方式，数据只能单向流动，只能在父子进程中流通；</li>
<li>有名管道也是半双工，但是它允许无亲缘关系进程间通信。</li>
</ul>
<p><strong>消息队列</strong>指的是<strong>进程间的数据交换是以格式化的消息(Message)为单位的</strong>，再由消息组成的链表，形成队列。</p>
<p><strong>共享内存</strong>指在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。</p>
<h2 id="2-4-进程间同步"><a href="#2-4-进程间同步" class="headerlink" title="2.4 进程间同步"></a>2.4 进程间同步</h2><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对<strong>多个相关进程在执行顺序上进行协调</strong>。</p>
<p>同步手段有：</p>
<ul>
<li>临界区</li>
<li>互斥量</li>
<li>信号量</li>
<li>事件： 通过通知操作的方式来保持线程的同步</li>
</ul>
<p>其中：互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多。</p>
<p><strong>临界区：</strong>一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。</p>
<p><strong>同步：</strong>同步也称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p>
<p><strong>互斥：</strong>间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<p>例如，A进程和B进程需要打印机，如果A需要打印机时已将打印机分配给B，则A阻塞，反之B阻塞。</p>
<p>空闲让进、忙则等待、有限等待、让权等待。</p>
<h2 id="2-5-线程间同步"><a href="#2-5-线程间同步" class="headerlink" title="2.5 线程间同步"></a>2.5 线程间同步</h2><p>由于线程间的资源可以共享，同步的方式就会更加细致：</p>
<ul>
<li><strong>互斥量：</strong>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li><strong>信号量</strong>，只能用于一个资源的互斥访问，不能实现多个资源的多线程互斥问题。它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>读写锁</strong>，可以被多个读者拥有，但是只能被一个写者拥有的锁</li>
<li><strong>条件变量</strong>，线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒</li>
<li><strong>原子操作</strong></li>
<li><strong>通道</strong></li>
</ul>
<h2 id="2-6-什么是临界区，如何解决冲突"><a href="#2-6-什么是临界区，如何解决冲突" class="headerlink" title="2.6 什么是临界区，如何解决冲突"></a>2.6 什么是临界区，如何解决冲突</h2><p>每个进程中访问临界资源的那段程序称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p>
<p>解决冲突的办法：</p>
<ul>
<li>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>
<li>任何时候，<strong>处于临界区内的进程不可多于一个</strong>。如已有进程进入自己的临界区，则其他所有试图进入临界区的进程必须等待；</li>
<li>进入临界区的进程要在<strong>有限时间内退出</strong>。</li>
<li>如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</li>
</ul>
<h2 id="2-7-线程的分类"><a href="#2-7-线程的分类" class="headerlink" title="2.7 线程的分类"></a>2.7 线程的分类</h2><p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程</p>
<p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong></p>
<h2 id="2-8-线程池"><a href="#2-8-线程池" class="headerlink" title="2.8 线程池"></a>2.8 线程池</h2><p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，<strong>处理完之后线程并不会被销毁，而是等待下一个任务。</strong>由于创建和销毁线程都是消耗系统资源的，所以池化技术能提升性能。</p>
<p>go实现线程池如下。创建两个通道，通道queue中传入任务函数，通道result传入结果：</p>
<ul>
<li>创建结构</li>
<li>初始化</li>
<li>开门接客</li>
<li>关门送客</li>
<li>辅助函数:添加任务、回调</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">type pool struct&#123;</span><br><span class="line">    <span class="function">Queue chan <span class="title">func</span><span class="params">()</span> error</span></span><br><span class="line"><span class="function">    Number <span class="keyword">int</span> <span class="comment">//协程数</span></span></span><br><span class="line"><span class="function">    Total <span class="keyword">int</span> <span class="comment">//任务数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    result chan error</span></span><br><span class="line"><span class="function">    finishCallback <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(p *pool)</span> <span class="title">Init</span><span class="params">(number, total <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    p.Queue=make(<span class="function">chan <span class="title">func</span><span class="params">()</span> error,total)</span></span><br><span class="line"><span class="function">    p.Number</span>=number</span><br><span class="line">    p.Total=total</span><br><span class="line">    p.result=make(chan error,total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开门接客</span></span><br><span class="line">func (p *pool) Start()&#123;</span><br><span class="line">    <span class="comment">// 开启Number个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;p.Number;i++&#123;</span><br><span class="line">        <span class="function">go <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                task, ok := &lt;-p.Queue</span><br><span class="line">                <span class="keyword">if</span> !ok &#123; <span class="comment">//所有任务已经完成，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                err:=task() <span class="comment">//执行任务，每个协程阻塞在此</span></span><br><span class="line">                p.result&lt;-err </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得每个work的执行结果</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;p.Total;i++&#123;</span><br><span class="line">        res:=&lt;-p.result <span class="comment">//阻塞形式</span></span><br><span class="line">        <span class="keyword">if</span> res!=nil&#123;</span><br><span class="line">            fmt.Println(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main传入回调函数才可以执行</span></span><br><span class="line">    <span class="keyword">if</span> p.finishCallback!=nil&#123;</span><br><span class="line">        p.finishCallback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关门送客</span></span><br><span class="line">func (p *pool) Stop() &#123;</span><br><span class="line">       close(p.Queue)</span><br><span class="line">    close(p.result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加任务</span></span><br><span class="line">func (p *pool)addTask(<span class="function">task <span class="title">func</span><span class="params">()</span> error)</span>&#123;</span><br><span class="line">    p.Queue&lt;-task</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置结束回调</span></span><br><span class="line">func (p *pool) setFinishCallback(<span class="function">callback <span class="title">func</span><span class="params">()</span>)</span>&#123;</span><br><span class="line">    p.finishCallback=callback</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ool := <span class="keyword">new</span>(GoroutinePool)</span><br><span class="line">pool.Init(<span class="number">3</span>, <span class="number">10</span>) <span class="comment">//开启3个协程处理10个任务</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    pool.addTask(func() error&#123;</span><br><span class="line">        <span class="comment">//从taskName中获取任务要求</span></span><br><span class="line">        <span class="keyword">return</span> doTask(taskName[i])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFinish:=<span class="keyword">false</span></span><br><span class="line">pool.setFinishCallback(func()&#123;</span><br><span class="line">    func(isFinish *bool)&#123;</span><br><span class="line">        *isFinish=<span class="keyword">true</span></span><br><span class="line">    &#125;(&amp;isFinish)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pool.Start()</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> isFinished&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond*<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.Stop()</span><br><span class="line">fmt.Println(<span class="string">&quot;Finished!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-9-死锁"><a href="#2-9-死锁" class="headerlink" title="2.9 死锁"></a>2.9 死锁</h2><p><strong>死锁</strong>是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p>
<p>产生死锁的必要条件：互斥条件、不剥夺条件、请求和保持条件、循环等待条件。</p>
<p><strong>死锁的处理策略：</strong>预防死锁、避免死锁、死锁的检测和解除</p>
<p><strong>预防死锁：</strong></p>
<ul>
<li>破坏互斥条件：有些资源必须互斥使用、无法破坏互斥条件</li>
<li>破坏不剥夺条件：增加系统开销，降低吞吐量</li>
<li>破坏请求和保持条件：严重浪费系统资源，还可能导致饥饿现象</li>
<li>破坏循环等待条件：浪费系统资源，并造成编程不便</li>
</ul>
<p><strong>避免死锁：</strong></p>
<ul>
<li>安全状态：能找到一个分配资源的序列能让所有进程都顺利完成。</li>
<li>银行家算法：采用预分配策略检查分配完成时系统是否处于完全状态。</li>
</ul>
<h1 id="3、内存"><a href="#3、内存" class="headerlink" title="3、内存"></a>3、内存</h1><h2 id="3-1-逻辑地址、线性地址和物理地址的区别"><a href="#3-1-逻辑地址、线性地址和物理地址的区别" class="headerlink" title="3.1 逻辑地址、线性地址和物理地址的区别"></a>3.1 逻辑地址、线性地址和物理地址的区别</h2><p><strong>逻辑地址（Logic Address）</strong>是指<strong>由程序产生的与段相关的偏移地址部分</strong>，因此一个逻辑地址<strong>由段标识符和段内偏移量</strong>组成，有时也称<strong>虚拟地址</strong>。比如，在C程序中，<strong>可以使用&amp;操作读取指针变量本身的值，实际上这个值就是逻辑地址</strong>。逻辑地址和绝对的物理地址不相干。</p>
<p><strong>线性地址（Linear Address）</strong>是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或说是段中的偏移地址，<strong>加上相应段的基地址就生成了一个线性地址。</strong></p>
<p><strong>物理地址（Physical Address）</strong>是CPU外部地址总线上的地址，也是地址变换的最终地址。</p>
<h2 id="3-2-寻址方式有哪些"><a href="#3-2-寻址方式有哪些" class="headerlink" title="3.2 寻址方式有哪些"></a>3.2 寻址方式有哪些</h2><p>寻址寻的都是物理地址。分三组：立即寻址+寄存寻址；直接间接寻址；相对寻址+2个基变址寻址。</p>
<ul>
<li><p>立即寻址：操作数在指令中给出，作为指令的一部分。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,5</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>寄存器寻址</strong>：操作数在CPU内部的寄存器中，指令指定寄存器。<strong>不需要访问存储器</strong>，所以速度快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>直接寻址</strong>：<strong>操作数在寄存器中</strong>，指令直接包含有操作数的有效地址。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[8054]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>间接寻址</strong>：存储操作数的寄存器的地址另一个在寄存器中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[SI]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>相对寻址</strong>：操作数在存储器中，形式为<strong>基地址+偏移地址</strong>。假设数据段DS地址为5000，DI为3678，最终地址为5000+3678+1223。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[DI+1223H]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基变址绝对寻址</strong>：操作数在寄存器中，形式为<strong>基地址寄存器+变址寄存器</strong>。BX基地址+DI变址得到操作数存放的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX][DI]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基变址相对寻址</strong>：操作数在存储器中，形式为：<strong>基地址寄存器+变址寄存器+偏移地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX+DI-2]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-3-什么是虚拟内存？"><a href="#3-3-什么是虚拟内存？" class="headerlink" title="3.3 什么是虚拟内存？"></a>3.3 什么是虚拟内存？</h2><p>多任务会带来进程对内存的操作冲突，需要虚拟内存来解决。假设现在有一块物理内存，<strong>操作系统让两个进程共用这一块内存</strong>，彼此并不打扰。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200217135006.png" alt="img"></p>
<p><strong>虚拟内存的应用与优点</strong></p>
<p>虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页（Page），每个页都是一段连续的地址。这些页<strong>被映射到物理内存</strong>，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图所示。 注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p>由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。　　</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190723/220525776_1563877459292_F5CB0AD2C92C30DF24FC9C18034B313D" alt="img">　　　　　　</p>
<p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p>
<ul>
<li><strong>在内存中可以保留多个进程，系统并发度提高</strong></li>
<li><strong>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</strong></li>
</ul>
<h2 id="3-4-什么是交换空间"><a href="#3-4-什么是交换空间" class="headerlink" title="3.4 什么是交换空间"></a>3.4 什么是交换空间</h2><p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)**。当内存资源不足时，</strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间<strong>。硬盘上的那块空间叫做</strong>交换空间**(swap space),而这一过程被称为交换(swapping)。<strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</strong></p>
<p>用途：</p>
<ul>
<li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li>
<li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li>
</ul>
<h2 id="3-5-什么是分页？"><a href="#3-5-什么是分页？" class="headerlink" title="3.5 什么是分页？"></a>3.5 什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218105728.png" alt="img"></p>
<h2 id="3-6-什么是分段？"><a href="#3-6-什么是分段？" class="headerlink" title="3.6 什么是分段？"></a>3.6 什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218110201.png" alt="img"></p>
<h2 id="3-7-分页分段的区别是什么？"><a href="#3-7-分页分段的区别是什么？" class="headerlink" title="3.7 分页分段的区别是什么？"></a>3.7 分页分段的区别是什么？</h2><ul>
<li>属性：页是信息的物理单位，对用户不可见，段是逻辑单位，用户可见。</li>
<li>大小：分页固定，分段不固定</li>
<li>决定权：分页在于系统，分段在于用户</li>
<li>目的：分页有利于资源的利用，分段方便用户管理内存。</li>
</ul>
<h2 id="3-8-有哪些页面置换算法"><a href="#3-8-有哪些页面置换算法" class="headerlink" title="3.8 有哪些页面置换算法"></a>3.8 有哪些页面置换算法</h2><p><strong>缺页中断</strong>：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>有时候操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<ul>
<li>先进先出FIFO：总是选择在主存中停留时间最长（即最老）的一页置换</li>
<li>LRU：选择在最近一段时间里<strong>最久没有使用</strong>过的页面予以置换</li>
<li>LFU(least frequent)：统计页的使用频率，选择在<strong>最近时期使用最少的页面</strong>作为淘汰页</li>
</ul>
<h1 id="系统中断"><a href="#系统中断" class="headerlink" title="系统中断"></a>系统中断</h1><h2 id="4-1-中断的处理过程"><a href="#4-1-中断的处理过程" class="headerlink" title="4.1 中断的处理过程"></a>4.1 中断的处理过程</h2><ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li>
</ol>
<h2 id="4-2-中断和轮询有什么区别？"><a href="#4-2-中断和轮询有什么区别？" class="headerlink" title="4.2 中断和轮询有什么区别？"></a>4.2 中断和轮询有什么区别？</h2><p><strong>磁盘调度算法</strong></p>
<p>1、先来先服务</p>
<p>2、最短寻找时间优先</p>
<p>3、扫描算法（也称电梯算法）</p>
<p>4、循环扫描</p>
<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><h3 id="Linux创建进程的方式"><a href="#Linux创建进程的方式" class="headerlink" title="Linux创建进程的方式"></a>Linux创建进程的方式</h3><p>两种方式：一是由操作系统创建；二是由父进程创建进程（通常为子进程）。系统调用函数fork()是创建一个新进程的唯一方式，fork()函数是LInux系统中一个比较特殊的函数，其一次调用会有两个返回值。</p>
<p>fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。父进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> fpid;</span><br><span class="line"></span><br><span class="line">    fpid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process, pid %d/n&quot;</span>,getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process, pid %d/n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is child process, pid <span class="number">5574</span></span><br><span class="line"><span class="keyword">this</span> is parent process, pid <span class="number">5573</span></span><br></pre></td></tr></table></figure>

<p>在语句fpid=fork（）之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if (fpid&lt;0)……</p>
<p>为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值</p>
<p>1）在父进程中，fork返回新创建子进程的进程ID；<br>2）在子进程中，fork返回0；<br>3）如果出现错误，fork返回一个负值；</p>
<p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<p>fork出错可能有两种原因：</p>
<p>1、当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。</p>
<p>2、系统内存不足，这时errno的值被设置为ENOMEM。</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p>
<p>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">springboot拦截器理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 21:13:56" itemprop="dateCreated datePublished" datetime="2021-02-23T21:13:56+08:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 11:59:30" itemprop="dateModified" datetime="2021-02-24T11:59:30+08:00">2021-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="拦截器配置及登录拦截"><a href="#拦截器配置及登录拦截" class="headerlink" title="拦截器配置及登录拦截"></a>拦截器配置及登录拦截</h1><p><strong>拦截器（Interceptor）同</strong>Filter过滤器一样，它俩都是面向切面编程—-AOP的具体实现。</p>
<p>在Spring中，当请求发送到Controller时，在被Controller处理之前，它必须经过Interceptors（0或多个）</p>
<p>Spring Interceptor是一个非常类似于servlet Filter的概念。</p>
<p><strong>Interceptor作用：</strong></p>
<p>1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV等；</p>
<p>2、权限检查：如登录检测，进入处理器检测是否登录；</p>
<p>3、性能监控：通过拦截器在进入代理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间。（反向代理，如Apache也可以自动记录）</p>
<p>4、通用行为：读取Cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</p>
<p><strong>自定义Interceptor</strong></p>
<p>实现自定义拦截器只需要3步：</p>
<p>1、创建我们自己拦截器类并实现<code>HandleInterceptor</code>(<code>org.springframework.web.servlet.HandleInterceptor</code>)接口。</p>
<p>2、创建一个Java类继承WebMvcConfigurerAdapter，并重写addInterceptor方法。</p>
<p>3、实例化我们自定义的拦截器，然后将对象手动添加到拦截器链中。</p>
<p><img src="https://img2020.cnblogs.com/blog/1782418/202005/1782418-20200507104950016-1385031069.png" alt="img"></p>
<p>实际代码：</p>
<p>LoginInterceptor类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------- LogInterception.preHandle --- &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Request URL: &quot;</span> + request.getRequestURL()); </span><br><span class="line">        System.out.println(<span class="string">&quot;Start Time: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        </span><br><span class="line">        request.setAttribute(<span class="string">&quot;startTime&quot;</span>,startTime);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,Object handle ModelAndView modelAndview)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n---------LogInterception.postHandle-----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Request URL:&quot;</span>+request.getRequestURL());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------LogInterception.afterCompletion ----&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> startTime = (Long) request.getAttribute(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMills();</span><br><span class="line">        System.out.println(<span class="string">&quot;Request URL:&quot;</span>+request.getRequestURL());</span><br><span class="line">        System.out.println(<span class="string">&quot;End Time:&quot;</span>+endTime);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Time Taken:&quot;</span>+(endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OldLoginInterceptor</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldLoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandleInterceptorAdaptor</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------OldLoginInterceptor.preHandle----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Request URL:&quot;</span>+request.getRequestURL());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Sorry! This URL is no longer user, Redirect to /admin/login&quot;</span>);</span><br><span class="line">        response.sendRedirect(request.getContextPath()+<span class="string">&quot;/admin/login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handle ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------OldLoginInterceptor.postHandle-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,HttpServletResponse response,Object handler,Exception ex)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n-------OldLoginInterceptor.afterCompletion----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="title">implement</span> <span class="title">WebMvcConfiurer</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span></span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LogInterceptor());</span><br><span class="line">        </span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> OldLoginInterceptor()).addPathPatterns(<span class="string">&quot;/admin/oldLogin&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> AdminInterceptor()).addPathPatterns(<span class="string">&quot;/admin/*&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/oldLogin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LogInterceptor</code> 拦截器用于拦截所有请求； <code>OldLoginInterceptor</code> 用来拦截链接  <strong>“ / admin / oldLogin”</strong>，它将重定向到新的 <strong>“ / admin / login”。</strong>；<code>AdminInterceptor</code>用来拦截链接 <strong>“/admin/*”</strong>，除了链接  <strong>“ / admin / oldLogin”</strong>。</p>
<p>自定义Controller验证拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span> (value=<span class="string">&quot;/admin/login&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时依赖 <strong>thymeleaf 模板</strong>构建两个页面。</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot Mvc Interceptor example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #ccc;padding: 5px;margin-bottom:10px;&quot;</span>&gt;</span>            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/admin/oldLogin&#125;&quot;</span>&gt;</span>/admin/oldLogin (OLD URL)<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Spring Boot Mvc Interceptor<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue;&quot;</span>&gt;</span>Testing LogInterceptor<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span>See Log in Console..<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>login.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot Mvc Interceptor example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #ccc;padding: 5px;margin-bottom:10px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/admin/oldLogin&#125;&quot;</span>&gt;</span>/admin/oldLogin (OLD URL)<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Login Page<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span>Testing OldLoginInterceptor <span class="symbol">&amp;amp;</span> AdminInterceptor<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">See more info in the Console.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>运行程序并测试效果</strong></p>
<p>一切准备完毕，启动该项目。打开网址： <a target="_blank" rel="noopener" href="http://localhost:8080/index">http://localhost:8080/index</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f04dfbb399140e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>关于该请求在后台的执行过程，用图解的方式进行展示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f04e00a9e12728?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如果此时点击 <a target="_blank" rel="noopener" href="http://localhost:8080/admin/oldLogin">/admin/oldLogin (OLD URL)</a> 或者在网址栏输入：<a target="_blank" rel="noopener" href="http://localhost:8080/admin/oldLogin">http://localhost:8080/admin/oldLogin</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f04e09b8dc8399?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>控制台打印结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-------- LogInterception.preHandle --- Request URL: http://localhost:8080/admin/oldLogin</span><br><span class="line">Start Time: 1576329730709</span><br><span class="line"></span><br><span class="line">-------- OldLoginInterceptor.preHandle --- Request URL: http://localhost:8080/admin/oldLogin</span><br><span class="line">Sorry! This URL is no longer used, Redirect to /admin/login</span><br><span class="line"></span><br><span class="line">-------- LogInterception.afterCompletion --- Request URL: http://localhost:8080/admin/oldLogin</span><br><span class="line">End Time: 1576329730709Time Taken: 0</span><br><span class="line"></span><br><span class="line">-------- LogInterception.preHandle --- </span><br><span class="line">Request URL: http://localhost:8080/admin/login</span><br><span class="line">Start Time: 1576329730716</span><br><span class="line"></span><br><span class="line">-------- AdminInterceptor.preHandle </span><br><span class="line"></span><br><span class="line">-------- AdminInterceptor.postHandle</span><br><span class="line"></span><br><span class="line">-------- LogInterception.postHandle</span><br><span class="line">Request URL: http://localhost:8080/admin/login</span><br><span class="line"></span><br><span class="line">-------- AdminInterceptor.afterCompletion --- </span><br><span class="line"></span><br><span class="line">-------- LogInterception.afterCompletion --- </span><br><span class="line">Request URL: http://localhost:8080/admin/login</span><br><span class="line">End Time: 1576329730718Time Taken: 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样我们用图解的形式分析：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/14/16f04e0d3ff69909?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>应用</strong></p>
<p>性能监控</p>
<blockquote>
<p>如记录一下请求的处理时间，得到一些慢请求，从而进行性能改进，一般的反向代理服务器如apache都具有这个功能。</p>
</blockquote>
<p>登录检测</p>
<blockquote>
<p>在访问某些资源时，需要用户登录后才能查看，因此需要进行登录检测。</p>
</blockquote>
<p>流程：</p>
<p>1、访问需要登录的资源时，由拦截器重定向到登录页面；</p>
<p>2、如果访问的是登录页面，拦截器不应该拦截；</p>
<p>3、用户登录成功后，往cookie/session添加登陆成功的标识；</p>
<p>4、下次请求时，拦截器通过判断cookie/session中是否有该标识来决定继续流程还是到登录页面；</p>
<p>5、在此拦截器还应该允许游客访问的资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/Spring-AOP%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/Spring-AOP%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">Spring AOP理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 16:41:18" itemprop="dateCreated datePublished" datetime="2021-02-18T16:41:18+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:11:47" itemprop="dateModified" datetime="2021-02-23T21:11:47+08:00">2021-02-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、AOP概念"><a href="#1、AOP概念" class="headerlink" title="1、AOP概念"></a>1、AOP概念</h2><p>面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来。</p>
<ul>
<li>主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等等。</li>
<li>主要意图：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</li>
</ul>
<h2 id="2、AOP特点"><a href="#2、AOP特点" class="headerlink" title="2、AOP特点"></a>2、AOP特点</h2><blockquote>
<p>采用横向抽取机制，取代了传统纵向继承体系重复性代码</p>
</blockquote>
<h2 id="3、AOP底层实现"><a href="#3、AOP底层实现" class="headerlink" title="3、AOP底层实现"></a>3、AOP底层实现</h2><p>AOP底层使用动态代理实现。包括两种方式：</p>
<ul>
<li>使用JDK动态代理实现</li>
<li>使用cglib来实现</li>
</ul>
<p><strong>JDK动态代理实现：</strong></p>
<p> 只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。步骤如下：</p>
<ol>
<li>定义一个实现接口<code>InvocationHandler</code>的类</li>
<li>通过构造函数，注入被代理类</li>
<li>实现<code>invoke（ Object proxy, Method method, Object[] args）</code>方法</li>
<li>在主函数中获得被代理类的类加载器</li>
<li>使用<code>Proxy.newProxyInstance( )</code>产生一个代理对象</li>
<li>通过代理对象调用各种方法</li>
</ol>
<p><strong>cglib动态代理实现：</strong></p>
<p>针对类实现代理，对是否实现接口无要求。原理是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法最好不要声明为final类型。</p>
<ul>
<li>定义一个实现了<code>MethodInterceptor</code>接口的类</li>
<li>实现其<code>intercept（）</code>方法，在其中调用<code>proxy.invokeSuper( )</code></li>
</ul>
<p><strong>代理方式的选择</strong></p>
<ol>
<li>如果目标对象实现了接口，默认情况下回采用JDK的动态代理实现AOP，也可以强制使用cglib实现AOP</li>
<li>如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换</li>
</ol>
<p><strong>静态代理和动态代理的区别：</strong></p>
<ul>
<li>静态代理：自己编写创建代理类，然后再进行编译，在程序运行前，代理类的.class文件就已经存在了。</li>
<li>动态代理：在实现阶段不用关心代理谁，而在运行阶段（通过反射机制）才指定代理哪一个对象。</li>
</ul>
<h2 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h2><p><img src="https://img-blog.csdn.net/20170716175506888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20170716175528540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="5、AOP操作术语"><a href="#5、AOP操作术语" class="headerlink" title="5、AOP操作术语"></a>5、AOP操作术语</h2><ul>
<li><strong>Joinpoint(连接点)</strong>: 类里面可以被增强的方法，这些方法称为连接点</li>
<li><strong>Pointcut(切入点)</strong>:所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li><strong>Advice(通知/增强)</strong>:所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</li>
<li><strong>Aspect(切面)</strong>: 是切入点和通知（引介）的结合</li>
<li><strong>Introduction(引介)</strong>:引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.</li>
<li><strong>Target(目标对象)</strong>:代理的目标对象(要增强的类)</li>
<li><strong>Weaving(织入)</strong>:是把增强应用到目标的过程，把advice 应用到 target的过程</li>
<li><strong>Proxy（代理）</strong>:一个类被AOP织入增强后，就产生一个结果代理类  </li>
</ul>
<p>其实我们只需要这么记忆即可：</p>
<ul>
<li><p><strong><em>\</em>切入点：**</strong>在类里边可以有很多方法被增强，比如实际操作中，只是增强了个别方法，则定义实际被增强的某个方法为切入点。</p>
</li>
<li><p><strong>通知/增强：</strong></p>
<p>增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强。包括：</p>
<ul>
<li><strong>前置通知</strong>：在方法之前执行</li>
<li><strong>后置通知</strong>：在方法之后执行</li>
<li><strong>异常通知</strong>：方法出现异常执行</li>
<li><strong>最终通知</strong>：在后置之后执行</li>
<li><strong>环绕通知</strong>：在方法之前和之后执行</li>
</ul>
</li>
<li><p><strong><em>切面：*</em></strong>把增强应用到具体方法上面的过程称为切面。</p>
</li>
</ul>
<h2 id="6、AOP操作案例"><a href="#6、AOP操作案例" class="headerlink" title="6、AOP操作案例"></a>6、AOP操作案例</h2><p><strong>导入和AOP相关的jar包</strong></p>
<p><img src="https://img-blog.csdn.net/20170716180550635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>创建Spring核心配置文件，导入aop约束</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用表达式配置切入点</strong></p>
<p>常用的表达式：<br>execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p>
<ul>
<li>execution(* cn.itcast.aop.Book.add(..))</li>
<li>execution(* cn.itcast.aop.Book.*(..))</li>
<li>execution(* <em>.</em>(..))</li>
<li>匹配所有save开头的方法 execution(* save*(..))</li>
</ul>
<h2 id="7、举例"><a href="#7、举例" class="headerlink" title="7、举例"></a>7、举例</h2><p>1、首先定义一个Book类，里边有方法add（），也就是切入点（被增强的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;add...........&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、定义一个MyBook类，里边有可以用来增强的方法，即某些功能方法代码。我们要实现的就是将某些功能方法加入切入点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBook</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;前置增强......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;后置增强......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//环绕通知</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around1</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//方法之前</span></span><br><span class="line">		System.out.println(<span class="string">&quot;方法之前.....&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//执行被增强的方法</span></span><br><span class="line">		proceedingJoinPoint.proceed();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方法之后</span></span><br><span class="line">		System.out.println(<span class="string">&quot;方法之后.....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、核心配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 1  配置对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.ywq.aop.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBook&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.ywq.aop.MyBook&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 2 配置aop操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2.1 配置切入点 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.ywq.aop.Book.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.2 配置切面 </span></span><br><span class="line"><span class="comment">			把增强用到方法上面</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myBook&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 配置增强类型 </span></span><br><span class="line"><span class="comment">				method： 增强类里面使用哪个方法作为前置</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;after1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around1&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、测试类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywq.aop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnno</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = </span><br><span class="line">				<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">		Book book = (Book) context.getBean(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">		book.add();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、结果如下：        </p>
<p><img src="https://img-blog.csdn.net/20170716181323013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjU4Mjc4NDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>以上就是使用aop的一个基本简单介绍，这样便可以在业务逻辑代码前后加一些功能性代码了，比如<strong>日志记录，性能统计，安全控制，事务处理，异常处理</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/18/spring-core%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/spring-core%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">spring-core源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-18 11:55:17 / 修改时间：12:41:32" itemprop="dateCreated datePublished" datetime="2021-02-18T11:55:17+08:00">2021-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>本部分从最基本的Spring开始。配置文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;base.SimpleBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line">    SimpleBean bean = context.getBean(SimpleBean.class);</span><br><span class="line">    bean.send();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am send method from SimpleBean!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/ResourceLoader.jpg" alt="ResourceLoader继承体系"></p>
<p>ResourceLoader代表了<strong>加载资源的一种方式，正是策略模式的实现。</strong></p>
<p>构造器源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//null</span></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getResourcePatternResolver:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p>
<h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolvePath:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: <code>new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);</code>那么classpath:就是需要被解析的。</p>
<p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/Environment.jpg" alt="Environment继承体系"></p>
<p>Environmen接口<strong>代表了当前应用所处的环境。</strong>从此接口的方法可以看出，其主要和profile、Property相关。</p>
<h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。<strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong>使用了Profile的配置文件示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;develop&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-develop.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-production.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:jdbc-test.properties&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动代码中可以用如下代码设置活跃Profile:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">&quot;dev&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p>
<blockquote>
<p>properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.</p>
</blockquote>
<h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertySources.jpg" alt="PropertySources继承体系"></p>
<p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p>
<p>StandardEnvironment.customizePropertySources:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** System environment property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">&quot;systemEnvironment&quot;</span>;</span><br><span class="line"><span class="comment">/** JVM system properties property source name: &#123;<span class="doctag">@value</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">&quot;systemProperties&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource</span><br><span class="line">        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource</span><br><span class="line">        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>PropertySource接口代表了键值对的Property来源。继承体系：</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertySource.jpg" alt="PropertySource继承体系"></p>
<p>AbstractEnvironment.getSystemProperties:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) System.getProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map) <span class="keyword">new</span> ReadOnlySystemAttributesMap() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">getSystemAttribute</span><span class="params">(String attributeName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(attributeName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(format(<span class="string">&quot;Caught AccessControlException when accessing system &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;property [%s]; its value will be returned [null]. Reason: %s&quot;</span>,</span><br><span class="line">                                attributeName, ex.getMessage()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p>
<p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p>
<h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="comment">//text即配置文件路径，比如classpath:config.xml</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">            <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></table></figure>

<h5 id="ProperytResolver接口"><a href="#ProperytResolver接口" class="headerlink" title="ProperytResolver接口"></a>ProperytResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p>
<p><img src="https://github.com/seaswalker/spring-analysis/raw/master/note/images/PropertyResolver.jpg" alt="PropertyResolver继承体系"></p>
<p>此接口正是用来解析PropertyResource。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三个参数分别是$&#123;, &#125;, :</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</span><br><span class="line">        <span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doResolvePlaceholders：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PlaceholderResolver接口依然是策略模式的体现</span></span><br><span class="line">    <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPropertyAsRawString(placeholderName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;spring&quot;</span>, <span class="string">&quot;classpath&quot;</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;$&#123;spring&#125;:config.xml&quot;</span>);</span><br><span class="line">SimpleBean bean = context.getBean(SimpleBean.class);</span><br></pre></td></tr></table></figure>

<p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProperty(key, String.class, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) &#123;</span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p>
<p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p>
<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/10/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/%E5%9B%BE%E8%A7%A3http%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">图解http笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-10 16:47:52" itemprop="dateCreated datePublished" datetime="2021-02-10T16:47:52+08:00">2021-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-15 15:24:45" itemprop="dateModified" datetime="2021-02-15T15:24:45+08:00">2021-02-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）</p>
<h3 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h3><p><strong>TCP/IP协议族</strong></p>
<p>TCP/IP协议族是互联网相关联的协议的集合。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及web页面显式需要处理的步骤，等等。而http是属于它内部的一个子集。</p>
<p><strong>TCP/IP的分层管理</strong></p>
<p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。 分层的好处：把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。而且，层次化之后，设计也变得相对简单。处于应用层上的应用可以只考虑分派给自己的任务，而无需弄清对方在地球上哪个地方、对方的传输路线、是否能确保传输送达等问题。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。TCP/IP协议族预存了各类通用的应用服务。如FTP（File Transfer Protocol）、DNS和HTTP。</li>
<li>传输层：该层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP和UDP。</li>
<li>网络层：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎么样的路径到达对方计算机。</li>
<li>链路层：用来处理网络的硬件部分。</li>
</ul>
<p><strong>TCP/IP通信传输流</strong></p>
<p><img src="https://camo.githubusercontent.com/b042898f685e28b66c740535b1d8e7b950bcdcdf841ba9a27ce28062684415c4/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d392e6a7067" alt="缺一张照片P9"></p>
<p>利用TCP/IP协议族进行网路通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>用HTTP 举例来说：首先作为发送端的客户端在应用层（HTTP协议）发出一个HTTP请求。 接着，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分隔，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这就让发往网络的通信请求准备齐全了。 接收端的服务器在链路层接收到数据后，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到客户端发送过来的HTTP请求。</p>
<p><img src="https://camo.githubusercontent.com/cfd3eff10113cb844f43eb253477d20e763cb1989d3dbae7317ecb5cbfff0b7e/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31302e6a7067" alt="&gt; 缺一张照片P10"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h3><p><strong>负责传输的IP协议</strong></p>
<p>IP（网际协议）位于网络层。该协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中最重要的两个条件是 IP 地址和 MAC地址。 IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。</p>
<p><strong>使用ARP协议凭借MAC地址进行通信</strong> IP间通信通信依赖MAC地址。通信的双方通常会经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。该协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>
<p><img src="https://camo.githubusercontent.com/5e168ebb2e85b5042d51ec7abd0bbcf144009610a869e29f978a4cbaf2e9f698/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31322e6a7067" alt="此处输入图片的描述"></p>
<p><strong>确保可靠性的TCP协议</strong></p>
<p>TCP属于传输层，提供可靠的字节流服务。字节流服务是指：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。这就是为什么下载高清大图时，图片会一块一块地加载。</p>
<p><strong>三次握手</strong>为了准确无误地将数据送达目标处，TCP协议在发送数据的准备阶段采用了三次握手策略（若在握手过程中某个阶段中断，TCP协议会再以相同的顺序发送相同的数据包）。</p>
<p><img src="https://camo.githubusercontent.com/5052b0fda439c493c0305e9495deba5a0cd316dd951cc83c42a03184bdeb381b/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31332e6a7067" alt="&gt; 缺图片P13"></p>
<p>当然，除了三次握手，TCP还有其它各种手段确保通信的可靠性。</p>
<h3 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h3><p>DNS服务提供域名到IP地址之间的解析服务。即可通过域名查找IP，或逆向从IP地址反查询域名服务。</p>
<p><img src="https://camo.githubusercontent.com/ca546afb0ebd451b7926a76a6398c1fb12503241d10438eedfdf50d9dad713a1/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31342e6a7067" alt="此处输入图片的描述"></p>
<p><strong>URI和URL</strong></p>
<p>URI（uniform Resource Identifier）Uniform:规定统一的格式可方便处理多种不同类型的资源。Resource:可标识的任何东西Identifier:标识符</p>
<p>URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称，如http、ftp。</p>
<p>URI 用字符串标识某一个互联网资源，而URL表示资源的地点。URL是URI的子集。</p>
<p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处指定的URL，如<code>/image/logo.gif</code>.</p>
<p>绝对URI的格式如下：</p>
<p><img src="https://camo.githubusercontent.com/ef4a26a5f83c09791980bc94140312b926c480f3edc182af01c111d8eb9cd7e2/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d31382e6a7067" alt="图片P18"></p>
<h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>HTTP协议规定，先从客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。</p>
<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p><img src="https://camo.githubusercontent.com/60c9513a2ca5927f006b20a8950f59d84b8c3d2f3ff8d58d0561e295b2821e37/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d32342e6a7067" alt="&gt; 图片P24"></p>
<p>响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<p><img src="https://camo.githubusercontent.com/ac4031c04d349053fd3818439b5a21f8da096ea5aefd6519e95e8a99a61f4f43/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d32352e6a7067" alt="&gt; 图片P25"></p>
<p><strong>HTTP是不保存状态的协议</strong></p>
<p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议得可伸缩性。HTTP/1.1随时无状态协议，但可通过Cookie技术保存状态。</p>
<h3 id="告知服务器意图得HTTP方法"><a href="#告知服务器意图得HTTP方法" class="headerlink" title="告知服务器意图得HTTP方法"></a>告知服务器意图得HTTP方法</h3><ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li>
<li>DELETE：删除文件，与PUT相反</li>
<li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法</li>
<li>TRACE：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理</li>
</ul>
<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。方法名区分大小写，主要要用大写字母。</p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p><strong>持久连接</strong></p>
<p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>
<p><img src="https://camo.githubusercontent.com/0b38dcc8b73925247087cf4f96e5af05c1a083d815d013777e51a75764f0c559/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33342e6a7067" alt="此处输入图片的描述"></p>
<p>发送请求一份包含多张图片的HTML文档对应的Web页面，会产生大量通信开销。</p>
<p><img src="https://camo.githubusercontent.com/97d2b88a8927bd5c1ae2d8dbf8b4345ee3c4084dd973724e9a236353b4a0a8df/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33352e6a7067" alt="此处输入图片的描述"></p>
<p>为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP Connection resue）的方法。 <strong>持久连接的特点</strong>是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p><img src="https://camo.githubusercontent.com/463cfc1f1f34386f3c4d2613e49e5ac24ca009c6137c466c7c10d05da501ba97/68747470733a2f2f626c6f672d313235313437373232392e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f6f74686572732f67726170686963616c2d687474702d33362e6a7067" alt="TCP持久连接"></p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也相应提高了。</p>
<p>在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。 毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>
<p><strong>管线化</strong></p>
<p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线技术出现后，不用等待响应亦可直接发送下一个请求。</p>
<p>注意：尽管HTTP管线化可以克服同域并行请求限制带来的阻塞，但HTTP/1.x有严格的串行返回响应机制，服务器通过TCP连接返回响应时，就是必须按照客户端的请求顺序进行响应，前一个响应没有完成，下一个响应就不能返回。所以使用“HTTP管道”技术时，万一第一个响应时间很长，那么后面的响应处理完了也无法发送，只能被缓存起来，占用服务器内存，这就是传说中的“队首阻塞”。</p>
<h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存Cookie当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>用于HTTP协议交互的信息被称为HTTP报文，请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。</p>
<p>HTTP报文本身是由多行（用CR+LF做换行符）数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两部块。两者由最初出现的空行（CR+LF、回车符+换行符）来划分。通常，并不一定要有报文主体。</p>
<h3 id="编码提升传输效率"><a href="#编码提升传输效率" class="headerlink" title="编码提升传输效率"></a>编码提升传输效率</h3><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率，但这会消耗更多的CPU等资源。</p>
<p><strong>报文主体和实体主体的差异</strong></p>
<p>报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<p><strong>压缩传输的内容编码</strong></p>
<p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。 常见的内容编码有：gzip（GNU zip）、compress（UNIX系统的标准压缩）、deflate（zlib）、identity（不进行编码）</p>
<p><strong>分隔发送的分块传输编码</strong></p>
<p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。 这种把实体主体分块的功能称为<strong>分块传输编码</strong>（Chunked Transfer Coding）。</p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常实在图片或文本文件等上传时使用。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>下载大尺寸的图片的过程中，如果网络中断，则需要重新下载。因此需要一种可恢复的机制。 实现该功能需要指定下载的实体范围，像这样，指定范围发送的请求叫做<strong>范围请求</strong>。 执行范围请求时，会用到首部字段Range来指定资源的byte范围。响应会返回状态码206 Partial Content。</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。状态码如200 OK，以3为数字和原因短语组成。数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="常用的状态码14种："><a href="#常用的状态码14种：" class="headerlink" title="常用的状态码14种："></a>常用的状态码14种：</h3><p><strong>2XX成功</strong></p>
<ul>
<li>200 OK：请求被正常处理</li>
<li>204 No Content:一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：客户端进行范围请求</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/10/restful%E9%A3%8E%E6%A0%BCAPI/" class="post-title-link" itemprop="url">restful风格API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-10 16:07:24 / 修改时间：16:43:20" itemprop="dateCreated datePublished" datetime="2021-02-10T16:07:24+08:00">2021-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>REST – REpresentational State Transfer直译：表现层状态转移。</strong></p>
<p>全称是Resource Representational State Transfer：通速来讲就是资源在网络中以某种表现形式进行状态转移。分解开来：</p>
<p>Resource:资源，即数据。比如newsfeed，friends等；</p>
<p>Representational:某种表现形式，比如用json、xml、jpeg等；</p>
<p>State Transfer：状态变化，通过http动词实现。</p>
<p><strong>为什么用RESTful结构呢？</strong></p>
<p>大家都知道”古代”网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。</p>
<p><img src="https://img-blog.csdn.net/20171107171036253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>从原理角度来分析：</strong></p>
<p>根据Richardson Maturity Model（理查德森成熟度模型）, REST架构的成熟度有4个等级：</p>
<p><img src="https://img-blog.csdn.net/20171107165849966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTc4MjcwNTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><strong>Level 0-面向前台</strong></p>
<p>我们在咖啡店向前台点了一杯拿铁，这个过程可以用这段文字来描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡，接着，前台给我们返回这么一串回复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="number">447031335</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询卡号为447031335的卡的余额，查询的结果返回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;balance&quot;</span>:<span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没钱……<br>哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level 1-面向资源</strong></p>
<p>现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。<br>比如还是下单，请求的内容不变，但是我们多了一条消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;addOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个斜杠和orders，这是什么意思？<br>这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作。<br>接着还是会返回订单的编号给我们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们还是要查询会员卡余额，这次请求的资源变成了cards：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;queryBalance&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;cardId&quot;</span>:<span class="string">&quot;447031335&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;deleteOrder&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level2 -打上标签</strong></p>
<p>接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求。<br>其他种类的请求，比如查询类的，用‘GET’表示，删除类的，用‘DELETE’表示，修改用PATCH表示。<br>来，我们再来重复上面那个过程，来一杯拿铁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>:<span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增，返回的内容还是一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是查询会员卡余额，这次也简化了很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /cards</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cardId&quot;</span>: <span class="string">&quot;447031335&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个请求我们还可以进一步优化为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /cards/<span class="number">447031335</span></span><br></pre></td></tr></table></figure>

<p>直接把要查询的卡号写在后面了。<br>没错，接着，取消订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>Level 3 -完美服务</strong></p>
<p>忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/&#123;orderId&#125;</span><br></pre></td></tr></table></figure>

<p>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……后面两人吵着吵着还打了起来…<br>噗，真是悲剧…<br>有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderName&quot;</span>: <span class="string">&quot;latte&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这次返回时多了些内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;orderId&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;link&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;rel&quot;</span>: <span class="string">&quot;cancel&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/order/123456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了。<br>Level3的Restful API，给使用者带来了很大的遍历，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。<br>现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，这个模型并不是一种规范，只是用来理解Restful的工具。所以，做到了Level2，也就是面向资源和使用Http动词，就已经很Restful了。</p>
<p><strong>Levels的意义</strong></p>
<p>Level1解释了如何通过分治法（Divide and Conquer）来处理复杂问题，将一个大型的服务端点（Service Endpoint）分解成多个资源。</p>
<p>Level 2引入了一套标准的动词，用来以相同的方式应对类似的场景，移除不要的变化。</p>
<p>Level 3引入了可发现性（Discoverability），它可以使协议拥有自我描述（Self-documenting）的能力。</p>
<p><strong>从应用角度来分析：</strong></p>
<p>一、REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计RESTful API;</p>
<p>二、Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。</p>
<p>URL定位资源，用HTTP动词（GET，POST，DELETE，DETC）描述操作。</p>
<p>1、看Url就知道要什么<br>2、看http method就知道干什么<br>3、看http status  code就知道结果如何</p>
<p><a target="_blank" rel="noopener" href="http://api.qc.com/v1/newsfeed">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;</p>
<p>三、用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：</p>
<p>GET用来获取资源</p>
<p>POST用来新建资源</p>
<p>PUT用来更新资源</p>
<p>DELETE用来删除资源</p>
<p>比如：<br>DELETE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 删除某人的好友 （在http parameter指定好友id）<br>POST <a target="_blank" rel="noopener" href="http://api.qc.com/v1/friends">http://api.qc.com/v1/friends</a>: 添加好友<br>UPDATE <a target="_blank" rel="noopener" href="http://api.qc.com/v1/profile">http://api.qc.com/v1/profile</a>: 更新个人资料</p>
<p>四、Server和Client之间传递某资源的一个表现形式，比如用json，xml传输文本，或者用jpg，webP传输图片等。当然还可以压缩HTTP传输时的数据。</p>
<p>五、用HTTP Status Code传递Server的状态信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E5%B9%B6%E5%8F%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">java并发volatile关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 14:00:00 / 修改时间：18:29:13" itemprop="dateCreated datePublished" datetime="2021-02-08T14:00:00+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>摘要：</strong>在java并发编程中，要想使并发程序能够正确地执行，必须要保证三条原则，即：原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致运行不正确。volatile关键字被用来保证可见性，即保证共享变量的内存可见性解决缓存一致性问题。一旦一个共享变量被volatile关键字修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。在多线程环境下，volatile关键字主要用于及时感知共享共享变量的修改，并使得其他线程可以立即得到变量的最新值，例如，用于修饰状态标记量和Double-Check中。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与内存模型紧密相关，因此在讲述volatile关键字之前，我们有必要先去了解与内存模型相关的概念和知识，然后回头再分析volatile关键字的实现原理，最后再给出volatile关键字的使用场景。</p>
<h2 id="一、内存模型的相关概念"><a href="#一、内存模型的相关概念" class="headerlink" title="一、内存模型的相关概念"></a>一、内存模型的相关概念</h2><p>由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。</p>
<p>也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行这个语句时，会先从主存当中读取 i 的值，然后复制一份到高速缓存当中，然后CPU执行指令对 i 进行加1操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如，同时有两个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。</p>
<p>最终结果i的值是1，而不是2.这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，<strong>如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 \</strong>缓存不一致** 的问题。**</p>
<p>为了解决缓存不一致性问题，在 <strong>硬件层面</strong> 上通常来说有以下两种解决方法：</p>
<p>　　1）通过在 <strong>总线加 LOCK# 锁</strong> 的方式 <strong>（在软件层面，效果等价于使用 synchronized 关键字）</strong>；</p>
<p>　　2）通过 <strong>缓存一致性协议</strong> <strong>（在软件层面，效果等价于使用 volatile 关键字）</strong>。</p>
<p>在早期的CPU当中，是通过在总线上加Lock锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问，从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中，如果一个线程在执行i=i+1，如果在执行这段代码的过程中，在总线上发出了LOCK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i的所在的内存读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以，就出现了缓存一致性协议，其中最出名的就是Intel的MESI协议。MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的吃变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。因此，当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="二、并发编程中的三个概念"><a href="#二、并发编程中的三个概念" class="headerlink" title="二、并发编程中的三个概念"></a>二、并发编程中的三个概念</h2><p>原子性问题、可见性问题、有序性问题</p>
<p>1、原子性</p>
<p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>银行转账的例子</p>
<p>2、可见性</p>
<p>可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>3、有序性</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 int型 变量，定义了一个 boolean型 变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1 是在 语句2 前面的，那么 JVM 在真正执行这段代码的时候会保证 语句1 一定会在 语句2 前面执行吗？不一定，为什么呢？这里可能会发生 <strong>指令重排序（Instruction Reorder）</strong>。</p>
<p>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。</p>
<p>比如上面的代码中，语句1 和 语句2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中， 语句2 先执行而 语句1 后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>那么可不可能是这个执行顺序呢： 语句2　-&gt;　语句1　-&gt;　语句4　-&gt;　语句3</p>
<p>　　答案是不可能，因为处理器在进行重排序时会考虑指令之间的 <strong>数据依赖性</strong>，如果一个指令 Instruction 2 必须用到 Instruction 1 的结果，那么处理器会保证 Instruction 1 会在 Instruction 2 之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面，看一个例子：</p>
<p>虽然 <strong>重排序不会影响单个线程内程序执行的结果</strong>，但是多线程呢？下面，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 语句1 和 语句2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在 线程1 执行过程中先执行 语句2，而此时 线程2 会以为初始化工作已经完成，那么就会跳出 while循环 ，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，<strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="三、java内存模型"><a href="#三、java内存模型" class="headerlink" title="三、java内存模型"></a>三、java内存模型</h2><p><strong>在 Java虚拟机规范 中，试图定义一种 *Java内存模型（Java Memory Model，JMM）* 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</strong>那么，Java内存模型 规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在 Java内存模型 中，也会存在缓存一致性问题和指令重排序的问题。</strong></p>
<p>java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>　　执行线程必须先在自己的工作线程中对 变量i 所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值10写入主存当中。那么，Java语言本身对原子性、可见性以及有序性 提供了哪些保证呢？</p>
<p>1、原子性</p>
<p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的：要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子，请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>乍一看，有些朋友可能会说上面的四个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是线程执行这个语句的会直接将数值10写入到工作内存中；</p>
<p>语句2实际上包含两个操作，它先要去读取x的值，再将x的值写入工作内存。虽然，读取x的值以及将x的值写入工作内存这两个操作都是原子性操作，但是合起来就不是原子性操作了；</p>
<p>同样的，x++和x=x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以，上面四个语句只有语句1的操作具备原子性。也就是说，只有简单的读取，赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过，这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p>2、可见性</p>
<p>对于可见性，java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronzied和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修饰刷新到主存当中，因此可以保证可见性。</p>
<p>3、有序性</p>
<p>在java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在java中，可以通过volatile关键字来保证一定的“有序性”。另外，我们千万不能想当然地认为，可以通过synchronized和Lock来保证有序性，也就是说，不能由于synchonized和Lock可以让线程串行地同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 <strong>happens-before 原则</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>先行发生原则：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测代中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ul>
<h2 id="四、深入剖析volatile关键字"><a href="#四、深入剖析volatile关键字" class="headerlink" title="四、深入剖析volatile关键字"></a>四、深入剖析volatile关键字</h2><p>1、volatile关键字的两层语义</p>
<p>一旦一个共享变量被volatile修饰后，那么就具备了两层语义：</p>
<p><strong>1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 \</strong>立即可见** 的；**</p>
<p><strong>2）禁止进行指令重排序。</strong></p>
<p>先看一段代码，假如 线程1 先执行，线程2 后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p><img src="https://img-blog.csdn.net/20170116141631367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程读取数据模型"></p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，如上图所示，每个线程在运行过程中都有自己的工作内存，那么 线程1 在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么，当 线程2 更改了 stop变量 的值之后，可能会出现以下两种情形：</p>
<ul>
<li>线程2对变量的修改没有立即刷入到主存当中；</li>
<li>即使线程2对变量的修改立即反映到主存中，线程1也可能由于没有立即知道线程2对stop变量的更新而一直循环下去。</li>
</ul>
<p>这两种情形都会导致线程1处于死循环。但是，用volatile关键字修饰后就变得不一样了，如下图所示：</p>
<p>1、使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>2、使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；</p>
<p>3、由于线程1的工作内存中缓存变量stop的缓存行无效，所以，线程1再次读取变量stop的值时会去主存读取。</p>
<p>综上，<strong>在 线程2 修改 stop 值时（当然这里包括两个操作，修改 线程2 工作内存中的值，然后将修改后的值写入内存），会使得 线程1 的工作内存中缓存变量 stop 的缓存行无效，然后 线程1 读取时，会发现自己的缓存行无效从而去对应的主存读取最新的值 。**</strong>简化一下，通过使用 volatile 关键字，如下图所示，线程会及时将变量的新值更新到主存中，并且保证其他线程能够立即读到该值。**这样，线程1 读取到的就是最新的、正确的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/08/java%E6%95%B0%E7%BB%84%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java数组综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-08 11:45:40 / 修改时间：13:59:39" itemprop="dateCreated datePublished" datetime="2021-02-08T11:45:40+08:00">2021-02-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、要点概览"><a href="#一、要点概览" class="headerlink" title="一、要点概览"></a>一、要点概览</h2><ul>
<li>数组与容器</li>
<li>数组的创建与初始化</li>
<li>数组与泛型</li>
<li>数组与可变参数列表</li>
<li>Arrays工具类的使用功能</li>
</ul>
<h2 id="二、数组与容器"><a href="#二、数组与容器" class="headerlink" title="二、数组与容器"></a>二、数组与容器</h2><p>早期java数组的几个特点：</p>
<ul>
<li><p>效率</p>
<p>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。由于ArrayList可以实现空间的自动分配且更为灵活，所以，通常应首选ArrayList而不是数组，但是ArrayList的效率比数组低的多。</p>
</li>
<li><p>类型</p>
<p>在 JDK 1.5 之前，Java 并未引进泛型。所以，泛型之前的容器类在处理对象时，都将它们视作没有任何具体类型，即将这些对象都当作 Object 来处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体的类型。这意味着你可以通过编译期的类型检查来防止插入错误类型和抽取不当类型。当然，无论在编译时还是运行时，Java都会阻止你向对象发送不恰当的消息。所以，并不是说哪种方法更不安全，只是若编译时就能够指出错误，会显得更为优雅。</p>
</li>
<li><p>保存基本类型的能力</p>
<p>数组可以持有基本类型，而泛型之前的容器则不能。JDK1.5之后，java引进了泛型和自动包装机制，这使得现在的容器除了性能之外的各个方面都使得数组相形见绌。</p>
</li>
</ul>
<h2 id="三、数组的创建与初始化"><a href="#三、数组的创建与初始化" class="headerlink" title="三、数组的创建与初始化"></a>三、数组的创建与初始化</h2><p>1、数组基础</p>
<ul>
<li>数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用或基本类型的值；</li>
<li>对象数组保存的是引用，基本类型数组直接保存基本类型的值；</li>
<li>“[]”语法是访问数组对象的唯一方式；</li>
</ul>
<p>2、创建与初始化</p>
<ul>
<li><p>作为数组初始化的一部分隐式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=&#123;...&#125;;	<span class="comment">//花括号内对象的个数就是数组大小</span></span><br><span class="line">System.out.println(strs.length);	<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用new表达式显式创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=<span class="keyword">new</span> String[<span class="number">5</span>];	<span class="comment">//创建方式2</span></span><br><span class="line">String[] ss = <span class="keyword">new</span> String[]&#123;...&#125;;	<span class="comment">//创建方式3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>3、多维数组</p>
<p>多维数组的本质：数组的元素仍是数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方式 1</span></span><br><span class="line"><span class="keyword">int</span>[][] a = &#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;, </span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;, </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式 2</span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//粗糙数组：每个向量具有任意长度</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-D array with varied-length vectors: </span></span><br><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123; </span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)][]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) </span><br><span class="line">        a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">5</span>)]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="四、数组与泛型"><a href="#四、数组与泛型" class="headerlink" title="四、数组与泛型"></a>四、数组与泛型</h2><ul>
<li><p>数组与泛型不能很好的结合，也就是说，不能实例化具有参数化类型的数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[] first = <span class="keyword">new</span> T[<span class="number">3</span>];    <span class="comment">// ERROR  </span></span><br><span class="line">A&lt;String&gt;[] arrays = <span class="keyword">new</span> A&lt;String&gt;[<span class="number">4</span>];    <span class="comment">// ERROR: Cannot create a generic array of A&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以创建泛型数组引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;String&gt;[] arrays;	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组是协变的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objs=<span class="keyword">new</span> String[<span class="number">3</span>];	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>总之，泛型容器总是比泛型数组更好的选择。</p>
<h2 id="五、数组与可变参数类型"><a href="#五、数组与可变参数类型" class="headerlink" title="五、数组与可变参数类型"></a>五、数组与可变参数类型</h2><p>1、可变参数类型概念</p>
<p>Java SE5 添加了可变参数类型 ( Variable Argument Type )，形式为 “Type… args”，<strong>只可用作方法的参数</strong>。<strong>可变参数列表适用于参数个数不确定但类型确定的情形 ( java 把可变参数当做数组处理 )。</strong>特别需要注意的是，<strong>可变参数列表必须位于最后一项 (即最多只支持一个可变参数)。</strong>当可变参数列表个数多余一个时，必将有一个不是最后一项，所以只支持一个可变参数。因为可变参数列表的参数个数不确定，所以当其后边还有相同类型参数时，Java 无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();  </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1   </span></span><br><span class="line"><span class="comment">        1 2 3   </span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~  </span></span><br></pre></td></tr></table></figure>

<p>可变参数列表具有以下特点：</p>
<ul>
<li>只能出现在方法参数列表的最后；</li>
<li>…位于变量类型和变量名之间，前后有无空格都可以；</li>
<li>调用可变参数所在的方法时，编译器会为该可变参数隐式创建一个数组，从而我们可以在方法体中以数组的形式访问可变参数列表。</li>
</ul>
<p>2、可变参数类型与数组的兼容性</p>
<ul>
<li>编译器认为数组类型和可变参数类型是相同的，即二者不能重载；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//ERROR : Duplicate method dealArray(int[]) in type TestVarArgus </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray();   </span><br><span class="line">        dealArray(<span class="number">1</span>);  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>可变参数是兼容数组类型参数的，但是数组类型参数却无法兼容可变参数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 1 ： 给参数为可变参数类型的方法传递数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line"></span><br><span class="line">        dealArray(intArray);  <span class="comment">// OK</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例 2 ： 给参数为数组类型的方法传递可变参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>[] intArray)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : intArray)  </span><br><span class="line">            System.out.print(i +<span class="string">&quot; &quot;</span>);  </span><br><span class="line"></span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">        dealArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// ERROR</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其实，对于示例代码 2 而言，只是需要一个定义为 dealArray(int, int, int）的方法或者一个定义为 dealArray(int… ）的方法。所以，自然就无法去匹配具有数组类型的参数 dealArray( int[] ) 方法了。</p>
<ul>
<li>参数匹配原则：能匹配定长的方法，那么优先匹配该方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVarArgus</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//含有不定参数的那个重载方法是最后被选中的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span>... intArray)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bad&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealArray</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> count2)</span></span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Bingo&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </span><br><span class="line">    dealArray(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">        Bingo </span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Arrays工具类的实用功能"><a href="#六、Arrays工具类的实用功能" class="headerlink" title="六、Arrays工具类的实用功能"></a>六、Arrays工具类的实用功能</h2><p>1、复制数组</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Introduction</th>
<th>Note</th>
</tr>
</thead>
<tbody><tr>
<td>System.arraycopy(<strong>Object src,</strong> int srcPos, <strong>Object dest,</strong> int destPos, int length)</td>
<td>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束</td>
<td>若复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝(浅复制)；<strong>该方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确切类型；**</strong>须明确自行新建立一个数组对象，作为副本**</td>
</tr>
<tr>
<td>copyOf(T[] original, int newLength)</td>
<td>复制指定的数组，<strong>截取或用 null 填充</strong></td>
<td><strong>底层调用的还是 System.arraycopy；返回一个新的数组对象，若新数组的长度超过原数组的长度，则保留数组默认值</strong></td>
</tr>
</tbody></table>
<p>注意</p>
<p>对于以上两个方法：</p>
<ul>
<li>若赋值对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝；</li>
<li>这两个方法不会执行自动包装和自动拆包，所以两个数组必须具有相同的确认类型。</li>
</ul>
<p>2、数组的字符串方式表示</p>
<p>方法：Arrays.toString(Object[] a)    //Arrays.deepToString(Object[] a)</p>
<p>作用：返回指定数组内容字符串表示形式：前者适用于一维数组，或者适用于多维数组</p>
<p>3、数组的比较</p>
<p>方法：Arrays.equals(Object[] a, Object[] a2)    //deepEquals(Object[] a, Object[] a2)</p>
<p>作用：比较两个数组：元素类型相同，元素个数相等，对应位置的元素相同；</p>
<p>注意：</p>
<ul>
<li>通过对每个元素使用equals()作比较来判断；</li>
<li>对于基本类型，使用的是基本类型的包装器类的equals()方法；</li>
<li>使用equals()方法比较原则：是不是同一个对象，是不是同一个类型，是不是具有相同的内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line">Arrays.fill(a1, <span class="number">47</span>); </span><br><span class="line">Arrays.fill(a2, <span class="number">47</span>); </span><br><span class="line">print(Arrays.equals(a1, a2));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>4、数组的排序</p>
<p>使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组进行排序，只要该对象实现了Comparable接口或具有相关联的Comparator。</p>
<p><strong>方法：</strong> Arrays.sort(Object[] a) / Arrays.sort(Object[] a, int fromIndex, int toIndex)<br>　　　Arrays.sort(T[] a, Comparator&lt;? super T&gt; c) / Arrays.sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> <strong>对数组内元素进行升序排序 (默认)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = Generated.array(<span class="keyword">new</span> String[<span class="number">20</span>], <span class="keyword">new</span> RandomGenerator.String(<span class="number">5</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 String 内置的比较器（已实现 Comparable 接口）：字典序（大写字母开头的词都放在前面输出，之后才是小写字母开头的词）</span></span><br><span class="line">Arrays.sort(sa);   <span class="comment">// ... ,WHkjU, YNzbr, bkIna, cQrGs, ...</span></span><br><span class="line">.</span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： Collections.reverseOrder() ： 现有顺序的逆序</span></span><br><span class="line">Arrays.sort(sa, Collections.reverseOrder()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 Comparator 比较 ： String.CASE_INSENSITIVE_ORDER : 忽略大小写将单词一起进行排序</span></span><br><span class="line">Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); </span><br></pre></td></tr></table></figure>

<p>5、在已排序的数组中查找</p>
<p><strong>若数组已经 \</strong>排好序*<em>，就可以使用该方法执行快速查找；*</em>若对未排序的数组使用该方法，将产生不可预料的结果。****</p>
<p><strong>方法：</strong> binarySearch(Object[] a, Object key) / binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</p>
<p><strong>作用：</strong> 使用 <strong>二分搜索法</strong> 来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的自然顺序对数组进行<strong>升序排序（通过 sort(Object[]) 方法）</strong>; 使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过 sort(T[], Comparator) 方法）对数组进行<strong>多态**</strong>升序排序**。</p>
<p>注意：</p>
<ul>
<li>对已经有序的数组进行查找；</li>
<li>若找到了目标，方法返回的值不小于0；否则，它产生的负返回值表示在此排序下应插入的位置；</li>
<li>“sort(Object[])” 与 “binarySearch(Object[] a, Object key)” 对应，“sort(T[], Comparator)” 与 binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) 对应。</li>
</ul>
<p><strong>若数组包含重复元素，则该方法无法保证找到的是哪一个元素；若需要对无重复元素的数组进行排序，可使用 TreeSet(保持排序顺序) 或 LinkedHashSet(保持插入顺序)进行排序。除非它们成为程序的瓶颈，否则不需要自己维护数组。</strong></p>
<p>6、填充数组</p>
<p><strong>方法：</strong> fill(Object[] a, Object val)<br><strong>作用：</strong> <strong>只能使用同一个值填充各个位置，而针对对象而言，就是复制同一个对象的引用进行填充</strong></p>
<p>7、数组与容器的转化</p>
<p><strong>方法：</strong> asList(T… a)<br><strong>作用：</strong> 返回一个 <strong>受指定数组支持的固定大小的列表</strong><br><strong>注意：</strong></p>
<ul>
<li>所得到的 List 是固定大小的，因为<strong>其底层表示即为该数组，因此不能调整大小。</strong>因此，调用 add/remove 方法会抛出 java.lang.UnsupportedOperationException (可选操作)。</li>
<li>因此，<strong>Arrays.asList() 的真正意义在于：将其结果作为构造器参数传递给任何 Collection （或者使用 addAll 方法、Collections.addAll 静态方法），这样可以生成一个动态的容器。</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">java异常模型综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 16:28:12 / 修改时间：20:28:49" itemprop="dateCreated datePublished" datetime="2021-02-04T16:28:12+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、异常的引入及基础"><a href="#一、异常的引入及基础" class="headerlink" title="一、异常的引入及基础"></a>一、异常的引入及基础</h2><p>发现错误的理想时机是在编译阶段，也就是在你试图运行程序之前。然而，编译期间编译器并不能找出所有的错误，余下的错误只有在运行期才能发现和解决，这类错误就是 <strong>Throwable。</strong> 这就需要错误源能够通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确的处理这个问题，这就是Java的错误报告机制 —— 异常机制。该机制使得程序把 <strong>在正常执行过程中做什么事的代码</strong> 与 <strong>出了问题怎么办的代码</strong> 相分离。</p>
<p>在对异常的处理方面，Java 采用的是 <strong>终止模型</strong> 。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。相对于终止模型，另一种异常处理模型为 <strong>恢复模型</strong>，它使异常被处理之后能够继续执行程序。虽然该模型很吸引人，但不是很实用，其主要原因是它所导致的耦合：恢复性处理程序需要了解异常的抛出地点，这势必要包含依赖于抛出位置的非通用代码，从而大大增加了代码编写和维护的难度。</p>
<p>在异常情形中，异常的抛出伴随着以下三件事的发生：</p>
<ul>
<li>首先，同java中其他对象的创建一样，将使用new在堆上创建异常对象；</li>
<li>其次，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用；</li>
<li>最后，异常处理机制接管程序，并开始寻找对应的异常处理程序，并将程序从错误状态中恢复。</li>
</ul>
<h2 id="二、java标准异常"><a href="#二、java标准异常" class="headerlink" title="二、java标准异常"></a>二、java标准异常</h2><p>1、基本概念</p>
<p><img src="https://img-blog.csdn.net/20160916105959789" alt="这里写图片描述"></p>
<p>- <strong>Throwable：所有的异常类型的根类</strong></p>
<p>　　在 Java 中，<strong>Throwable 是所有的异常类型的根类。</strong>Throwable 有两个直接子类：<strong>Exception</strong> 和 <strong>Error</strong>。二者都是 Java 异常处理的重要子类，各自都包含大量子类。<br>　<br>- <strong>Error：程序本身无法处理的错误</strong></p>
<p>　　<strong>Error 是程序无法处理的错误，表示运行应用程序中较严重问题。</strong>这些错误大部分与代码编写者执行的操作无关，而与代码运行时的 JVM 、资源等有关。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<strong>这些错误是不可查的，并且它们在应用程序的控制和处理能力之外。</strong>在 Java 中，错误通过Error的子类描述。</p>
<ul>
<li><p><strong>Exception：程序本身可以处理的错误</strong></p>
<p>　　Exception 通常是Java程序员所关心的，其在Java类库、用户方法及运行时故障中都可能抛出。它由两个分支组成： <strong>运行时异常（派生于 RuntimeException 的异常）</strong> 和 <strong>其他异常</strong> 。<strong>划分这两种异常的规则是：由程序错误（一般是逻辑错误，如错误的类型转换、数组越界等，应该避免）导致的异常属于RuntimeException；而程序本身没有问题，但由于诸如I/O这类错误（eg：试图打开一个不存在的文件）导致的异常就属于其他异常。</strong></p>
</li>
</ul>
<hr>
<p>此外，Java的异常(包括Exception和Error)通常可分为 <strong>受检查的异常（checked exceptions）</strong> 和 <strong>不受检查的异常（unchecked exceptions）</strong> 两种类型。</p>
<ul>
<li><p><strong>不受检查异常：派生于 Error 或 RuntimeException 的所有异常</strong></p>
<p>　　<strong>不可查异常是编译器不要求强制处理的异常</strong>，包括运行时异常（RuntimeException与其子类）和错误（Error）。也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
</li>
<li><p><strong>受检查异常：除去不受检查异常的所有异常</strong></p>
<p>　　<strong>受检查异常是编译器要求必须处理的异常。</strong>这里所指的处理方式有两种： <strong>捕获并处理异常</strong> 和<strong>声明抛出异常</strong> 。也就是说，当程序中可能出现这类异常，要么用 try-catch 语句捕获它，要么用 throws 子句声明抛出它，否则编译不会通过。</p>
</li>
<li><p><strong>准则：**</strong>如果程序出现RuntimeException异常，那么一定是程序员的问题**</p>
</li>
<li><p><strong>异常和错误的区别：</strong>异常能被程序本身处理，错误则无法处理</p>
</li>
</ul>
<h2 id="三、java异常处理机制"><a href="#三、java异常处理机制" class="headerlink" title="三、java异常处理机制"></a>三、java异常处理机制</h2><p>1、异常处理</p>
<p>在java应用程序中，异常处理机制为：抛出异常与捕获异常。</p>
<p><strong>抛出异常：</strong>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处理异常的代码并执行。</p>
<p><strong>捕获异常：</strong>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常地方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着java程序的终止。</p>
<hr>
<p>对于运行时异常、错误或受检查的异常，java技术所要求的异常处理方式有所不同：</p>
<ul>
<li><p>由于<strong>运行时异常是不受检查的</strong>，Java规定：运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常；</p>
</li>
<li><p>对于<strong>方法运行中可能出现的Error</strong>，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error是不可恢复的，也属于合理的应用程序不该捕捉的异常；</p>
</li>
<li><p>对于<strong>所有受检查的异常</strong>，Java规定：异常必须被捕捉，或者进行异常说明。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常；</p>
<p>　　任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的 throw 语句抛出异常。</p>
<p>　　<strong>总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的 RuntimeException 和 Error。</strong></p>
</li>
</ul>
<p>2、异常说明</p>
<p>对于受检查异常而言，java提供了相应的语法，使你能告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> TooBig, TooSmall, DivZero </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>表示方法f可能会抛出TooBig，TooSmall，DivZero三种异常，而</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;... ...&#125;</span><br></pre></td></tr></table></figure>

<p>表示方法g不会抛出任何异常</p>
<p>代码必须与异常说明保持一致。若方法中的代码产生了受检查异常却没有进行处理，编译器就会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中表明此方法产生异常。不过，我们可以声明方法将抛出异常，但实际上并不抛出。</p>
<p>3、捕获异常</p>
<p><strong>监控区域：</strong>它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码，由try…catch…子句实现。</p>
<p>（1）try子句</p>
<p>​    如果方法内部抛出了异常，这个方法将在抛出异常的过程中结束。若不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。其中，在这个块里，尝试各种方法调用的部分称为try块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>(2) catch子句-异常处理程序</p>
<p>抛出的异常必须得到处理，而且针对每个要捕获的异常，都必须准备相应的异常处理程序。异常处理程序必须紧跟在try块之后，以catch关键字表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// Code that might generate exceptions </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 id1)|&#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type1 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 id2) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type2 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type3 id3) &#123; </span><br><span class="line">  <span class="comment">// Handle exceptions of Type3 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>异常处理程序可能用不到标识符（id1,id2,…），因为异常的类型本身就已经给出了足够的信息来处理异常，但标识符不可省。<strong>当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入对应的catch自居执行，此时认为异常得到处理。一旦catch子句结束，则处理程序的查找结束</strong>（与 switch…case…不同）。</p>
<p>特别需要注意的是：</p>
<ul>
<li>异常匹配原则：抛出异常时，异常处理系统会按照代码的书写顺序找出最近匹配的处理程序。一旦找到，它就认为异常将得到处理，然后停止查找；</li>
<li>不可屏蔽派生类异常：捕获基类异常的catch子句必须放在捕获其派生类异常的catch子句之后，否则编译不会通过；</li>
<li>catch子句必须与try子句连用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/java%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">java的抽象特性：抽象类与接口深度解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 15:47:32 / 修改时间：16:24:10" itemprop="dateCreated datePublished" datetime="2021-02-04T15:47:32+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>要点</strong></p>
<ul>
<li>抽象类</li>
<li>接口</li>
<li>抽象类与接口的区别</li>
</ul>
<h2 id="一、抽象"><a href="#一、抽象" class="headerlink" title="一、抽象"></a>一、抽象</h2><p>对于面向对象编程来说，抽象是它的四大特征之一。在java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。接口和抽象类为我们提供了一种将接口与实现分离的更加结构化的方法。</p>
<h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h2><p>1）概念基础</p>
<p>所有的对象都是通过类来描述的，但是并不是所有的类都是可以描述对象（对象=状态+行为）的。如果一个类没有足够的信息来描述一个具体的对象，那么我们就可以将这样的类设为抽象类。抽象类只能被public和默认修饰符修饰。</p>
<p>抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰 <strong>(特别需要注意的是，抽象类也可以不包含抽象方法，即其中所有的方法都是具体方法)**。</strong>因为抽象类中含有未具体实现的方法，所以不能用抽象类创建对象。**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就称为abstract类了。</p>
<p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要三点区别：</p>
<ul>
<li>抽象方法不能是private的，否则，其不能被子类继承，子类也无法实现该方法，从而这样做没有任何意义；</li>
<li>抽象类不能用来创建对象</li>
<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。</li>
</ul>
<p>2）本质</p>
<ul>
<li>抽象类与具体类的唯一区别：含有抽象方法的类一定是抽象类；</li>
<li>抽象类的根本作用是为了继承，所以抽象类的抽象方法不能被private修饰；</li>
<li>抽象类比具体类仅多一点抽象因素：行为层面的抽象（可以包含抽象方法）；</li>
</ul>
<h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><p>1）概念基础</p>
<p>接口（interface），在软件工程中，接口泛指别人调用的方法或者函数。它是对行为的抽象。接口只能被public和默认修饰符修饰。在java中，定义一个接口的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口中可以含有 变量和方法。</strong>但是要注意，接口中的 <strong>变量</strong> 会被隐式地指定为 <strong>public static final变量（并且只能是public static final变量，\</strong>而且 public static final 可省，即默认就是public static final 的）*<strong>* ，而 <strong>方法</strong> 会被隐式地指定为 <strong>public abstract方法且只能是 public abstract 方法\</strong>（public abstract 可省，即默认就是 public abstract 的）**</strong>，<strong>并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</strong>从这里可以隐约看出接口和抽象类的区别，<strong>接口是一种极度抽象的类型，它比抽象类更加“抽象”。</strong></p>
<p>要让一个类遵循某组特地的接口需要使用 <strong>implements</strong> 关键字，具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p>
<p>2）本质</p>
<ul>
<li>接口是一种行为契约，是对行为的抽象；</li>
</ul>
<h2 id="四、接口与抽象类的区别"><a href="#四、接口与抽象类的区别" class="headerlink" title="四、接口与抽象类的区别"></a>四、接口与抽象类的区别</h2><p>1、语法层面上的区别</p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract（可省）方法；</li>
<li>抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法、而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161210225212635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>2、设计层面上的区别</p>
<p>1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，<strong>继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。</strong>如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它可以跨越不同的类，是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说 <strong>对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</strong></p>
<p>门和警报的例子：门都有open()和close()两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>
<p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>
<p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>
<p>　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、小结</p>
<ul>
<li>抽象类是对一种事物的抽象，接口是对行为的抽象；</li>
<li>抽象类是一种模板，接口是一种契约</li>
<li>抽象类的抽象程序介于普通类和接口之间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
