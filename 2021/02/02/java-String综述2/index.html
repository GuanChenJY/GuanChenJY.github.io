<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="六、字符串常量池字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。java能够进行这">
<meta property="og:type" content="article">
<meta property="og:title" content="java String综述2">
<meta property="og:url" content="http://example.com/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:description" content="六、字符串常量池字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。java能够进行这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdn.net/20170313093548412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="article:published_time" content="2021-02-02T02:29:46.000Z">
<meta property="article:modified_time" content="2021-02-03T11:09:03.089Z">
<meta property="article:author" content="GCC">
<meta property="article:tag" content="java相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170313093548412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">

<link rel="canonical" href="http://example.com/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java String综述2 | Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/02/java-String%E7%BB%BC%E8%BF%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java String综述2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 10:29:46" itemprop="dateCreated datePublished" datetime="2021-02-02T10:29:46+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-03 19:09:03" itemprop="dateModified" datetime="2021-02-03T19:09:03+08:00">2021-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="六、字符串常量池"><a href="#六、字符串常量池" class="headerlink" title="六、字符串常量池"></a>六、字符串常量池</h2><p>字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(str1==str2);	<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个初始为空的字符串池，它由类String私有地维护。当以字面值形式创建一个字符串时，总是先检查字符串池是否含存在该对象，若存在，则直接返回。此外，通过new操作符创建的字符串对象不指向字符串池中的任何对象。</p>
<p>2、手动入池</p>
<p>​    一个初始为空的字符串池，它由类String私有地维护。当调用intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(Object)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。特别地，手动入池遵循以下规则：</p>
<p>​    对于任意两个字符串s和t，当且仅当s.equals(t)为true时，s.intern() == t.intern()才为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String str3 = s2.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println( str1 == str2 );   <span class="comment">//false</span></span><br><span class="line">        System.out.println( str1 == str3 );   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于String str1=“abc”，str1引用的是常量池（方法区）的对象；而String str2=new String(“abc”)，str2引用的是堆中的对象，所以内存地址不一样。但是由于内容一样，所以str1和str3指向同一对象。</p>
<p>3、实例</p>
<p>1）情景一：字符串常量池</p>
<p>Java虚拟机（JVM）中存在着一个字符串常量池，其中保存着很多String对象，并且这些String对象可以被共享使用，因此提高了效率。之所以字符串具有字符串常量池，是因为String对象是不可变的，因此可以被共享。字符串常量池由String类维护，我们可以通过intern()方法使字符串池手动入池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 在字符串池创建了一个对象  </span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line"><span class="comment">//↑ 字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s2 : &quot;</span>+(s1==s2));    </span><br><span class="line"><span class="comment">//↑ true 指向同一个对象，  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2)));    </span><br><span class="line"><span class="comment">//↑ true  值相等  </span></span><br></pre></td></tr></table></figure>

<p>2）情景二：关于new String(“…”)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 创建了两个对象，一个存放在字符串池中，一个存在与堆区中；  </span></span><br><span class="line"><span class="comment">//↑ 还有一个对象引用s3存放在栈中  </span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);  </span><br><span class="line"><span class="comment">//↑ 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3 == s4 : &quot;</span>+(s3==s4));  </span><br><span class="line"><span class="comment">//↑false   s3和s4栈区的地址不同，指向堆区的不同地址；  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4)));  </span><br><span class="line"><span class="comment">//↑true  s3和s4的值相同  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1 == s3 : &quot;</span>+(s1==s3));  </span><br><span class="line"><span class="comment">//↑false 存放的地区都不同，一个方法区，一个堆区  </span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.equals(s3) : &quot;</span>+(s1.equals(s3)));  </span><br><span class="line"><span class="comment">//↑true  值相同 </span></span><br></pre></td></tr></table></figure>

<p>通过new String(“…”)来创建字符串时，在该构造函数的参数值为字符串字面值的前提下，若该字面值不在字符串常量池中，那么会创建两个对象：一个在字符串常量池中，一个在堆中；否则，只会在堆中创建一个对象。对于不在同一区域的两个对象，二者的内存地址必定不同。</p>
<p>3）情景三：字符串连接符“+”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">&quot;ab&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str3 = <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象                                         </span></span><br><span class="line">String str4 = str2+str3;                                        </span><br><span class="line">String str5 = <span class="string">&quot;abcd&quot;</span>;    </span><br><span class="line">System.out.println(<span class="string">&quot;str4 = str5 : &quot;</span> + (str4==str5)); <span class="comment">// false  </span></span><br></pre></td></tr></table></figure>

<p>局部变量str2，str3指向字符串常量池中的两个对象。在运行时，第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</p>
<p>　(1). 调用 String 类的静态方法 <strong>String.valueOf()</strong> 将 str2 转换为字符串表示；</p>
<p>　(2). JVM 在堆中创建一个 StringBuilder对象，同时用str2指向转换后的字符串对象进行初始化；　</p>
<p>　(3). 调用StringBuilder对象的append方法完成与str3所指向的字符串对象的合并；</p>
<p>　(4). 调用 StringBuilder 的 toString() 方法在堆中创建一个 String对象；</p>
<p>　(5). 将刚刚生成的String对象的堆地址存赋给局部变量引用str4。</p>
<p>而引用str5指向的是字符串常量池中字面值”abcd”所对应的字符串对象。由上面的内容我们可以知道，引用str4和str5指向的对象的地址必定不一样。这时，内存中实际上会存在五个字符串对象： 三个在字符串常量池中的String对象、一个在堆中的String对象和一个在堆中的StringBuilder对象。</p>
<p>4）情景四：字符串的编译期优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;  <span class="comment">//1个对象  </span></span><br><span class="line">String str11 = <span class="string">&quot;abcd&quot;</span>;   </span><br><span class="line">System.out.println(<span class="string">&quot;str1 = str11 : &quot;</span>+ (str1 == str11));   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">final</span> String str8 = <span class="string">&quot;cd&quot;</span>;  </span><br><span class="line">String str9 = <span class="string">&quot;ab&quot;</span> + str8;  </span><br><span class="line">String str89 = <span class="string">&quot;abcd&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str9 = str89 : &quot;</span>+ (str9 == str89));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">//↑str8为常量变量，编译期会被优化  </span></span><br><span class="line">String str6 = <span class="string">&quot;b&quot;</span>;  </span><br><span class="line">String str7 = <span class="string">&quot;a&quot;</span> + str6;  </span><br><span class="line">String str67 = <span class="string">&quot;ab&quot;</span>;  </span><br><span class="line">System.out.println(<span class="string">&quot;str7 = str67 : &quot;</span>+ (str7 == str67));     <span class="comment">// false</span></span><br><span class="line"><span class="comment">//↑str6为变量，在运行期才会被解析。</span></span><br></pre></td></tr></table></figure>

<p>java编译器对于类似“常量+字面值”的组合，其值在编译的时候就能够被确定了。在这里，str1和str9的的值在编译时就可以被确定，因此它们分别等价于：String str1=”abcd”；和String str9=”abcd”；</p>
<p>java编译器对于含有“String”引用的组合，则在运行期会产生新的对象（通过调用StringBuilder类的toString()方法），因此这个对象存储在堆中。</p>
<p>4、小结</p>
<ul>
<li>使用字面值形式创建的字符串与通过new创建的字符串一定是不同的，因为二者的存储位置不同：前者在方法区，后者在堆；</li>
<li>我们在使用诸如String str=”abc”；的格式创建字符串对象时，总是想当然地认为，我们创建了String类的对象str。但是事实上，对象可能并没有被创建。唯一可以肯定的是，指向String对象的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑；</li>
<li>字符串常量池的理念是享元模式；</li>
<li>java编译器对“常量+字面值”的组合是当成常量表达式直接求值来优化的；对于含有”String 引用”的组合，其在编译期不能被确定，会在运行期创建新对象。</li>
</ul>
<h2 id="七、三个字符串类"><a href="#七、三个字符串类" class="headerlink" title="七、三个字符串类"></a>七、三个字符串类</h2><p>1、String与StringBuilder</p>
<p>简要的说， <strong>String 类型 和 StringBuilder 类型的主要性能区别在于 String 是不可变的对象。</strong> 事实上，在对 String 类型进行“改变”时，实质上等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。由于频繁的生成对象会对系统性能产生影响，特别是当内存中没有引用指向的对象多了以后，JVM 的垃圾回收器就会开始工作，继而会影响到程序的执行效率。所以，<strong>对于经常改变内容的字符串，最好不要声明为 String 类型</strong>。但如果我们使用的是 StringBuilder 类，那么情形就不一样了。因为，我们的每次修改都是针对 StringBuilder 对象本身的，而不会像对String操作那样去生成新的对象并重新给变量引用赋值。所以，<strong>在一般情况下，推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下</strong>。</p>
<p>在某些特别情况下，String对象的字符串拼接可以直接被JVM在编译期确定下来，这时StringBuilder在速度上就不占任何优势了。</p>
<p>因此，在绝大部分情况下，在效率方面：StringBuilder&gt;String</p>
<p>2、StringBuffer与StringBuilder</p>
<p>首先需要明确的是，StringBuffer 始于 JDK 1.0，而 StringBuilder 始于 JDK 5.0；此外，从 JDK 1.5 开始，对含有字符串变量 (非字符串字面值) 的连接操作(+)，JVM 内部是采用 StringBuilder 来实现的，而在这之前，这个操作是采用 StringBuffer 实现的。</p>
<p>　　<strong>JDK的实现中 StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder。</strong>AbstractStringBuilder的实现原理为：AbstractStringBuilder中采用一个 <strong>char数组</strong> 来保存需要append的字符串，char数组有一个初始大小，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是 <strong>2</strong> 倍。</p>
<p>　　<strong>StringBuffer 和 StringBuilder 都是可变的字符序列，但是二者最大的一个不同点是：StringBuffer 是线程安全的，而 StringBuilder 则不是。StringBuilder 提供的API与StringBuffer的API是完全兼容的，即，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，但是后者一般要比前者快。**</strong>因此，可以这么说，StringBuilder 的提出就是为了在单线程环境下替换 StringBuffer 。**</p>
<p>　　在单线程环境下，优先使用 StringBuilder。</p>
<p>3、实例</p>
<p>1）编译时优化与字符串连接符的本质</p>
<p>先来看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2 + s3;</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量s的创建等价于String s=”abc”；而变量s4的创建相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder(s1);</span><br><span class="line">temp.append(s2).append(s3);</span><br><span class="line">String s4 = temp.toString();</span><br></pre></td></tr></table></figure>

<p>但事实上，是不是这样子呢？我们将其反编译一下，来看看Java编译器究竟做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将上述 Test2 的 class 文件反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;            <span class="comment">// 编译期优化</span></span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//底层使用 StringBuilder 进行字符串的拼接</span></span><br><span class="line">        String s4 = (<span class="keyword">new</span> StringBuilder(String.valueOf(s1))).append(s2).append(s3).toString();   </span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的反编译结果，很好的印证了我们在第六节中提出的字符串连接符的本质。</p>
<p>2）另一个例子：字符串连接符的本质</p>
<p>由上面的分析结果，我们不难推断出 String 采用连接运算符（+）效率低下原因分析，形如这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            s+=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会被编译器编译为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            s = (<span class="keyword">new</span> StringBuilder(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，每做一次 字符串连接操作 “+” 就产生一个 StringBuilder 对象，然后 append 后就扔掉。下次循环再到达时，再重新 new 一个 StringBuilder 对象，然后 append 字符串，如此循环直至结束。事实上，如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 <strong>N - 1</strong> 次创建和销毁对象的时间。所以，<strong>对于在循环中要进行字符串连接的应用，一般都是用StringBulider对象来进行append操作。</strong></p>
<h2 id="八、字符串与正则表达式：匹配、替换与验证"><a href="#八、字符串与正则表达式：匹配、替换与验证" class="headerlink" title="八、字符串与正则表达式：匹配、替换与验证"></a>八、字符串与正则表达式：匹配、替换与验证</h2><p>正则表达式：</p>
<p><strong>用一个字符串来描述一个特征，然后去验证另一个字符串是否符合这个特征。</strong>使用正则表达式，我们能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。 Java 内置了对正则表达式的支持，其相关的类库在 java.util.regex 包下</p>
<p>1、java转义与正则表达式转义</p>
<p>要想匹配某些特殊字符，比如 “\”，需要进行两次转义，即Java转义与正则表达式转义。对于下面的例子，需要注意的是，split()函数的参数必须是“正则表达式”字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a\\b&quot;</span>;</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(a.split(<span class="string">&quot;\\\\&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>2、使用Pattern与Matcher构造功能强大的正则表达式对象</p>
<p>Pattern与Matcher的组合就是Java对正则表达式的主要内置支持，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;.\\\\.&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;a\\b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.matches());</span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    a\b</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h2 id="九、String与（深）克隆"><a href="#九、String与（深）克隆" class="headerlink" title="九、String与（深）克隆"></a>九、String与（深）克隆</h2><p>1、克隆的定义与意义</p>
<p>克隆就是制造一个对象的副本。一般地，根据所要克隆的对象的成员变量中是否含有引用类型，可以将克隆分为两种：浅克隆（Shallow Clone）和深克隆（Deep Clone），默认情况下使用Object中的clone方法进行克隆就是浅克隆，即完成对象域对域的拷贝。</p>
<p>（1）Object中的clone()方法</p>
<p><img src="https://img-blog.csdn.net/20170313093548412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在使用clone()方法时，若该类未实现 Cloneable 接口，则抛出 java.lang.CloneNotSupportedException 异常。下面我们以Employee这个例子进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆完成...&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        ~Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: P1_1.Employee</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>(2).Cloneable接口</p>
<p>Cloneable接口是一个标识性接口，即该接口不包含任何方法，但是如果一个类想合法的进行克隆，那么就必须实现这个接口。JDK描述如下：</p>
<ul>
<li>A class implements the Cloneable interface to indicate to the java.lang.Object.clone() method that it is <strong>legal</strong> for that method to make a field-for-field copy of instances of that class.</li>
<li><strong>Invoking Object’s clone method on an instance that does not implement the Cloneable interface results in the exception CloneNotSupportedException being thrown.</strong></li>
<li>By convention, classes that implement this interface should <strong>override</strong> Object.clone (which is protected) with <strong>a public method</strong>.</li>
<li><strong>Note that this interface does *not* contain the clone() method.</strong> Therefore, it is not possible to clone an object merely by virtue of the fact that it implements this interface. Even if the clone method is invoked reflectively, there is no guarantee that it will succeed.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#clone()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Clone与Copy</p>
<p>假设现在有一个Employee对象，Employee tobby = new Employee(“CMTobby”,5000)，<strong>通常, 我们会有这样的赋值Employee tom=tobby，这个时候只是简单了copy了一下reference</strong>，tom 和 tobby 都指向内存中同一个object，这样tom或者tobby对对象的修改都会影响到对方。打个比方，如果我们通过tom.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。如果我们希望得到tobby所指向的对象的一个精确拷贝，同时两者互不影响，那么我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法</p>
<p>3、Shallow Clone与Deep Clone</p>
<p>Clone是如何完成的呢？Object中的clone()方法在对某个对象实施克隆时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了，以Employee为例，它里面有一个域hireDay不是基本类型的变量，而是一个reference变量，经过Clone之后克隆类只会产生一个新的Date类型的引用，它和原始引用都指向同一个 Date 对象，这样克隆类就和原始类共享了一部分信息，显然这种情况不是我们愿意看到的</p>
<p>这个时候，我们就需要进行 Deep Clone 了，以便对那些引用类型的域进行特殊的处理，例如本例中的hireDay。我们可以重新定义 clone方法，对hireDay做特殊处理，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       Employee cloned = (Employee) <span class="keyword">super</span>.clone();  </span><br><span class="line">       <span class="comment">// Date 支持克隆且重写了clone()方法，Date 的定义是：</span></span><br><span class="line">       <span class="comment">// public class Date implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;</span></span><br><span class="line">       cloned.hireDay = (Date) hireDay.clone() ;   </span><br><span class="line">       <span class="keyword">return</span> cloned;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>因此，Object 在对某个对象实施 Clone 时，对其是一无所知的，它仅仅是简单执行域对域的Copy。 其中，对八种基本类型的克隆是没有问题的，但当对一个引用类型进行克隆时，只是克隆了它的引用。因此，克隆对象和原始对象共享了同一个对象成员变量，故而提出了深克隆 ： 在对整个对象浅克隆后，还需对其引用变量进行克隆，并将其更新到浅克隆对象中去。</strong></p>
<p>4、一个克隆的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Employee </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(Date hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Employee cloned = (Employee) <span class="keyword">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((hireDay == <span class="keyword">null</span>) ? <span class="number">0</span> : hireDay.hashCode());</span><br><span class="line">        result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        temp = Double.doubleToLongBits(salary);</span><br><span class="line">        result = prime * result + (<span class="keyword">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee other = (Employee) obj;</span><br><span class="line">        <span class="keyword">if</span> (hireDay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.hireDay != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hireDay.equals(other.hireDay))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.doubleToLongBits(salary) != Double</span><br><span class="line">                .doubleToLongBits(other.salary))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; : &quot;</span> + String.valueOf(salary) + <span class="string">&quot; : &quot;</span> + hireDay.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类 Manger </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manger</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String edu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manger</span><span class="params">(String name, <span class="keyword">double</span> salary, Date hireDay, String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, hireDay);</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEdu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEdu</span><span class="params">(String edu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.edu = edu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getSalary() + <span class="string">&quot; : &quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.getHireDay() + <span class="string">&quot; : &quot;</span> + <span class="keyword">this</span>.getEdu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">super</span>.hashCode();</span><br><span class="line">        result = prime * result + ((edu == <span class="keyword">null</span>) ? <span class="number">0</span> : edu.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(obj))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manger other = (Manger) obj;</span><br><span class="line">        <span class="keyword">if</span> (edu == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.edu != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!edu.equals(other.edu))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Manger manger = <span class="keyword">new</span> Manger(<span class="string">&quot;Rico&quot;</span>, <span class="number">20000.0</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;NEU&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        Manger clonedManger = (Manger) manger.clone();</span><br><span class="line">        <span class="comment">// 输出克隆的manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象的克隆对象 = &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Manger对象和其克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改、输出manger</span></span><br><span class="line">        manger.setEdu(<span class="string">&quot;TJU&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象 = &quot;</span> + manger.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次输出manger</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原克隆对象= &quot;</span> + clonedManger.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的Manger对象和原克隆对象是否相等：  &quot;</span></span><br><span class="line">                + manger.equals(clonedManger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output: </span></span><br><span class="line"><span class="comment">        Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象的克隆对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        Manger对象和其克隆对象是否相等：  true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        修改后的Manger对象 = Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : TJU</span></span><br><span class="line"><span class="comment">        原克隆对象= Rico : 20000.0 : Mon Mar 13 15:36:03 CST 2017 : NEU</span></span><br><span class="line"><span class="comment">        修改后的Manger对象和原克隆对象是否相等：  false</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:</span></span><br></pre></td></tr></table></figure>

<p>5、Clone()方法的保护机制</p>
<p>　<strong>在Object中clone()是被申明为 \</strong>protected** 的，这样做是有一定的道理的。**以 Employee 类为例，如果我们在Employee中重写了protected Object clone()方法， ，就大大限制了可以“克隆”Employee对象的范围，即可以保证只有在和Employee类在同一包中类及Employee类的子类里面才能“克隆”Employee对象。进一步地，如果我们没有在Employee类重写clone()方法，则只有Employee类及其子类才能够“克隆”Employee对象。</p>
<p>6、注意事项</p>
<p>Clone()方法的使用比较简单，注意以下几点：</p>
<ul>
<li><p>什么时候使用shallow Clone，什么时候使用deep Clone？</p>
<p>这个主要看具体对象的域是什么性质的，基本类型还是引用类型</p>
</li>
<li><p>调用Clone()方法的对象所属的类(Class)必须实现Clonable接口，否则在调用Clone方法的时候会抛出CloneNotSupportedException；</p>
</li>
<li><p>所有数组对象都实现了Clonable接口，默认支持克隆；</p>
</li>
<li><p>如果我们实现了Clonable接口，但没有重写Object类的clone方法，那么执行域对域的拷贝；</p>
</li>
<li><p>明白String在克隆中的特殊性</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E7%9B%B8%E5%85%B3/" rel="tag"># java相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/01/java-String%E7%BB%BC%E8%BF%B01/" rel="prev" title="java String综述1">
      <i class="fa fa-chevron-left"></i> java String综述1
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/04/java%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/" rel="next" title="java原生类型与包装器类型深度剖析">
      java原生类型与包装器类型深度剖析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.</span> <span class="nav-text">六、字符串常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">七、三个字符串类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E5%8C%B9%E9%85%8D%E3%80%81%E6%9B%BF%E6%8D%A2%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="nav-number">3.</span> <span class="nav-text">八、字符串与正则表达式：匹配、替换与验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81String%E4%B8%8E%EF%BC%88%E6%B7%B1%EF%BC%89%E5%85%8B%E9%9A%86"><span class="nav-number">4.</span> <span class="nav-text">九、String与（深）克隆</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
