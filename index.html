<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Laplace">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="GCC">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%BA%94%E7%94%A8-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">位运算的应用-算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-10 11:48:12 / 修改时间：14:26:18" itemprop="dateCreated datePublished" datetime="2020-12-10T11:48:12+08:00">2020-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>　　位操作是一种通过算法来处理bit或比单词短的数据片段的操作。需要位操作的计算机程序任务包括低级设备控制，错误检测和校正算法，数据压缩，加密算法和优化。对于大多数其他任务，现代程序语言允许编程者直接在抽象层面上工作，而不是去编程那些代表这些抽象的bit位（即我们现在编程都是用代码写程序，而不是0和1）。在源码中可以用的位操作包括：AND、OR、XOR、NOT和位移。<br>　　在某些情况中，位操作可以避免或者减少在一个数据结构上需要进行循环的次数，并且可以成倍的效率提升，因为位操作是并行处理的。但是位操作的代码比较难以编写和维护。</p>
<p>这里我们先用一个简单的问题来感受一下位操作的威力。比如现在问题是要求判断一个数x是不是2的整数幂，普通的思路是用循环不断去判断x x<em>x</em>看是否能够被2整除，如果是，则除以2，否则这个数不是2的整数幂。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type x: int</span></span><br><span class="line"><span class="string">	:rtype: bool</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> x &lt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">		x //= <span class="number">2</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面普通解法，需要进行的循环次数随着x的增大而增大，采用位运算的算法程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type x: int</span></span><br><span class="line"><span class="string">	:rtype: bool</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">not</span> (x &amp; (x - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>代码中<code>x&amp;(x-1)</code>的作用是将x的二进制表示中右边第一个1置0。比如3原来的二进制表示是<code>11</code>，最右边的1置0后就变成了<code>10</code>，所以有<code>3&amp;(3-1)=2</code>。而2的整数幂的二进制表示肯定是只有一个1，如果将这个1置0，那么结果肯定是0。</p>
<h2 id="位运算的应用实例"><a href="#位运算的应用实例" class="headerlink" title="位运算的应用实例"></a>位运算的应用实例</h2><p>位运算的几个核心操作符是&amp;（按位与）、|（按位或）、~（按位取反）、^（按位异或）、&lt;&lt;（左移）、&gt;&gt;（右移）。下面根据一些具体的问题，来看看位运算怎么应用。</p>
<p>**Example 1:**计算给定整数的二进制表达中有多少个1</p>
<p>最简单的思路就是每次判断数字的二进制表达的最后一位是否为1，如果是1就计数器加一，然后将数字右移一位，但是这样会有很多无效操作，比如100个0连在一起，需要右移100次才能遇到下一个1。这里可以用到上面提到的<code>x &amp; (x - 1)</code>，每次去掉最右边的一个1，x中有多少个1，就只要循环这么多次。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count1Bit</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type x: int</span></span><br><span class="line"><span class="string">	:rtype: int</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> x:</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		x &amp;= x - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>上面也提到过，<code>x &amp; (x - 1)</code>的作用是将x的二进制表示中右边第一个1置0，我们来分步看一下为什么会这样子。首先<code>x-1</code>的作用是将x最右边的1置0，并且这个1后面的所有0置1（如果这个1已经是最后一位则忽略不计）。如果将减一后的结果和原数按位相与，首先最右边一个1由于变成0了，肯定与的结果是0，最右边1后面的数字，原数都是0，现在都是1，那么与的结果肯定也还都是0。比如现在一个二进制数是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x:0010,0101,0000</span><br><span class="line">x-1:0010,0100,1111</span><br><span class="line">x&amp;(x-1):0010,0100,0000</span><br></pre></td></tr></table></figure>

<p>这里就没有考虑负数的情况了，由于计算机中负数是补码形式存储，而Python中整数的位数又没有限制，感觉没啥意义，这里就pass了。</p>
<p><strong>Example 2</strong>: 不使用加减法实现两个整数相加</p>
<p>不能使用加减法，那就只能靠位运算了。可以将加法分解一下，每次先计算不考虑进位的加法，然后计算进位，最后把两个结果加在一起。看一下程序:honey_pot:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type a: int</span></span><br><span class="line"><span class="string">	:type b: int</span></span><br><span class="line"><span class="string">	:rtype: int</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">while</span> b:</span><br><span class="line">		a, b = a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">		a &amp;= <span class="number">0xFFFFFFFF</span>		<span class="comment"># 32位整型</span></span><br><span class="line">		b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">		<span class="keyword">if</span> a &gt; <span class="number">0x7FFFFFFF</span>:		<span class="comment"># 考虑负数的情况</span></span><br><span class="line">			a = ~(a ^ <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">	<span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>上面程序，<code>a^b</code>的结果是是不考虑进位的和，因为1+1和0+0的结果都是0，只有0+1或1+0才是1，这刚好符合异或的性质。而<code>(a &amp; b) &lt;&lt; 1</code>表示进位的结果，因为只有1+1才会发生进位，并且需要将这个进位左移1位（因为是进位往前一位加）。然后一直循环，直到进位为0，此时的<code>a</code>就是输入两个数的和了。</p>
<p>以5和7为例：</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201210141043810.png" alt="image-20201210141043810"></p>
<p>当<code>b=0</code>时停止循环，此时<code>a=0b1100=12</code>，结果正确。<br>　　不过因为在Python中，整型的长度没有限制，当一个整数超过32位时，Python会自动扩展，理论上可以表示无穷大的数（实际最大能够表示多大我也没有测试过）。这个就直接导致进位右移操作在Python算法中起不到效果，永远不可能出现<code>b=0</code>的情况。所以Python代码中需要判断整数<strong>溢出</strong>的情况。现在假设整数由32bit表示，<code>a &amp;= 0xFFFFFFFF</code>就是获取<code>a</code>的32位二进制表示，如果<code>a</code>为负数，那么得到的是<code>a</code>的无符号补码，这里需要注意一下。由于在计算机中，二进制第一位是符号位，0表示正数，1表示负数，所以32位能表示的最大的正数为0x7FFFFFF，即0111,1111,1111,1111,1111,1111,1111,1111</p>
<p>如果<code>a &amp;= 0xFFFFFFFF</code>的结果大于0x7FFFFFFF，就说明<code>a</code>是个负数，需要进行转原码的处理</p>
<p>我们如何根据无符号的负数补码得其有符号的原码呢？先回顾一下补码是如何计算的：正数的补码就是其本身；负数的补码是保持符号位不变，其他位按位取反，然后加1得到补码。现在最大的问题就是如果一个数和0xFFFFFFFF与运算之后，得到的数是无符号类型的，所以也不存在符号位这一说了。这里我们可以先将<code>a ^= 0xFFFFFFFF</code>，这其实也就是按位取反，不过这种形式的按位取反得到的还是无符号类型，如果先用<code>~</code>进行按位取反，Python会将得到一个有符号类型的数，这改变了数的大小，显然不行。所以第二次再用<code>~</code>进行按位取反，得到的有符号的<code>a</code>的补码了。<br>　　简而言之，如果<code>a</code>是负数，<code>a &amp;= 0xFFFFFFFF</code>得到的是<code>a</code>无符号的补码形式，如果先用<code>a ^= 0xFFFFFFFF</code>按位取反，再用<code>a = ~a</code>按位取反，得到的还是原来的数（两次取反相互抵消，负负得正），只不过变成<code>a</code>有符号的补码了。这时Python会将其当做负数的补码处理，会再对其进行一次求补码的操作，得到<code>a</code>的原码。</p>
<p><strong>Example 3</strong>:给一个从0~n的连续整数数组，找出数组缺少的一个数，比如数组为[0,1,3]，缺少的数为2</p>
<p>这个我们当然可以用等差数列求和公式算出理论上数组的和，再减去数组实际的和，就能得到缺少的这个数。如果用位运算应该怎么做呢？代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type nums: list</span></span><br><span class="line"><span class="string">	:rtype: int</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	ret = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">		ret ^= i</span><br><span class="line">		ret ^= x</span><br><span class="line">	<span class="keyword">return</span> ret ^ <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>

<p>这里用到的其实是异或的一个特性：两个同样的数异或结果为0。就以[0, 1, 3]为例，程序中<code>ret</code>初始值为0，<code>ret</code>每次循环分别同<code>i</code>和<code>x</code>进行了一次异或操作，这里<code>i</code>代表完整数组应该出现的值，<code>x</code>代表实际数组中的值。循环结束时，<code>ret</code>同[0, 0, 1, 1, 2, 3]进行了异或，因为完整数组是从0 ~ n的，循环结束时只访问了0 ~ n-1，所以<code>ret</code>需要再和<code>len(nums)</code>异或一次。<code>ret</code>就总共和[0, 0, 1, 1, 2, 3, 3]进行了异或，相同的数异或抵消为，2只出现了一次，所以2就是这个连续数组缺失的数字。<br>　　异或很适合“找不同”的问题，下面再看一个例子。</p>
<p><strong>Example 4:</strong> 一个无序整数数组中，除了两个数字只出现过一次，其他数字都出现了两次，找出这两个只出现一次的数字出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        res^=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((div&amp;res)==<span class="number">0</span>)&#123;</span><br><span class="line">        div&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((div&amp;n)!=<span class="number">0</span>)&#123;</span><br><span class="line">            a^=n;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b^=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example5:找出不大于N的最大的2的幂指数</strong></p>
<p>这个问题本质上就是找到N的二进制表达中最左边的1所在的位置，然后将后面的1全部置0的问题。笨办法是循环判断找到最高位的1，这个问题还可以转化为将最左边的1后面全部置1，然后加1再右移一位。比如现在N=19，其二进制表示为<code>10011</code>，我们只要将其转化为<code>11111</code>然后加1变为<code>100000</code>，最后再右移一位变为<code>10000</code>即得到不大于19的最大二次幂为16。将最高位右边全部置1可以用或逻辑<code>|</code>来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestPower</span>(<span class="params">N</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type N: int</span></span><br><span class="line"><span class="string">	:rtype: int</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	N |= N &gt;&gt; <span class="number">1</span></span><br><span class="line">	N |= N &gt;&gt; <span class="number">2</span></span><br><span class="line">	N |= N &gt;&gt; <span class="number">4</span></span><br><span class="line">	N |= N &gt;&gt; <span class="number">8</span></span><br><span class="line">	N |= N &gt;&gt; <span class="number">16</span></span><br><span class="line">	<span class="keyword">return</span> (N + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>位运算符<code>|</code>的一个作用就是尽可能多的保留1，这里我们默认用32bit来表示整数，所以上述代码中只考虑了除去符号位的后31位。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>常用的位运算包括&amp;（按位与）、|（按位或）、~（按位取反）、^（按位异或）、&lt;&lt;（左移）、&gt;&gt;（右移）。</p>
<ul>
<li><code>&amp;</code>通常用于需要选择特定的数位的情况，因为任何一个数位和1相与得到的是其本身；</li>
<li><code>|</code>通常用于要求尽可能保留1的情况，因为只要有1，或运算的结果一定是1；</li>
<li><code>~</code>按位取反会将符号位一同取反，得到的还是一个有符号整数；</li>
<li><code>^</code>常用于去除重复元素的情况，和“负负得正”这种情况比较类似；</li>
<li><code>&lt;&lt;</code>和<code>&gt;&gt;</code>通常和上面4种位运算符搭配使用，不过要注意在Python中左移是不会发生溢出的，需要人为判断溢出。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/10/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%88/" class="post-title-link" itemprop="url">网络杂谈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-10 10:45:23 / 修改时间：11:23:28" itemprop="dateCreated datePublished" datetime="2020-12-10T10:45:23+08:00">2020-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="VPN的原理"><a href="#VPN的原理" class="headerlink" title="VPN的原理"></a>VPN的原理</h2><p>VPN：英文全称是“Virtual Private Network”，就是虚拟专用网络。VPN通常拿来做两个事情，一个是可以让世界上任意2台机器进入一个虚拟的局域网中（当然这个局域网的数据通讯是加密的，很安全，用起来和一个家庭局域网没有区别），一个是可以用来翻墙。</p>
<p>VPN比SS更加底层，它通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。这和任何一个代理的实现思路都差不多，应用层并不知道网卡是虚拟的，这样vpn虚拟网卡将以中间人的身份对数据进行加工，从而实现各种神奇的效果。具体来说，vpn是通过编写一套网卡驱动并注册到操作系统实现的虚拟网卡，这样数据只要经过网卡收发就可以进行拦截处理。</p>
<p>一句话，vpn在IP层工作，而ss在TCP层工作。</p>
<p><strong>翻墙用途</strong></p>
<p><img src="http://yuerblog.cc/wp-content/uploads/2017/01/baiviet000181.png" alt="baiviet000181"></p>
<p>需要在vps上部署vpn server，客户端所有数据将经过虚拟网卡的加密封装后都转发给vps上的vpn server，由它来转发给目标服务器，这和ss server原理类似，由vpn协议加密从而绕过GFW实现访问墙外网站，下面将以pptp vpn协议为例说明。</p>
<p>例如要访问谷歌，那么客户端发出的数据包首先通过协议栈处理封装成IP包，其源地址是虚拟网卡的地址，例如：192.168.0.2，而目标地址是谷歌的IP。</p>
<p>原始IP包交给虚拟网卡发送时，PPTP网卡驱动会按PPP协议对这个IP包整体加密封装作为新的payload，用一层新的IP头封装这个payload发送出去，这个新IP头的目标地址是vpn server，源地址是客户端的外网IP。</p>
<p>vpn server的协议栈会剥离掉新IP头，将内部PPP协议的payload交给pptpd进程处理，pptpd进程会按PPP协议解包得到原始的IP包，我们知道这个IP包的源地址是192.168.0.2，目标地址google。因此pptpd进程需要做的是将这个ip包的源ip地址改为VPS的地址，然后将IP包发给谷歌，从而和谷歌进行数据交换。最终，pptpd理所应当将谷歌的应答IP包的目标IP地址换成192.168.0.2，然后经过PPP协议封装并添加新的IP头后发回给客户端既可。</p>
<p><strong>局域网用途</strong></p>
<p><img src="http://yuerblog.cc/wp-content/uploads/2017/01/Drawing3.gif" alt="drawing3"></p>
<p>大家知道，玩CS的时候都是局域网搜索房间的，要求大家坐在一个网吧里连着一台交换机。如果大家各自坐在家里玩CS想联机，通常要登录一个对战平台，其实对战平台做的事情就是VPN，也就是虚拟一个局域网，大家感受起来就和坐在一起一样。</p>
<p>虚拟网卡的驱动会尽力伪装成一个物理网卡的样子，我们知道DHCP协议是局域网动态分配客户端IP的协议，那么VPN的虚拟网卡其实也会和vpn server进行一些协商得到一个虚拟局域网的IP，比如192.168.0.2。得到虚拟IP后，后续数据将通过虚拟网卡发送至vpn server所在的IP，最终被pptpd进程处理。</p>
<p>既然各个客户端的虚拟网卡都是和同一个pptpd进程交互，那么这个pptpd进程自然知道这个虚拟的局域网内有哪些局域网用户，因此当2个虚拟局域网用户192.168.0.2和192.168.0.3之间想互相通讯的时候，pptpd会完成数据的中转。不过要注意，虚拟局域网用户间的通讯是不需要像访问谷歌那样修改数据包的源IP地址的，这个很容易想明白。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/09/kubeEdge%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/09/kubeEdge%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">kubeEdge学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-09 15:06:40" itemprop="dateCreated datePublished" datetime="2020-12-09T15:06:40+08:00">2020-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-10 10:44:23" itemprop="dateModified" datetime="2020-12-10T10:44:23+08:00">2020-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img-blog.csdnimg.cn/20200917160602852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="云边通信"><a href="#云边通信" class="headerlink" title="云边通信"></a>云边通信</h2><p>cloud端的cloud Hub与edge端的Edge Hub。这两个模块之间通过websocket或者quic通信，相当于建立了一条底层通信隧道，供k8s和其他应用通信。</p>
<p><strong>cloudhub</strong>: 就是一个隧道的server端，用于大量的edge端基于websocket或者quic协议链接上来；</p>
<p><strong>edgehub</strong>: 位于edge端运行，是隧道的client端，负责将接收到的信息转发到各edge端的模块处理；同时将来自各edge端模块的消息通过隧道发送到cloud端。</p>
<h2 id="边缘端"><a href="#边缘端" class="headerlink" title="边缘端"></a>边缘端</h2><h3 id="MetaManager"><a href="#MetaManager" class="headerlink" title="MetaManager"></a>MetaManager</h3><p><code>MetaManager</code>模块后端对应一个本地的数据库（sqlLite），所有其他模块需要与cloud端通信的内容都会被保存到本地DB中一份，当需要查询数据时，如果本地DB中存在该数据，就会从本地获取，这样就避免了与cloud端之间频繁的网络交互；同时，在网络中断的情况下，本地的缓存的数据也能够保障其稳定运行（比如你的智能汽车进入到没有无线信号的隧道中），在通信恢复之后，重新同步数据。</p>
<h3 id="Edged"><a href="#Edged" class="headerlink" title="Edged"></a>Edged</h3><p>之前提到过kubernetes的kubelet，它相当于k8s的核心。这块其实简单做了一些裁剪，去掉一些用不上的功能，然后就成为<code>Edged</code>模块，该模块就是保障cloud端下发的pod以及其对应的各种配置、存储（后续会支持函数式计算）能够在edge端稳定运行，并在异常之后提供自动检测、故障恢复等能力。当然，由于k8s本身运行时的发展，该模块对应支持各种CRI应该也比较容易。</p>
<h3 id="EventBus-Servicebus-Mapper"><a href="#EventBus-Servicebus-Mapper" class="headerlink" title="EventBus/Servicebus/Mapper"></a>EventBus/Servicebus/Mapper</h3><p>前面讲到的模块都与k8s直接或间接相关，接下来说下与设备（或者说真正IOT业务）相关的设备管理侧。外部设备的接入当前支持MQTT和Rest-API，这里分别对应<code>EventBus</code>和<code>ServiceBus</code>。EventBus就是一个MQTT broker的客户端，主要功能是将edge端各模块通信的message与设备mapper上报到MQTT的event做转换的组件；而ServiceBus就是对应当外部是Rest-API接入时的转换组件。说道这里，就有必要提一下MQTT broker，其实搞互联网的基本都用过类似于rabbitmq、activeMQ之类的消息中间件，其实他们就支持MQTT协议啦（可以理解为AMQP的精简版）。IOT的各种设备可能直接支持MQTT，但有的只支持蓝牙或者其他近场通信的协议。没关系，<code>Mappper</code>可以实现将各种协议转换为对MQTT的订阅与发布，从而实现与edge端的通信。当然，ServiceBus对应就适用于支持http协议的服务了。</p>
<h3 id="DeviceTwin"><a href="#DeviceTwin" class="headerlink" title="DeviceTwin"></a>DeviceTwin</h3><p>edge端最后就剩下一个<code>DeviceTwin</code>模块了，要理解这个名词，就得提一下<code>数字孪生</code>这个概念。这里来科幻一下，假设人类要实现乾坤大挪移，但是有点难度的是，这下是要把你移到火星上。怎么办？这里有一个解决方案：在地球上通过扫描你的所有生物信息，生成拥有你完整生物特征的数据包之后，然后在地球上就把你毁灭了。再将描述你完整信息的数据包通过电波光速发送到火星上，让火星的设备再使用接收到的生物特征造出一个你。是不是挺可行！ 回个头来，我们要说的<code>数字孪生</code>就是那个用来传输到火星的用于描述你所有生物特征的数据包；当然，这里对应就是接入设备信息。所以，DeviceTwin就是将这些信息保存到本地DB中，并处理基于cloud端的操作来修改device的某些属性（也就是操作设备）；同时，将设备基于eventBus上报的状态信息同步到本地DB和cloud端的中间人。</p>
<h2 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h2><h3 id="入口与beehive"><a href="#入口与beehive" class="headerlink" title="入口与beehive"></a>入口与beehive</h3><p>beehive模块在整个kubeedge中扮演了非常重要的作用，它实现了一套Module管理的接口，程序中各个模块的启动、运行、模块间的通信等都是由其统一封装管理。下图是kubeedge的edge端代码的main启动流程，这里涉及到的modules就是由beehive提供。</p>
<p><img src="https://img-blog.csdnimg.cn/20200917160627314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>可以看到，在初始化的时候，分别加载了各个edge端modules的init函数，用来注册其modules到beehive框架中。然后在core.Run中遍历启动（StartModules）。</p>
<h3 id="EdgeHub"><a href="#EdgeHub" class="headerlink" title="EdgeHub"></a>EdgeHub</h3><p><img src="https://img-blog.csdnimg.cn/2020091716072848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>重点是启动了两个go routine，用来实现往两个方向的消息接收和分发。这里<code>go ehc.routeToEdge</code>对应从隧道端点接收cloud端发往edge端的消息，然后调用<code>ehc.dispatch</code>解析出消息的目标module并基于beehive模块module间消息的通信机制来转发出去。</p>
<p>同理，<code>go ehc.routeToCloud</code>实现将edge端消息基于隧道转发到cloud端的cloudHub模块处理。当然，该模块中实现了对同步消息的response等到超时处理的逻辑，当在未超时期间收到response消息，会转发到消息发送端模块。比较暴力的是，一旦发送消息到cloud失败，该goroutine会退出，通知所有模块，当前与cloud端是未连接状态，然后重新发起连接。</p>
<p>metaManager在与cloud的连接断开期间，会使用本地DB中的数据，不会发起往cloud端的查询。</p>
<h3 id="Edged-1"><a href="#Edged-1" class="headerlink" title="Edged"></a>Edged</h3><p><img src="https://img-blog.csdnimg.cn/20200917160745170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这块基本是调用kubelet的代码，实现较多的是启动流程。另外，将之前kubelet的client作为fake的假接口，转而将数据都通过metaClient来存储数据到metaManager，从而代理之前直接访问api-server的操作。</p>
<p>这里差异化的一块代码在<code>e.syncPod</code>的实现，通过读取metaManager和EdgeController的pod任务列表，来执行对本地pod的操作。同时，这些pod关联的configmap和secret也会随着处理pod的过程而一并处理。对pod的操作也是基于一个操作类别的queue，比如<code>e.podAddWorkerRun</code>就启动了一个用于消费添加pod的queue的goroutine。外部的封装基本就这样，内部完全通过引用kubelet原生的包来处理。</p>
<h3 id="MetaManager-1"><a href="#MetaManager-1" class="headerlink" title="MetaManager"></a>MetaManager</h3><p><img src="https://img-blog.csdnimg.cn/20200917160755654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>从代码架构看起来，该模块比较简单，首先在外层按照一定周期给自己发送消息，触发定时同步pod状态到cloud端。另外，在mainLoop中启动一个独立的goroutine接收外部消息，并执行处理逻辑。</p>
<p>处理逻辑基于消息类型分类，分别包括：</p>
<ol>
<li>cloud端发起的增、删、查、改</li>
<li>edge端模块发起的查询请求（前面提到，当状态为disconnect的时候不发起remote查询）</li>
<li>cloud端返回的查询响应的结果</li>
<li>edgeHub发来的用于更新与cloudHub见连接状态的消息</li>
<li>自己给自己发送的，定期同步edge端pod状态到cloud端的消息</li>
<li>函数式计算相关的消息</li>
</ol>
<p>重点来说增删查改，拿添加举例。当接收到要添加某个资源时，会将资源解析出来，组织成为key、type、value的三元组，以一种类似于模拟NoSQL的方式保存到本地的SqlLite数据库中。这样保存的目的也是为了方便快速检索和增删。保存完之后，需要对应发送response消息到请求消息的源模块。</p>
<h3 id="EventBus与ServiceBus"><a href="#EventBus与ServiceBus" class="headerlink" title="EventBus与ServiceBus"></a>EventBus与ServiceBus</h3><p><img src="https://img-blog.csdnimg.cn/2020091716081283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>EventBus</strong>:</p>
<p>eventBus用于对接MQTT Broker与beehive，MQTT broker有几种启动模式，从代码实现的角度分为：</p>
<ol>
<li>使用内嵌MQTT broker</li>
<li>使用外部MQTT broker</li>
</ol>
<p>在内嵌MQTT broker模式下，eventBus启动了golang实现的broker包<code>gomqtt</code>用来作为外部MQTT设备的接入，具体用法请参考其github项目首页。两种模式下eventBus都做了一些共性的操作。</p>
<p><strong>ServiceBus</strong>:</p>
<p>ServiceBus启动一个goroutine来接受来自beehive的消息，然后基于消息中带的参数，通过调用http client将消息通过REST-API发送到本地127.0.0.1上的目标APP。这相当于一个客户端，而APP是一个http Rest-API server，所有的操作和设备状态都需要客户端调用接口来下发和获取。</p>
<h3 id="DeviceTwin-1"><a href="#DeviceTwin-1" class="headerlink" title="DeviceTwin"></a>DeviceTwin</h3><p><img src="https://img-blog.csdnimg.cn/20200917161104100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09saXZlckpvbmFz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>DeviceTwin包含以下几个部分的功能：</p>
<ol>
<li>数据存储方面，将设备数据存储到本地存储sqlLite，包括三张表：<code>device</code>、<code>deviceAttr</code>和<code>deviceTwin</code>。</li>
<li>处理其他模块发送到twin module的消息，然后调用 dtc.distributeMsg来处理消息。在消息处理逻辑里面，消息被分为了四个类别，并分别发送到这四个类别的action执行处理（每一个类别又包含多个action）。</li>
</ol>
<h2 id="edgecore源码分析"><a href="#edgecore源码分析" class="headerlink" title="edgecore源码分析"></a>edgecore源码分析</h2><p>源码分析中主要分析<code>edgecore</code>中EdgeCommand的基本流程。</p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edgecore</span><br><span class="line">├── app</span><br><span class="line">│   ├── options</span><br><span class="line">│   │   └── options.go</span><br><span class="line">│   └── server.go  <span class="comment"># NewEdgeCoreCommand 、registerModules</span></span><br><span class="line">└── edgecore.go  <span class="comment"># main</span></span><br></pre></td></tr></table></figure>

<p>edgecore模块包含：</p>
<p><code>edged</code>、<code>edgehub</code>、<code>metamanager</code>、<code>eventbus</code>、<code>servicebus</code>、<code>devicetwin</code>、<code>edgemesh</code></p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>main入口函数，仍然是cobra命令框架格式。</p>
<p><code>edge/cmd/edgecore/edgecore.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    command := app.NewEdgeCoreCommand()</span><br><span class="line">    logs.InitLogs()</span><br><span class="line">    <span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewEdgeCoreCommand"><a href="#NewEdgeCoreCommand" class="headerlink" title="NewEdgeCoreCommand"></a>NewEdgeCoreCommand</h3><p><code>NewEdgeCoreCommand</code>与<code>NewCloudCoreCommand</code>一样构造对应的cobra command结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewEdgeCoreCommand create edgecore cmd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEdgeCoreCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    opts := options.NewEdgeCoreOptions()</span><br><span class="line">    cmd := &amp;cobra.Command&#123;</span><br><span class="line">        Use: <span class="string">&quot;edgecore&quot;</span>,</span><br><span class="line">        Long: <span class="string">`Edgecore is the core edge part of KubeEdge, which contains six modules: devicetwin, edged, </span></span><br><span class="line"><span class="string">edgehub, eventbus, metamanager, and servicebus. DeviceTwin is responsible for storing device status </span></span><br><span class="line"><span class="string">and syncing device status to the cloud. It also provides query interfaces for applications. Edged is an </span></span><br><span class="line"><span class="string">agent that runs on edge nodes and manages containerized applications and devices. Edgehub is a web socket </span></span><br><span class="line"><span class="string">client responsible for interacting with Cloud Service for the edge computing (like Edge Controller as in the KubeEdge </span></span><br><span class="line"><span class="string">Architecture). This includes syncing cloud-side resource updates to the edge, and reporting </span></span><br><span class="line"><span class="string">edge-side host and device status changes to the cloud. EventBus is a MQTT client to interact with MQTT </span></span><br><span class="line"><span class="string">servers (mosquito), offering publish and subscribe capabilities to other components. MetaManager </span></span><br><span class="line"><span class="string">is the message processor between edged and edgehub. It is also responsible for storing/retrieving metadata </span></span><br><span class="line"><span class="string">to/from a lightweight database (SQLite).ServiceBus is a HTTP client to interact with HTTP servers (REST), </span></span><br><span class="line"><span class="string">offering HTTP client capabilities to components of cloud to reach HTTP servers running at edge. `</span>,</span><br><span class="line">        Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            verflag.PrintAndExitIfRequested()</span><br><span class="line">            flag.PrintFlags(cmd.Flags())</span><br><span class="line">            <span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">            klog.Infof(<span class="string">&quot;Version: %+v&quot;</span>, version.Get())</span><br><span class="line">            registerModules()</span><br><span class="line">            <span class="comment">// start all modules</span></span><br><span class="line">            core.Run()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fs := cmd.Flags()</span><br><span class="line">    namedFs := opts.Flags()</span><br><span class="line">    verflag.AddFlags(namedFs.FlagSet(<span class="string">&quot;global&quot;</span>))</span><br><span class="line">    globalflag.AddGlobalFlags(namedFs.FlagSet(<span class="string">&quot;global&quot;</span>), cmd.Name())</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> namedFs.FlagSets &#123;</span><br><span class="line">        fs.AddFlagSet(f)</span><br><span class="line">    &#125;</span><br><span class="line">    usageFmt := <span class="string">&quot;Usage:\n  %s\n&quot;</span></span><br><span class="line">    cols, _, _ := term.TerminalSize(cmd.OutOrStdout())</span><br><span class="line">    cmd.SetUsageFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())</span><br><span class="line">        cliflag.PrintSections(cmd.OutOrStderr(), namedFs, cols)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    cmd.SetHelpFunc(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(cmd.OutOrStdout(), <span class="string">&quot;%s\n\n&quot;</span>+usageFmt, cmd.Long, cmd.UseLine())</span><br><span class="line">        cliflag.PrintSections(cmd.OutOrStdout(), namedFs, cols)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opts := options.NewEdgeCoreOptions()</span><br><span class="line">registerModules()</span><br><span class="line">core.Run()</span><br></pre></td></tr></table></figure>

<h3 id="registerModules"><a href="#registerModules" class="headerlink" title="registerModules"></a>registerModules</h3><p>edgecore仍采用Beehive通信框架，模块调用前先注册对应的模块。</p>
<p><code>edge/cmd/edgecore/app/server.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// registerModules register all the modules started in edgecore</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerModules</span><span class="params">()</span></span> &#123;</span><br><span class="line">    devicetwin.Register()</span><br><span class="line">    edged.Register()</span><br><span class="line">    edgehub.Register()</span><br><span class="line">    eventbus.Register()</span><br><span class="line">    edgemesh.Register()</span><br><span class="line">    metamanager.Register()</span><br><span class="line">    servicebus.Register()</span><br><span class="line">    test.Register()</span><br><span class="line">    dbm.InitDBManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-Run"><a href="#core-Run" class="headerlink" title="core.Run"></a>core.Run</h3><p><code>vendor/github.com/kubeedge/beehive/pkg/core/core.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Run starts the modules and in the end does module cleanup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//Address the module registration and start the core</span></span><br><span class="line">   StartModules()</span><br><span class="line">   <span class="comment">// monitor system signal and shutdown gracefully</span></span><br><span class="line">   GracefulShutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/08/Chrome%E5%8E%9F%E7%90%86%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/Chrome%E5%8E%9F%E7%90%86%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">Chrome原理和HTTP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-08 16:46:16 / 修改时间：17:03:03" itemprop="dateCreated datePublished" datetime="2020-12-08T16:46:16+08:00">2020-12-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、Chrome打开一个页面，为什么会有4个进程"><a href="#1、Chrome打开一个页面，为什么会有4个进程" class="headerlink" title="1、Chrome打开一个页面，为什么会有4个进程"></a>1、Chrome打开一个页面，为什么会有4个进程</h2><p>打开一个页面，至少需要<strong>1个网络进程,1个浏览器进程，1个GPU进程以及1个渲染进程</strong>。</p>
<p>虽然多进程模型提供了浏览器的稳定性、流畅性和安全性，但是带来了更高的资源占用，更复杂的体系结构。</p>
<h2 id="2、TCP协议是如何保证页面文件能被完整送达浏览器的？"><a href="#2、TCP协议是如何保证页面文件能被完整送达浏览器的？" class="headerlink" title="2、TCP协议是如何保证页面文件能被完整送达浏览器的？"></a>2、TCP协议是如何保证页面文件能被完整送达浏览器的？</h2><p>对于在网络中，我们知道一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大的可能会丢失或者出错，保证页面文件完整地送达浏览器是有必要的。</p>
<p>下面就这三方面展开描述：</p>
<ol>
<li><strong>数据包如何送达到主机</strong></li>
<li><strong>主机如何将数据包转交给应用</strong></li>
<li><strong>数据是如何被完整地送达到应用程序</strong></li>
</ol>
<p>数据包从主机A送到主机B，数据包上会附加上主机B的IP地址信息，主机A本身的IP地址，这些附加的信息会被装进一个IP头的数据结构里（包含IP版本，源IP地址，目标IP地址，生存时间等）</p>
<p>这些一般我们都了解，下面主要说明TCP（Transmission Control Protocol），传输控制协议是一种面向连接的，可靠的，基于字节<strong>流</strong>的传输层通信协议，在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。</p>
<p>用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p>
<p>在因特网协议族中，TCP层是位于IP层之上的，TCP-&gt;IP应用层之下的中间层，应用层-&gt;中间层。<strong>不同主机的应用层</strong>之间经常需要<strong>可靠的，像管道一样的连接</strong>，但是IP层不提供这样的流机制，而是提供不可靠的包进行交换。</p>
<p>TCP为了保证不发生丢包的情况，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。接收端实体对已成功收到的包发回一个相应的确认信息（ACK），如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。</p>
<ul>
<li>数据在TCP层称为流</li>
<li>数据分组称为分段</li>
</ul>
<blockquote>
<p>TCP协议的运作：连接创建，数据传送，连接终止。</p>
</blockquote>
<p>那你了解什么是TCP吗？这一点大部分人应该只会说它是一种协议。</p>
<p>TCP传输控制协议是TCP/IP，传输控制协议Internet协议中的主要协议之一，TCP/IP是一套通信协议，用于连接Internet以及大多数其他计算机网络上的主机。</p>
<blockquote>
<p>协议是一种共同商定的用于执行某件事的格式。对于计算机，最常用于指一组规则，使计算机能够相互连接并传输数据，称为通信协议。</p>
</blockquote>
<p>TCP是一种面向连接的协议，它在主机之间建立并维护虚拟连接，直到交换了一条消息或要在其上运行的应用程序交换的消息为止。数据包是TCP/IP网络上数据传输的最基本单位。</p>
<p>TCP在传输层上运行，负责维护整个网络上可靠的端到端通信，IP是网络层协议，它是传输层正下方的层，在传输层运行的有：UDP(用户数据报协议)，RTP(实时传输协议)，SCTP(流控制传输协议)。</p>
<blockquote>
<p>连接创建</p>
</blockquote>
<p>TCP用三次握手过程创建一个连接</p>
<p>三次握手协议的过程：</p>
<p>a.客户端 向 服务器端 发送一个 SYN 包，请求一个主动打开。该包携带客户端为这个连接请求设定的随机数A作为消息列号。</p>
<p>b.服务器端接收到一个SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身携带一个随机产生的序号B。</p>
<p>c.客户端收到SYN/ACK包后，发送一个ACK的包，该包的序号被设定为A+1，而ACK的确认码为B+1。当服务器端收到这个ACK包的时候，把请求帧从SYN队列中移出，放置ACCEPT队列中。</p>
<p>场景：当服务器端接收到客户端发送过来的SYN后， 回了SYN-ACK后，客户端掉线了，服务器端没有收到客户端回来的ACK，那这个连接 就 处于 一个中间状态，没成功也没失败。</p>
<p>但是，服务器端如果在一定时间内没有收到TCP会重新发SYN-ACK</p>
<ul>
<li>主机收到一个TCP包时，用两端的IP地址与端口号来标识这个TCP包属于哪个session。使用一张表来存储所有的session，表中的每条称作TCB（Transmit Control Block）。</li>
<li>TCB结构的定义包含：连接使用的源端口， 目的端口，目的ip， 序号， 应答序号， 对方窗口大小， 已方窗口大小， tcp状态， tcp输入/输出队列， 应用层输出队列， tcp的重传有关变量等。</li>
<li>服务器端的连接数量是无限的，只受内存的限制。</li>
</ul>
<blockquote>
<p>数据传送</p>
</blockquote>
<p>在每个TCP报文段中都有一对<strong>序号和确认号</strong>。</p>
<p>TCP报文发送者称自己的字节流的编号为序号，称接收到对方的字节流编号为确认号。通过使用序号和确认号，TCP层可以把收到的报文段中的字节按正确的顺序交付给应用层。</p>
<p>TCP协议使用序号标识每端发出的字节顺序，从另一端接收数据可以重建顺序，无惧传输的包的乱序交付或丢包。</p>
<p>发送确认包acks，携带接收对方发来的字节流的编号（确认号），告诉对方已经成功接收的数据流的字节位置。</p>
<h2 id="3、HTTP请求流程，为什么很多站点第二次打开速度会很快呢"><a href="#3、HTTP请求流程，为什么很多站点第二次打开速度会很快呢" class="headerlink" title="3、HTTP请求流程，为什么很多站点第二次打开速度会很快呢"></a>3、HTTP请求流程，为什么很多站点第二次打开速度会很快呢</h2><p>HTTP是一种用于分布式，协作式和超媒体信息系统的应用层协议，HTTP是万维网的数据通信的基础。</p>
<p>域名系统DNS是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<p>首先，第一步浏览器会请求DNS返回域名对应的IP，浏览器还提供了DNS数据缓存服务，如果某个域名已经被解析过了，浏览器就会缓存解析的结构，下次查询时直接使用，减少一次网络请求。拿到IP后，就需要获取端口号，如果url没有明确指出端口号，HTTP协议默认是80端口。</p>
<p>到这一步明白的清清楚楚了，IP和端口号。那么让我说说<strong>HTTP协议的描述</strong>，这里补充是为了更好的了解：</p>
<p>HTTP是一个客户端和服务器端之间请求和应答的标准，通常使用TCP协议，通过使用网页浏览器，网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口，默认端口为80。</p>
<p>应答的服务器上存储着一些资源，如HTML文件和图像等，源服务器；（客户端称为用户代理程序），用户代理和源服务器中间可能存在多个”中间层”，比如<strong>代理服务器，网关，隧道</strong>等。</p>
<p>so，HTTP服务器在端口监听客户端的请求，一旦收到请求，服务器会向客户端返回一个状态，如：”HTTP/1.1 200 OK”,以及返回的内容，如请求的文件，错误消息，或者其它消息。</p>
<blockquote>
<p>到这里我先回答一下：浏览器发起HTTP请求流程：1.构建请求(构建请求行信息)；2.查找缓存（浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术）；3.准备IP地址和端口；4.等待TCP队列；5.建立TCP连接；6.发送HTTP请求。</p>
</blockquote>
<p>然后服务器处理请求，服务器返回请求，断开连接。</p>
<p>其实端口和IP地址准备好后，不一定直接建立TCP连接的，因为在Chrome中有个机制，就是<strong>同一个域名同时最多只能建立6个TCP连接</strong>，如果在同一个域名下同时有10个请求发生，那么其中就有4个请求进入排队等待状态。</p>
<p>如果请求数量少于6个，就直接进入建立TCP连接。</p>
<h2 id="4、输入URL到页面展示发生了什么？"><a href="#4、输入URL到页面展示发生了什么？" class="headerlink" title="4、输入URL到页面展示发生了什么？"></a>4、输入URL到页面展示发生了什么？</h2><p>简单地说一下就是：</p>
<ul>
<li>浏览器主进程提交url给网络进程</li>
<li>网络进程请求服务器，返回响应头行体，判断是否需要重定向</li>
<li>网络进程将页面类型的响应资源提交给渲染进程</li>
<li>渲染进程渲染结束，加载完毕</li>
</ul>
<p>分步骤简单来说就是：</p>
<ol>
<li>首先是域名解析</li>
<li>建立TCP请求</li>
<li>建立HTTP请求</li>
<li>服务器处理HTTP请求</li>
<li>关闭TCP连接</li>
<li>浏览器解析资源</li>
<li>浏览器渲染页面</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/kubernetes%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/kubernetes%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">kubernetes命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 19:27:41 / 修改时间：19:28:25" itemprop="dateCreated datePublished" datetime="2020-12-07T19:27:41+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="1、跑一个简单应用"><a href="#1、跑一个简单应用" class="headerlink" title="1、跑一个简单应用"></a>1、跑一个简单应用</h2><p>1）、部署一个应用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run cnntest --image=docker.io/gcc1122/cnn_test:v1 --port=5008</span><br></pre></td></tr></table></figure>

<p>2)、访问应用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment/cnntest --type=&quot;NodePort&quot; --port=5008</span><br><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201123094408309.png" alt="image-20201123094408309"></p>
<p>3)、测试访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:30423</span><br></pre></td></tr></table></figure>

<p>4)、scale 应用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br><span class="line">kubectl scale deployments/cnntest1 --replicas=3 #将副本数增加到3个</span><br><span class="line">kubectl get pods #pods被扩展到三个，访问时负载均衡策略为随机策略</span><br></pre></td></tr></table></figure>

<p><strong>过程分析：</strong></p>
<p>1、kubectl 发送部署请求到API Server</p>
<p>2、API Server通知Controller Manager创建一个deployment资源</p>
<p>3、Scheduler执行调度任务，将两个副本pod分发到k8s-node1和k8s-node2上。</p>
<p>4、k8s-node1和k8s-node2上的kubectl在各自的节点上创建并运行pod。</p>
<h2 id="2、重要概念"><a href="#2、重要概念" class="headerlink" title="2、重要概念"></a>2、重要概念</h2><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>cluster是计算、存储和网络资源的集合，K8s利用这些资源运行各种基于容器的应用。</p>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master是Cluster的大脑，主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node负责监控并汇报容器的状态，同时根据Matser的要求管理容器的生命周期。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>pod是k8s的最小工作单元，每个pod包含一个或多个容器，pod中的容器会作为一个整体被Master调度到一个Node上运行。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>K8s通常不会直接创建pod，而是通过Controller来管理pod的。Controller中定义了pod的部署特性，比如有几个副本、在什么样的Node上运行。为了满足不同的业务场景，k8s提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、Stateful、Job等。</p>
<p>**Deployment:**最常用的Controller,Deployment可以管理pod的多个副本，并确保pod按照期望的状态运行。</p>
<p>**ReplicaSet:**实现了pod的多副本管理。使用Deployment时会自动创建ReplicaSet，也就是说Deployment是通过ReplicaSet来管理pod的多个副本的，我们通常不需要直接使用ReplicaSet。</p>
<p>**DaemonSet:**用于每个Node最多只运行一个pod副本的场景。</p>
<p>**StatefulSet:**能够保证pod的每个副本在整个生命周期中名称是不变的，而其他Controller不提供这个功能。当某个pod发生故障需要删除并重新启动时，pod的名称会发生变化，同时statefulset会保证副本按照固定的顺序启动、更新或者删除。</p>
<p>**job:**用于运行结束就删除的应用，而其他controller中的pod通常是长期持续运行。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Deployment可以部署多个副本，每个pod都有自己的ip，访问这些副本不能通过pod的ip，而是service。K8s service定义了外界访问一组特定的pod的方式。service有自己的ip和端口，servce为pod提供了复杂均衡。</p>
<p>k8s运行容器与访问容器这两项任务分别由controller和service执行</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>多个用户或项目组使用同一个kubernetes Cluster，如何将controller、pod等资源分开呢？</p>
<p>namespace可以将一个物理的Cluster逻辑上划分成多个虚拟cluster，每个cluster就是一个Namespace。不同Namespace里的资源是完全隔离的。</p>
<p><strong>Deployment配置文件简介</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lbphtest-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">lbphtest</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">lbphtest</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lbphtest1</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.io/gcc1122/lbph_test:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>删除deployment</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete deployment nginx 或 kubectl delete -f nging.yml</span><br></pre></td></tr></table></figure>

<p>如果希望将k8s-master也当作Node使用，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node k8s-matser node-role.kubernetes.io/matser-</span><br></pre></td></tr></table></figure>

<p>恢复Matser Only状态，执行如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint node k8s-master node-role.kubernetes.io/master=&quot;&quot;.NoSchedule</span><br></pre></td></tr></table></figure>

<p><strong>Service配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lbphtest-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">lbphtest</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">lbphtest</span></span><br></pre></td></tr></table></figure>

<p>​    nodePort是节点上监听的端口</p>
<p>​    port是Cluster上监听的端口</p>
<p>​    targetPort是Pod监听的端口</p>
<p>最终，Node和ClusterIP在各自端口上接收到的请求都会通过iptables转发到pod的targetPort。</p>
<p>测试是否成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201123110859570.png" alt="image-20201123110859570"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 10.108.152.174:88 #测试是否可连接pod</span><br></pre></td></tr></table></figure>

<p>查看service信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">describe</span> <span class="string">service</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">Name:</span>              <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">Namespace:</span>         <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>            <span class="string">app=nginx</span></span><br><span class="line"><span class="attr">Annotations:       kubectl.kubernetes.io/last-applied-configuration:</span></span><br><span class="line">                     &#123;<span class="string">&quot;apiVersion&quot;</span><span class="string">:&quot;v1&quot;</span>,<span class="string">&quot;kind&quot;</span><span class="string">:&quot;Service&quot;</span>,<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;annotations&quot;</span><span class="string">:</span>&#123;&#125;,<span class="string">&quot;labels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;nginx&quot;</span>&#125;,<span class="string">&quot;name&quot;</span><span class="string">:&quot;nginx-service&quot;</span>,<span class="string">&quot;namespace&quot;</span><span class="string">:&quot;default&quot;</span>&#125;,<span class="string">&quot;s...</span></span><br><span class="line"><span class="string">Selector:          app=nginx</span></span><br><span class="line"><span class="string">Type:              ClusterIP</span></span><br><span class="line"><span class="string">IP:                10.108.152.174</span></span><br><span class="line"><span class="string">Port:              &lt;unset&gt;  88/TCP</span></span><br><span class="line"><span class="string">TargetPort:        80/TCP</span></span><br><span class="line"><span class="string">Endpoints:         10.244.51.20:80</span></span><br><span class="line"><span class="string">Session Affinity:  None</span></span><br><span class="line"><span class="string">Events:            &lt;none&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>EndPoint罗列了一个Pod的IP和端口。</p>
<h4 id="Cluster-IP底层实现原理"><a href="#Cluster-IP底层实现原理" class="headerlink" title="Cluster IP底层实现原理"></a>Cluster IP底层实现原理</h4><p>虚拟ip，是由k8s节点上的iptables规则管理的。iptables将Service的流量转发到后端pod，而且使用类似轮询的负载均衡策略。</p>
<h2 id="3、数据管理"><a href="#3、数据管理" class="headerlink" title="3、数据管理"></a>3、数据管理</h2><p>容器和pod是短暂的，其含义是它们的生命周期可能很短，会被频繁地销毁和创建。容器销毁时，保存在容器内部文件系统中的数据都会被清楚。</p>
<p>为了持久化保存容器的数据，可以使用Kubernetes Volume。</p>
<h2 id="4、Istio"><a href="#4、Istio" class="headerlink" title="4、Istio"></a>4、Istio</h2><p>创建service 和不同版本的deployment。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lbphapp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9010</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lbphapp-v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchlabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lbphapp</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker.io/gcc1122/lbph_test:v1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">version</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">v1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lbphapp-v2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchlabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">lbphapp</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lbphapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.io/gcc1122/lbph_test:v1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">version</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure>

<p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istioctl kube-inject -f lbphapp.istio.yml | kubectl apply -f - #部署service和deployment并注入</span><br><span class="line">kubectl get service #检查service创建成功</span><br><span class="line">kubectl get deployment #检查deployment</span><br><span class="line">kubectl get pod -o wide #检查pod</span><br><span class="line">kubectl describe po pod_name #查看pod详细信息 </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/docker%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/docker%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">docker命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 19:11:29 / 修改时间：19:19:54" itemprop="dateCreated datePublished" datetime="2020-12-07T19:11:29+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><h2 id="docker状态命令"><a href="#docker状态命令" class="headerlink" title="docker状态命令"></a>docker状态命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker #查看状态</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl restart docker #重启</span><br><span class="line">systemctl enable docker #开机自启动</span><br></pre></td></tr></table></figure>

<h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看本地镜像</span><br><span class="line">docker images -q #查看所用镜像的id</span><br><span class="line">docker search redis #搜索镜像</span><br><span class="line">docker pull redis #下载镜像</span><br><span class="line">docker rmi redis:latest #删除镜像</span><br><span class="line">docker build -t cnn_test .</span><br><span class="line">images:显示镜像列表。</span><br><span class="line">history：显示镜像构建历史。</span><br><span class="line">commit:从容器创建新镜像</span><br><span class="line">tag:给镜像打tag</span><br><span class="line">pull:从registry下载镜像</span><br><span class="line">push：将镜像上传到registry</span><br></pre></td></tr></table></figure>

<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name c1 centos:7 /bin/bash</span><br><span class="line">（-i 保持容器运行，通常与-t同时使用，加入it这两个参数后，容器创建后会自动进入容器中，退出容器后，容器自动关闭。</span><br><span class="line">-t :为容器重新分配一个伪输入终端，通常与-i同时使用</span><br><span class="line">-d：以守护（后台）模式运行容器，创建一个容器在后台运行，需要使用docker exec进入容器，退出后，容器不会关闭。</span><br><span class="line">-it:创建的容器一般为交互式容器，-id创建的容器一般称为守护式容器</span><br><span class="line">--name:为创建的容器命名。）</span><br><span class="line">docker ps #查看正在运行的容器</span><br><span class="line">docker ps -a #查看历史的运行的容器</span><br><span class="line">docker rm CONTAINER_NAME #删除容器，删除容器时要确保容器不在运行 docker stop container_name</span><br><span class="line">docker inspect CONTAINER_NAME #查看容器的信息</span><br><span class="line">docker run -itd -p 9000:80 image_name #端口映射</span><br></pre></td></tr></table></figure>

<p><strong>进入容器的方法</strong></p>
<p>我们经常需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。有两种方法进入容器：attach和exec。两者主要区别如下：</p>
<p>1、attach直接进入容器启动命令的终端，不会启动新的进程</p>
<p>2、exec则是在容器中打开新的终端，并且可以启动新的进程。</p>
<p>3、如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec.</p>
<h2 id="docker查看日志记录"><a href="#docker查看日志记录" class="headerlink" title="docker查看日志记录"></a>docker查看日志记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line">Options:</span><br><span class="line">      --details        显示更多的信息</span><br><span class="line">  -f, --follow         跟踪实时日志</span><br><span class="line">      --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）</span><br><span class="line">      --tail string    从日志末尾显示多少行日志， 默认是all</span><br><span class="line">  -t, --timestamps     显示时间戳</span><br><span class="line">      --until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<p>查看最近30分钟的日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since 30m CONTAINER_ID</span><br></pre></td></tr></table></figure>

<p>查看指定时间后的日志，只显示最后100行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --since=&quot;2018-02-08&quot; --tail=100 CONTAINER_ID</span><br></pre></td></tr></table></figure>

<p>查看某时间之后的日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -t --since=&quot;2018-02-08T13:23:37&quot; CONTAINER_ID</span><br></pre></td></tr></table></figure>

<p>查看某时间段日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -t --since=&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID</span><br></pre></td></tr></table></figure>

<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6 #指定base镜像</span><br><span class="line">MAINTAINER：&#x27;gcc&#x27; 303163861@qq.com #指定镜像作者</span><br><span class="line">WORKDIR /usr/src/app #设置工作目录</span><br><span class="line">COPY requirements.txt ./ #将文件从build content复制到镜像</span><br><span class="line">RUN apt-get update #运行命令以安装环境</span><br><span class="line">RUN apt install -y libgl1-mesa-glx</span><br><span class="line">RUN pip install -i https://mirrors.aliyun.com/pypi/simple/ --no-cache-dir -r requirements.txt</span><br><span class="line">COPY py/ /usr/src/app/</span><br><span class="line">VOLUME /usr/src/app #将文件或目录申明为volume</span><br><span class="line">ENTRYPOINT [&quot;python&quot;] #设置容器启动时运行的命令</span><br></pre></td></tr></table></figure>

<h2 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h2><p>docker镜像是以layer概念存在的，一层一层的叠加，最终成为我们需要的镜像。但该镜像的每一层都是ReadOnly的。只有我们运行容器的时候才会创建读写层。文件系统的隔离使得：</p>
<p>​    容器不再运行时，数据将不会持续存在，数据很难从容器中取出。</p>
<p>​    无法在不同主机之间很好的进行数据迁移</p>
<p>​    数据写入容器的读写层需要内核提供联合文件系统，这会额外的降低性能。</p>
<p>docker提供了三种不同的方式将数据挂载到容器中：volume、bind mount、tmpfs.</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201123132602878.png" alt="image-20201123132602878"></p>
<p><strong>volume方式：</strong></p>
<ul>
<li>docker默认在主机上会有一个特定的区域（/var/lib/docker/volumes/linux），该区域用来存放volume。</li>
<li>非docker进程不应该去修改该区域。</li>
<li>volume可以通过docker volume进行管理，如创建、删除等操作。</li>
<li>volume在生成的时候如果不指定名称，便会随机生成。</li>
</ul>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201123133043043.png" alt="image-20201123133043043"></p>
<ul>
<li>volume在容器停止或删除的时候会继续存在，如需删除需要显示声明。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v container_id</span><br><span class="line">docker volume rm volume_name</span><br></pre></td></tr></table></figure>

<p>volume 在 docker 中被推荐为首选方式，它与 bind mount 相比，有以下优点：</p>
<ul>
<li>与 bind mount 相比，volume 更容易备份或迁移。</li>
<li>可以使用 Docker CLI 命令或 Docker API 来管理。</li>
<li>volume 在 Linux 和 Windows 容器上都能工作。</li>
<li>volume 可以在多个容器之间更安全的共享。</li>
<li>volume 驱动程序允许你在远程主机或云上提供存储、加密或其他功能。</li>
<li>新 volume 的内容可以由容器预填充。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls #卷列表</span><br><span class="line">docker volume inspect volume_name #查看卷信息</span><br><span class="line">docker volume rm volume_name #删除卷</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201123133713960.png" alt="image-20201123133713960"></p>
<h2 id="bind-mount方式"><a href="#bind-mount方式" class="headerlink" title="bind mount方式"></a>bind mount方式</h2><p>通过bind mount方式，可以将主机上的任何文件或目录（绝对路径）挂载到容器中。</p>
<ul>
<li>挂载的文件或目录可以被任何进程修改，因此有时候容器中修改了该文件或目录将会影响其他进程。</li>
<li>如果挂载主机的文件或目录不存在将会自动创建。</li>
<li>使用该方式不能通过docker volume管理，推荐使用volume方式。</li>
</ul>
<p>bind mount，一般在以下情况下使用：</p>
<ul>
<li>从主机共享配置文件到容器。默认情况，docker会绑定类似/etc/resolv.conf的文件用于DNS的解析。</li>
<li>主机与容器共享源代码或构建工具。如，可以将Maven target/ 挂载到容器中，并且每次主机上构建Maven项目时，容器都可以访问重建的构件。</li>
<li>主机的文件或目录结构与容器所需的一致时。</li>
</ul>
<p>如果将空文件或目录挂载到容器，容器中的该目录又有文件，那么，这些文件将会被复制到主机上的目录中。如果将非空的文件或目录挂载到容器，容器中的该目录也有文件，那么，容器中的文件将会被隐藏。</p>
<p><strong>-v/-mount标志</strong></p>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line">docker volume ls #查看所有数据卷</span><br><span class="line">docker volume inspect my-vol #查看数据卷的信息</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2020-11-23T18:45:44+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用docker run命令的时候，使用–mount标记来将数据卷挂载到容器里。在一次docker run中可以挂载多个数据卷。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -P \</span></span><br><span class="line"><span class="bash">    --name web \</span></span><br><span class="line"><span class="bash">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span></span><br><span class="line"><span class="bash">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span></span><br><span class="line"><span class="bash">    nginx:alpine</span></span><br></pre></td></tr></table></figure>

<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-vol</span><br><span class="line">docker volume prune #清理数据卷</span><br></pre></td></tr></table></figure>

<h2 id="上传至dockerhub"><a href="#上传至dockerhub" class="headerlink" title="上传至dockerhub"></a>上传至dockerhub</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker tag cnn_reco gcc1122/cnn_reco</span><br><span class="line">docker push gcc1122/cnn_reco</span><br></pre></td></tr></table></figure>

<h2 id="案例流程"><a href="#案例流程" class="headerlink" title="案例流程"></a>案例流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir cnn_reco</span><br><span class="line">cp -rf cnn_test/* /home/cnn_reco</span><br><span class="line">cd /home/cnn_reco</span><br><span class="line">docker build -t cnn_reco .</span><br><span class="line">docker login</span><br><span class="line">docker tag cnn_reco gcc1122/cnn_reco</span><br><span class="line">docker push gcc1122/cnn_reco</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><p>镜像源最好选择阿里的镜像源，清华的镜像源会卡导致失败。</p>
</li>
<li><p>编译依赖应提前下载好</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">java字符串比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 16:18:45 / 修改时间：16:21:20" itemprop="dateCreated datePublished" datetime="2020-12-07T16:18:45+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h1><p>三者都可用来代表字符串。String类是不可变类，任何对String的改变都会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。既然可变和不可变都有了，为何还有一个StringBuilder呢？相信初期的你，在进行append时，一般都会选择StringBuffer吧！</p>
<p>先说一下集合的故事，HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高</p>
<p>贴上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String BASEINFO = <span class="string">&quot;Mr.Y&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">2000000</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行一项String赋值测试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStringTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		String str = <span class="keyword">new</span> String(BASEINFO);</span><br><span class="line">		<span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT / <span class="number">100</span>; i++) &#123;</span><br><span class="line">			str = str + <span class="string">&quot;miss&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">		System.out.println((endtime - starttime)</span><br><span class="line">				+ <span class="string">&quot; millis has costed when used String.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行一项StringBuffer赋值测试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStringBufferTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer(BASEINFO);</span><br><span class="line">		<span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">			sb = sb.append(<span class="string">&quot;miss&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">		System.out.println((endtime - starttime)</span><br><span class="line">				+ <span class="string">&quot; millis has costed when used StringBuffer.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行一项StringBuilder赋值测试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStringBuilderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder(BASEINFO);</span><br><span class="line">		<span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">			sb = sb.append(<span class="string">&quot;miss&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">		System.out.println((endtime - starttime)</span><br><span class="line">				+ <span class="string">&quot; millis has costed when used StringBuilder.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试StringBuffer遍历赋值结果</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mlist</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStringBufferListTest</span><span class="params">(List&lt;String&gt; mlist)</span> </span>&#123;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (String string : mlist) &#123;</span><br><span class="line">			sb.append(string);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(sb.toString() + <span class="string">&quot;buffer cost:&quot;</span></span><br><span class="line">				+ (endtime - starttime) + <span class="string">&quot; millis&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试StringBuilder迭代赋值结果</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mlist</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStringBuilderListTest</span><span class="params">(List&lt;String&gt; mlist)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (Iterator&lt;String&gt; iterator = mlist.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">			sb.append(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">		System.out.println(sb.toString() + <span class="string">&quot;builder cost:&quot;</span></span><br><span class="line">				+ (endtime - starttime) + <span class="string">&quot; millis&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		doStringTest();</span><br><span class="line">		doStringBufferTest();</span><br><span class="line">		doStringBuilderTest();</span><br><span class="line"> </span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">&quot; I &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; like &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; BeiJing &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; tian &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; an &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; men &quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot; . &quot;</span>);</span><br><span class="line"> </span><br><span class="line">		doStringBufferListTest(list);</span><br><span class="line">		doStringBuilderListTest(list);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下执行结果：</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201207160435698.png" alt="image-20201207160435698"></p>
<p>从上面的结果可以看出，不考虑多线程，采用String对象时（我把Count/100），执行时间比其他两个都要高，而采用StringBuffer对象和采用StringBuilder对象的差别也比较明显。由此可见，如果我们的程序是在单线程下运行，或者是不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</p>
<p>从后面List的测试结果可以看出，除了对多线程的支持不一样外，这两个类的使用方式和结果几乎没有任何差别。</p>
<h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();<span class="comment">//初始化空对象</span></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> StringBuffer(<span class="number">512</span>);<span class="comment">//分配了长度512字节的字符缓冲区</span></span><br><span class="line">StringBuffer sb2=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;how are you?&quot;</span>)<span class="comment">//创建带有内容的StringBuffer对象，在字符缓冲区中存放字符串&quot;how are you?&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">    *该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接，调用该方法以后，StringBuffer对象的内容也发生改 变</span></span></span><br><span class="line"><span class="function"><span class="comment">    */</span></span></span><br><span class="line"><span class="function">StringBuffer sb</span>=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="keyword">true</span>);<span class="comment">//对象的值将变成&quot;abctrue&quot;</span></span><br><span class="line"></span><br><span class="line">deleteCharAt方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">*该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function">StringBuffer sb </span>= <span class="keyword">new</span> StringBuffer(“KMing”);</span><br><span class="line">sb. deleteCharAt(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变 为”King”。</span></span><br><span class="line"><span class="comment">//还存在一个功能类似的delete方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。例如：</span></span></span><br><span class="line"><span class="function">StringBuffer sb </span>= <span class="keyword">new</span> StringBuffer(“TestString”);</span><br><span class="line">sb. delete (<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//该代码的作用是删除索引值1(包括)到索引值4(不包括)之间的所有字符，剩余的字符形成新的字符串。则对象sb的值是”TString” </span></span><br><span class="line">insert方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。例如：</span></span></span><br><span class="line"><span class="function">StringBuffer sb </span>= <span class="keyword">new</span> StringBuffer(“TestString”);</span><br><span class="line">sb.insert(<span class="number">4</span>,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”。</span></span><br><span class="line">reverse方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。例如：</span></span></span><br><span class="line"><span class="function">StringBuffer sb </span>= <span class="keyword">new</span> StringBuffer(“abc”);</span><br><span class="line">sb.reverse();</span><br><span class="line"><span class="comment">//经过反转以后，对象sb中的内容将变为”cba”。    </span></span><br><span class="line">setCharAt方法    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span><span class="comment">//该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。例如：</span></span></span><br><span class="line"><span class="function">StringBuffer sb </span>= <span class="keyword">new</span> StringBuffer(“abc”);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,’D’);</span><br><span class="line"><span class="comment">//则对象sb的值将变成”aDc”。     </span></span><br><span class="line">trimToSize方法</span><br><span class="line"><span class="comment">//该方法的作用是将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费，和String的trim()是一样的作用    </span></span><br><span class="line">length方法<span class="comment">//获取字符串长度    </span></span><br><span class="line">setlength方法<span class="comment">//设置字符串缓冲区大小</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.setlength(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//如果用小于当前字符串长度的值调用setlength()方法，则新长度后面的字符将丢失。   sb.capacity方法//该方法作用是获取字符串的容量</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(“string”);</span><br><span class="line"><span class="keyword">int</span> i=sb.capacity(); </span><br><span class="line">ensureCapacity方法</span><br><span class="line"><span class="comment">//该方法的作用是重新设置字符串容量的大小。</span></span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.ensureCapacity(<span class="number">32</span>); <span class="comment">//预先设置sb的容量为32 </span></span><br><span class="line">getChars方法</span><br><span class="line"><span class="comment">//该方法的作用是将字符串的子字符串复制给数组。</span></span><br><span class="line">getChars(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">char</span> chars[],<span class="keyword">int</span> charStart); </span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;I love You&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//注意ch字符数组的长度一定要大于等于begin到end之间字符的长度</span></span><br><span class="line"><span class="comment">//小于的话会报ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//如果大于的话，大于的字符会以空格补齐</span></span><br><span class="line"><span class="keyword">char</span>[] ch  = <span class="keyword">new</span> <span class="keyword">char</span>[end-begin];</span><br><span class="line">sb.getChars(begin, end, ch, <span class="number">0</span>);</span><br><span class="line">System.out.println(ch);</span><br><span class="line">结果：I lov</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">行为型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 10:57:25 / 修改时间：10:58:12" itemprop="dateCreated datePublished" datetime="2020-12-07T10:57:25+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="行为类模式"><a href="#行为类模式" class="headerlink" title="行为类模式"></a>行为类模式</h1><h2 id="1、模板方法模式"><a href="#1、模板方法模式" class="headerlink" title="1、模板方法模式"></a>1、模板方法模式</h2><p><strong>定义：</strong>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图</strong>：</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201119103658090.png" alt="image-20201119103658090"></p>
<p>事实上，模版方法是编程中一个经常用到的模式。先来看一个例子，某日，程序员A拿到一个任务：给定一个整数数组，把数组中的数由小到大排序，然后把排序之后的结果打印出来。经过分析之后，这个任务大体上可分为两部分，排序和打印，打印功能好实现，排序就有点麻烦了。但是A有办法，先把打印功能完成，排序功能另找人做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将数组array由小到大排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showSortResult</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sort(array);</span><br><span class="line">		System.out.print(<span class="string">&quot;排序结果：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;%3s&quot;</span>, array[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 写完后，A找到刚毕业入职不久的同事B说：有个任务，主要逻辑我已经写好了，你把剩下的逻辑实现一下吧。于是把AbstractSort类给B，让B写实现。B拿过来一看，太简单了，10分钟搞定，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSort</span> <span class="keyword">extends</span> <span class="title">AbstractSort</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">			selectSort(array, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> MinValue = <span class="number">32767</span>; <span class="comment">// 最小值变量</span></span><br><span class="line">		<span class="keyword">int</span> indexMin = <span class="number">0</span>; <span class="comment">// 最小值索引变量</span></span><br><span class="line">		<span class="keyword">int</span> Temp; <span class="comment">// 暂存变量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; array.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (array[i] &lt; MinValue)&#123; <span class="comment">// 找到最小值</span></span><br><span class="line">				MinValue = array[i]; <span class="comment">// 储存最小值</span></span><br><span class="line">				indexMin = i; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Temp = array[index]; <span class="comment">// 交换两数值</span></span><br><span class="line">		array[index] = array[indexMin];</span><br><span class="line">		array[indexMin] = Temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写好后交给A，A拿来一运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] a = &#123; <span class="number">10</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span> &#125;; <span class="comment">// 预设数据数组</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		AbstractSort s = <span class="keyword">new</span> ConcreteSort();</span><br><span class="line">		s.showSortResult(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p>排序结果： 0 1 3 4 5 7 9 10 12 32   </p>
<p>运行正常。行了，任务完成。没错，这就是模版方法模式。大部分刚步入职场的毕业生应该都有类似B的经历。一个复杂的任务，由公司中的牛人们将主要的逻辑写好，然后把那些看上去比较简单的方法写成抽象的，交给其他的同事去开发。这种分工方式在编程人员水平层次比较明显的公司中经常用到。比如一个项目组，有架构师，高级工程师，初级工程师，则一般由架构师使用大量的接口、抽象类将整个系统的逻辑串起来，实现的编码则根据难度的不同分别交给高级工程师和初级工程师来完成。怎么样，是不是用到过模版方法模式？</p>
<p><strong>模版方法模式的结构</strong></p>
<p>​    模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：</p>
<ul>
<li><strong>抽象方法：</strong>父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</li>
<li><strong>模版方法：</strong>由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。</li>
<li><strong>钩子方法：</strong>由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。</li>
<li>抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。</li>
</ul>
<p>​    实现类用来实现细节。抽象类中的模版方法正是通过实现类扩展的方法来完成业务逻辑。只要实现类中的扩展方法通过了单元测试，在模版方法正确的前提下，整体功能一般不会出现大的错误。</p>
<p><strong>模版方法的优点及适用场景</strong></p>
<p>​    容易扩展。一般来说，抽象类中的模版方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。</p>
<p>​    便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。</p>
<p>​    比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。</p>
<p>​    在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</p>
<h2 id="2、中介者模式"><a href="#2、中介者模式" class="headerlink" title="2、中介者模式"></a>2、中介者模式</h2><p><strong>定义：</strong>用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201118095325521.png" alt="image-20201118095325521"></p>
<p><strong>中介者模式的结构：</strong></p>
<p>​    中介者模式又称为调停者模式，从类图中看，共分为三部分：</p>
<p>​    抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。</p>
<p>​    中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同事类。</p>
<p>​    同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。</p>
<p><strong>为什么要使用中介者模式</strong></p>
<p>​    一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201118100213816.png" alt="image-20201118100213816"></p>
<p>​    如果引入中介者模式，那么同事类之间的关系将变为星型结构，从图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201118100306012.png" alt="image-20201118100306012"></p>
<p>​    我们使用一个例子来说明一下什么是同事类：有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//抽象方法，修改数字时同时修改关联对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		coll.setNumber(number*<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		coll.setNumber(number/<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">		AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">		AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;==========设置A影响B==========&quot;</span>);</span><br><span class="line">		collA.setNumber(<span class="number">1288</span>, collB);</span><br><span class="line">		System.out.println(<span class="string">&quot;collA的number值：&quot;</span>+collA.getNumber());</span><br><span class="line">		System.out.println(<span class="string">&quot;collB的number值：&quot;</span>+collB.getNumber());</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">&quot;==========设置B影响A==========&quot;</span>);</span><br><span class="line">		collB.setNumber(<span class="number">87635</span>, collA);</span><br><span class="line">		System.out.println(<span class="string">&quot;collB的number值：&quot;</span>+collB.getNumber());</span><br><span class="line">		System.out.println(<span class="string">&quot;collA的number值：&quot;</span>+collA.getNumber());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，类A类B通过直接的关联发生关系，假如我们要使用中介者模式，类A类B之间则不可以直接关联，他们之间必须要通过一个中介者来达到关联的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注意这里的参数不再是同事类，而是一个中介者</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		am.AaffectB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		am.BaffectA();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> AbstractColleague A;</span><br><span class="line">	<span class="keyword">protected</span> AbstractColleague B;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractMediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line">		A = a;</span><br><span class="line">		B = b;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> <span class="keyword">extends</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//处理A对B的影响</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = A.getNumber();</span><br><span class="line">		B.setNumber(number*<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//处理B对A的影响</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = B.getNumber();</span><br><span class="line">		A.setNumber(number/<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">		AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line">		</span><br><span class="line">		AbstractMediator am = <span class="keyword">new</span> Mediator(collA, collB);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;==========通过设置A影响B==========&quot;</span>);</span><br><span class="line">		collA.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">		System.out.println(<span class="string">&quot;collA的number值为：&quot;</span>+collA.getNumber());</span><br><span class="line">		System.out.println(<span class="string">&quot;collB的number值为A的10倍：&quot;</span>+collB.getNumber());</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">&quot;==========通过设置B影响A==========&quot;</span>);</span><br><span class="line">		collB.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">		System.out.println(<span class="string">&quot;collB的number值为：&quot;</span>+collB.getNumber());</span><br><span class="line">		System.out.println(<span class="string">&quot;collA的number值为B的0.1倍：&quot;</span>+collA.getNumber());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然代码比较长，但是还是比较容易理解的，其实就是把原来处理对象关系的代码重新封装到一个中介类中，通过这个中介类来处理对象间的关系。</p>
<p><strong>中介者模式的优点</strong></p>
<ul>
<li>适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。</li>
<li>使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。</li>
<li>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>​    在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。</p>
<p>​    中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂。</p>
<h2 id="3、观察者模式"><a href="#3、观察者模式" class="headerlink" title="3、观察者模式"></a>3、观察者模式</h2><p><strong>定义：</strong>定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201119104726273.png" alt="image-20201119104726273"></p>
<p> 在软件系统中经常会有这样的需求：如果一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。比如，我们要设计一个右键菜单的功能，只要在软件的有效区域内点击鼠标右键，就会弹出一个菜单；再比如，我们要设计一个自动部署的功能，就像eclipse开发时，只要修改了文件，eclipse就会自动将修改的文件部署到服务器中。这两个功能有一个相似的地方，那就是一个对象要时刻监听着另一个对象，只要它的状态一发生改变，自己随之要做出相应的行动。其实，能够实现这一点的方案很多，但是，无疑使用观察者模式是一个主流的选择。</p>
<p><strong>观察者模式的结构</strong></p>
<p>在最基础的观察者模式中，包括以下四个角色：</p>
<ul>
<li><strong>被观察者：</strong>从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</li>
<li><strong>观察者：</strong>观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。</li>
<li><strong>具体的被观察者：</strong>使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。</li>
<li><strong>具体的观察者：</strong>观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。</li>
</ul>
<p><strong>观察者模式代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Vector&lt;Observer&gt; obs = <span class="keyword">new</span> Vector&lt;Observer&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer obs)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.obs.add(obs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer obs)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.obs.remove(obs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Observer o: obs)&#123;</span><br><span class="line">			o.update();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;被观察者事件反生&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.notifyObserver();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;观察者1收到信息，并进行处理。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;观察者2收到信息，并进行处理。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Subject sub = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">		sub.addObserver(<span class="keyword">new</span> ConcreteObserver1()); <span class="comment">//添加观察者1</span></span><br><span class="line">		sub.addObserver(<span class="keyword">new</span> ConcreteObserver2()); <span class="comment">//添加观察者2</span></span><br><span class="line">		sub.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>被观察者事件反生</p>
<p>观察者1收到信息，并进行处理。</p>
<p>观察者2收到信息，并进行处理。</p>
<p>​    通过运行结果可以看到，我们只调用了Subject的方法，但同时两个观察者的相关方法都被同时调用了。仔细看一下代码，其实很简单，无非就是在Subject类中关联一下Observer类，并且在doSomething方法中遍历一下Observer的update方法就行了。</p>
<p><strong>观察者模式的优点</strong></p>
<p>​    观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</p>
<p>​    观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。</p>
<p><strong>总结：</strong></p>
<p>​     java语言中，有一个接口Observer，以及它的实现类Observable，对观察者角色常进行了实现。我们可以在jdk的api文档具体查看这两个类的使用方法。</p>
<p>​    做过VC++、javascript DOM或者AWT开发的朋友都对它们的事件处理感到神奇，了解了观察者模式，就对事件处理机制的原理有了一定的了解了。如果要设计一个事件触发处理机制的功能，使用观察者模式是一个不错的选择，AWT中的事件处理DEM（委派事件模型Delegation Event Model）就是使用观察者模式实现的。</p>
<h2 id="4、访问者模式"><a href="#4、访问者模式" class="headerlink" title="4、访问者模式"></a>4、访问者模式</h2><p><strong>定义：</strong>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201119102557323.png" alt="image-20201119102557323"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">		b.showA(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">		a.method1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们主要来看一下在类A中，方法method1和方法method2的区别在哪里，方法method1很简单，就是打印出一句“我是A”；方法method2稍微复杂一点，使用类B作为参数，并调用类B的showA方法。再来看一下类B的showA方法，showA方法使用类A作为参数，然后调用类A的method1方法，可以看到，method2方法绕来绕去，无非就是调用了一下自己的method1方法而已，它的运行结果应该也是“我是A”，分析完之后，我们来运行一下这两个方法，并看一下运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.method1();</span><br><span class="line">		a.method2(<span class="keyword">new</span> B());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p>我是A<br>我是A  </p>
<p>看懂了这个例子，就理解了访问者模式的90%，在例子中，对于类A来说，类B就是一个访问者。但是这个例子并不是访问者模式的全部，虽然直观，但是它的可扩展性比较差，下面我们就来说一下访问者模式的通用实现，通过类图可以看到，在访问者模式中，主要包括下面几个角色：</p>
<ul>
<li><p> <strong>抽象访问者：</strong>抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</p>
</li>
<li><p><strong>访问者：</strong>实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</p>
</li>
<li><p><strong>抽象元素类：</strong>接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</p>
</li>
<li><p><strong>元素类：</strong>实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</p>
</li>
<li><p><strong>结构对象：</strong>一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。</p>
<p>访问者模式的通用代码实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IVisitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是元素1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span> </span>&#123;</span><br><span class="line">		visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是元素2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span> </span>&#123;</span><br><span class="line">		visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> <span class="keyword">implements</span> <span class="title">IVisitor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 el1)</span> </span>&#123;</span><br><span class="line">		el1.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 el2)</span> </span>&#123;</span><br><span class="line">		el2.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStruture</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Element&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">		Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> a = ran.nextInt(<span class="number">100</span>);</span><br><span class="line">			<span class="keyword">if</span>(a&gt;<span class="number">50</span>)&#123;</span><br><span class="line">				list.add(<span class="keyword">new</span> ConcreteElement1());</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				list.add(<span class="keyword">new</span> ConcreteElement2());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		List&lt;Element&gt; list = ObjectStruture.getList();</span><br><span class="line">		<span class="keyword">for</span>(Element e: list)&#123;</span><br><span class="line">			e.accept(<span class="keyword">new</span> Visitor());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问者模式的优点</strong></p>
<ul>
<li><strong>符合单一职责原则：</strong>凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</li>
<li><strong>扩展性良好：</strong>元素类可以通过接受不同的访问者来实现对不同操作的扩展。</li>
</ul>
<p> <strong>访问者模式的适用场景</strong></p>
<p>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</p>
<p>​    假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</p>
<p>​    但是，访问者模式并不是那么完美，它也有着致命的缺陷：增加新的元素类比较困难。通过访问者模式的代码可以看到，在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素类的数据已经基本确定下来不会变了，会变的只是这些元素内的相关操作，这时候，我们可以使用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改各个元素类的情况下，对原有功能进行修改。</p>
<p><strong>总结</strong></p>
<p>正如《设计模式》的作者GoF对访问者模式的描述：大多数情况下，你并需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。当然这只是针对真正的大牛而言。在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，而往往只是想展示一下自己对面向对象设计的驾驭能力。编程时有这种心理，往往会发生滥用设计模式的情况。所以，在学习设计模式时，一定要理解模式的适用性。必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。</p>
<h2 id="5、命令模式"><a href="#5、命令模式" class="headerlink" title="5、命令模式"></a>5、命令模式</h2><p><strong>定义：</strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>
<p>**类型:**行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201117105749392.png" alt="image-20201117105749392"></p>
<p><strong>命令模式的结构</strong></p>
<p>命令模式就是对命令的封装，首先来看一下命令模式类图中的基本结构：</p>
<p>​    <strong>command类：</strong>是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。</p>
<p>​    <strong>ConcreteCommand类：</strong>Command类的实现类，对抽象类中声明的方法进行实现。</p>
<p>​    <strong>Client类：</strong>最终的客户端调用类。</p>
<p>以上三个类的作用应该是比较好理解的，下面我们重点说一下Invoker类和Recevier类。</p>
<p>​    <strong>Invoker类：</strong>调用者，负责调用命令。</p>
<p>​    <strong>Receiver类：</strong>接收者，负责接收命令并且执行命令。</p>
<p>所谓对命令的封装，说白了，无非就是把一系列的操作写到一个方法中，然后供客户端调用就行了，反映到类图上，只需要一个ConcreteCommand类和Client类就可以完成对命令的封装，即使再进一步，为了增加灵活性，可以再增加一个Command类进行适当地抽象，这个调用者和接收者到底是什么作用呢？</p>
<p>​    其实大家可以换一个角度去想：假如仅仅是简单地把一些操作封装起来作为一条命令供别人调用，怎么能称为一种模式呢？命令模式作为一种行为类模式，首先要做到低耦合，耦合度低了才能提高灵活性，而加入调用者和接收者两个角色的目的也正是为此。命令模式的通用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Command command;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.command = command;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.command.execute();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Receiver receiver;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.receiver.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;接受者-业务逻辑处理&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">		Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">		<span class="comment">//客户端直接执行具体命令方式（此方式与类图相符）</span></span><br><span class="line">		command.execute();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//客户端通过调用者来执行命令</span></span><br><span class="line">		Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">		invoker.setCommand(command);</span><br><span class="line">		invoker.action();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码我们可以看到，当我们调用时，执行的时序首先是调用者类，然后是命令类，最后是接收者类。也就是说一条命令的执行被分成了三步，它的耦合度要比把所有的操作都封装到一个类中要低的多，而这也正是命令模式的精髓所在：把命令的调用者与执行者分开，使双方不必关心对方是如何操作的。</p>
<p><strong>命令模式的优缺点：</strong></p>
<p> 首先，命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。比如有一组文件操作的命令：新建文件、复制文件、删除文件。如果把这三个操作都封装成一个命令类，客户端只需要知道有这三个命令类即可，至于命令类中封装好的逻辑，客户端则无需知道。</p>
<p>​    其次，命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好。比如，文件的操作中，我们需要增加一个剪切文件的命令，则只需要把复制文件和删除文件这两个命令组合一下就行了，非常方便。</p>
<p>​    最后说一下命令模式的缺点，那就是命令如果很多，开发起来就要头疼了。特别是很多简单的命令，实现起来就几行代码的事，而使用命令模式的话，不用管命令多简单，都需要写一个命令类来封装。</p>
<p><strong>命令模式的适用场景：</strong></p>
<p>对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。</p>
<p><strong>总结：</strong></p>
<p>对于一个场合到底用不用模式，这对所有的开发人员来说都是一个很纠结的问题。有时候，因为预见到需求上会发生的某些变化，为了系统的灵活性和可扩展性而使用了某种设计模式，但这个预见的需求偏偏没有，相反，没预见到的需求倒是来了不少，导致在修改代码的时候，使用的设计模式反而起了相反的作用，以至于整个项目组怨声载道。这样的例子，我相信每个程序设计者都遇到过。所以，基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。</p>
<p>​    拿命令模式来说吧，我们开发中，请求-响应模式的功能非常常见，一般来说，我们会把对请求的响应操作封装到一个方法中，这个封装的方法可以称之为命令，但不是命令模式。到底要不要把这种设计上升到模式的高度就要另行考虑了，因为，如果使用命令模式，就要引入调用者、接收者两个角色，原本放在一处的逻辑分散到了三个类中，设计时，必须考虑这样的代价是否值得。</p>
<h2 id="6、责任链模式"><a href="#6、责任链模式" class="headerlink" title="6、责任链模式"></a>6、责任链模式</h2><p><strong>定义：</strong>使每个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201118092231462.png" alt="image-20201118092231462"></p>
<p>首先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i, Request request)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">		Handler1.response(request);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">		Handler2.response(request);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">		Handler3.response(request);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">		Handler4.response(request);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Handler5.response(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的业务逻辑是这样的，方法有两个参数：整数i和一个请求request，根据i的值来决定由谁来处理request，如果i==1，由Handler1来处理，如果i==2，由Handler2来处理，以此类推。在编程中，这种处理业务的方法非常常见，所有处理请求的类有if…else…条件判断语句连成一条责任链来对请求进行处理，相信大家都经常用到。这种方法的优点是非常直观，简单明了，并且比较容易维护，但是这种方法也存在着几个比较令人头疼的问题：</p>
<ul>
<li><strong>代码臃肿：</strong>实际应用中的判定条件通常不是这么简单地判断是否为1或者是否为2，也许需要复杂的计算，也许需要查询数据库等等，这就会有很多额外的代码，如果判断条件再比较多，那么这个if…else…语句基本上就没法看了。</li>
<li><strong>耦合度高：</strong>如果我们想继续添加处理请求的类，那么就要继续添加else if判定条件；另外，这个条件判定的顺序也是写死的，如果想改变顺序，那么也只能修改这个条件语句。</li>
</ul>
<p>​    既然缺点我们已经清楚了，就要想办法来解决。这个场景的业务逻辑很简单：如果满足条件1，则由Handler1来处理，不满足则向下传递；如果满足条件2，则由Handler2来处理，不满足则继续向下传递，以此类推，直到条件结束。其实改进的方法也很简单，就是把判定条件的部分放到处理类中，这就是责任连模式的原理。</p>
<p><strong>责任链模式：</strong></p>
<p>​    责任链模式的类图非常简单，由一个抽象处理类和它的一组实现类组成。</p>
<p><strong>抽象处理类：</strong>抽象处理类中主要包含下一处理类的成员变量nextHandler和一个处理请求的方法handRequest,handRequest方法的主要思想是，如果满足处理的条件，则由本处理类来进行处理，否则由nextHandler来处理。</p>
<p><strong>具体处理类：</strong>具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。</p>
<p>看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Level</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.level = level;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">above</span><span class="params">(Level level)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.level &gt;= level.level)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">	Level level;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(Level level)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.level = level;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Level <span class="title">getLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> level;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Handler nextHandler;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Response <span class="title">handleRequest</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">		Response response = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.getHandlerLevel().above(request.getLevel()))&#123;</span><br><span class="line">			response = <span class="keyword">this</span>.response(request);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.nextHandler != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">this</span>.nextHandler.handleRequest(request);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-----没有合适的处理器-----&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler handler)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.nextHandler = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Response <span class="title">response</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Level(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----请求由处理器1进行处理-----&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Level(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----请求由处理器2进行处理-----&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler3</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Level <span class="title">getHandlerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Level(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----请求由处理器3进行处理-----&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">		Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">		Handler handler3 = <span class="keyword">new</span> ConcreteHandler3();</span><br><span class="line"> </span><br><span class="line">		handler1.setNextHandler(handler2);</span><br><span class="line">		handler2.setNextHandler(handler3);</span><br><span class="line">		</span><br><span class="line">		Response response = handler1.handleRequest(<span class="keyword">new</span> Request(<span class="keyword">new</span> Level(<span class="number">4</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码中Level类是模拟判定条件；Request，Response分别对应请求和响应；抽象类Handler中主要进行条件的判断，这里模拟一个处理等级，只有处理类的处理等级高于Request的等级才能处理，否则交给下一个处理者处理。在Client类中设置好链的前后执行关系，执行时将请求交给第一个处理类，这就是责任连模式，它完成的功能与前文中的if…else…语句是一样的。</p>
<p><strong>责任链模式的优缺点</strong></p>
<p>​    责任链模式与if…else…相比，他的耦合性要低一些，因为它把条件判定都分散到了各个处理类中，并且这些处理类的优先处理顺序可以随意设定。责任链模式也有缺点，这与if…else…语句的缺点是一样的，那就是在找到正确的处理类之前，所有的判定条件都要被执行一遍，当责任链比较长时，性能问题比较严重。</p>
<p><strong>责任链模式的适用场景</strong></p>
<p>​    就像开始的例子那样，假如使用if…else…语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。</p>
<p><strong>总结</strong></p>
<p>​    责任链模式其实就是一个灵活版的if…else…语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。</p>
<h2 id="7、策略模式"><a href="#7、策略模式" class="headerlink" title="7、策略模式"></a>7、策略模式</h2><p><strong>定义：</strong>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201120095902190.png" alt="image-20201120095902190"></p>
<p>策略模式是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。在前面说过的行为类模式中，有一种模式也是关注对算法的封装——模版方法模式，对照类图可以看到，策略模式与模版方法模式的区别仅仅是多了一个单独的封装类Context，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码，因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子。</p>
<p><strong>策略模式的结构</strong></p>
<p>​    <strong>封装类：</strong>也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。</p>
<p>​    <strong>抽象策略：</strong>通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模板方法模式。</p>
<p>​    <strong>具体策略：</strong>具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。</p>
<p><strong>策略模式代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;具体策略1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;具体策略2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IStrategy strategy;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(IStrategy strategy)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">		strategy.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Context context;</span><br><span class="line">		System.out.println(<span class="string">&quot;-----执行策略1-----&quot;</span>);</span><br><span class="line">		context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategy1());</span><br><span class="line">		context.execute();</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">&quot;-----执行策略2-----&quot;</span>);</span><br><span class="line">		context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategy2());</span><br><span class="line">		context.execute();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>策略模式的优缺点：</strong></p>
<p>策略模式的主要优点有：</p>
<ul>
<li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。</li>
<li>避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。</li>
</ul>
<p>​    策略模式的缺点主要有两个：</p>
<ul>
<li>维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。</li>
<li>必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>​    策略模式实质上就是面向对象中的继承和多态。一般来说策略模式通常与模板方法模式、工厂模式等混合使用的情况比较多。</p>
<h2 id="8、迭代器模式"><a href="#8、迭代器模式" class="headerlink" title="8、迭代器模式"></a>8、迭代器模式</h2><p><strong>定义：</strong>提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201120100854167.png" alt="image-20201120100854167"></p>
<p>如果要问java中使用最多的一种模式，答案不是单例模式，也不是工厂模式，更不是策略模式，而是迭代器模式，先来看一段代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection coll)</span></span>&#123;</span><br><span class="line">	Iterator it = coll.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		String str = (String)it.next();</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个方法的作用是循环打印一个字符串集合，里面就用到了迭代器模式，java语言已经完整地实现了迭代器模式，Iterator翻译成汉语就是迭代器的意思。提到迭代器，首先它是与集合相关的，集合也叫聚集、容器等，我们可以将集合看成是一个可以包容对象的容器，例如List，Set，Map，甚至数组都可以叫做集合，而迭代器的作用就是把容器中的对象一个一个地遍历出来。</p>
<p><strong>迭代器模式的结构：</strong></p>
<p>​    <strong>抽象容器：</strong>一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。</p>
<p>​    <strong>具体容器：</strong>就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等</p>
<p>​    <strong>抽象迭代器：</strong>定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove()。</p>
<p>​    <strong>迭代器实现：</strong>实现迭代器接口中定义的方法，完成集合的迭代。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> cursor =<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(cursor==list.size())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object obj = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">			obj = <span class="keyword">this</span>.list.get(cursor++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		list.add(obj);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(list);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		list.remove(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">		ag.add(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">		ag.add(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">		ag.add(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">		Iterator it = ag.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			String str = (String)it.next();</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面的代码中，Aggregate是容器类接口，大家可以想象一下Collection,List，Set等，Aggregate就是他们的简化版，容器类接口中主要有三个方法：添加对象方法add、删除对象方法remove、取得迭代器对象方法next，判断是否迭代完成方法hasNext。</p>
<p><strong>迭代器模式的优缺点</strong></p>
<p> 迭代器模式的优点有：</p>
<ul>
<li>简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</li>
<li>可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</li>
<li>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</li>
</ul>
<p>​    迭代器模式的缺点：</p>
<ul>
<li>对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。</li>
</ul>
<p><strong>迭代器模式的适用场景</strong></p>
<p>​    迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，</p>
<p>就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。</p>
<p>​    但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。</p>
<h2 id="9、解释器模式"><a href="#9、解释器模式" class="headerlink" title="9、解释器模式"></a>9、解释器模式</h2><p><strong>定义：</strong>给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。</p>
<p><strong>类型：</strong>行为类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201119094914257.png" alt="image-20201119094914257"></p>
<p>解释器模式是一个比较少用的模式。</p>
<p><strong>解释器模式的结构：</strong></p>
<p>​    <strong>抽象解释器：</strong>声明一个所有具体表达式都要实现的抽象接口，接口中主要是一个interpret()方法</p>
<p>，称为解释操作。具体解释任务由他的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。</p>
<p>​    <strong>终结符表达式：</strong>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</p>
<p>​    <strong>非终结符表达式：</strong>文法中的每条规则对应于一个非终结表达式，非终结表达式一般是文法中的运算符或其他关键字，比如公式R=R1+R2，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p>
<p>​    <strong>环境角色：</strong>这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(Expression...expressions)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">interpreter</span><span class="params">(Context ctx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String expression = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">char</span>[] charArray = expression.toCharArray();</span><br><span class="line">		Context ctx = <span class="keyword">new</span> Context();</span><br><span class="line">		Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;Expression&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charArray.length;i++)&#123;</span><br><span class="line">			<span class="comment">//进行语法判断，递归调用</span></span><br><span class="line">		&#125;</span><br><span class="line">		Expression exp = stack.pop();</span><br><span class="line">		exp.interpreter(ctx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    文法递归的代码部分需要根据具体的情况来实现，因此在代码中没有体现。抽象表达式是生成语法集合的关键，每个非终结符表达式解释一个最小的语法单元，然后通过递归的方式将这些语法单元组合成完整的文法，这就是解释器模式。</p>
<p><strong>解释器模式的优缺点</strong></p>
<p>​    解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。</p>
<p>​    但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，由于采用递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。</p>
<p><strong>解释器模式的适用场景</strong></p>
<p>在以下情况下可以使用解释器模式：</p>
<ul>
<li>有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释。</li>
<li>一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c<em>d，有时是a</em>b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。</li>
</ul>
<p><strong>注意事项</strong></p>
<p>解释器模式真的是一个比较少用的模式，因为对它的维护实在是太麻烦了，想象一下，一坨一坨的非终结符解释器，假如不是事先对文法的规则了如指掌，或者是文法特别简单，则很难读懂它的逻辑。解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。</p>
<h2 id="10、备忘录模式"><a href="#10、备忘录模式" class="headerlink" title="10、备忘录模式"></a>10、备忘录模式</h2><p><strong>定义：</strong>在不破坏封装下的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以将该对象恢复到原先保存的状态。</p>
<p><strong>类型：</strong>行为类</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201120102342782.png" alt="image-20201120102342782"></p>
<p>我们在编程的时候，经常需要保存对象的中间状态，当需要的时候，可以恢复到这个状态。比如，我们使用Eclipse进行编程时，假如编写失误（例如不小心误删除了几行代码），我们希望返回删除前的状态，便可以使用Ctrl+Z来进行返回。这时我们便可以使用备忘录模式来实现。</p>
<p><strong>备忘录模式的结构</strong></p>
<p>​    <strong>发起人：</strong>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</p>
<p>​    <strong>备忘录：</strong>负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p>
<p>​    <strong>管理角色：</strong>对备忘录进行管理，保存和提供备忘录。</p>
<p><strong>通用代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(memento.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Memento memento;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memento;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.memento = memento;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">		originator.setState(<span class="string">&quot;状态1&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;初始状态:&quot;</span>+originator.getState());</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">		caretaker.setMemento(originator.createMemento());</span><br><span class="line">		originator.setState(<span class="string">&quot;状态2&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;改变后状态:&quot;</span>+originator.getState());</span><br><span class="line">		originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复后状态:&quot;</span>+originator.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码演示了一个单状态单备份的例子，逻辑非常简单：Originator类中的state变量需要备份，以便在需要的时候恢复；Memento类中，也有一个state变量，用来存储Originator类中state变量的临时状态；而Caretaker类就是用来管理备忘录类的，用来向备忘录对象中写入状态或者取回状态。</p>
<p><strong>多状态多备份备忘录：</strong></p>
<p>通用代码演示的例子中，Originator类只有一个state变量需要备份，而通常情况下，发起人角色通常是一个javaBean，对象中需要备份的变量不止一个，需要备份的状态也不止一个，这就是多状态多备份备忘录。实现备忘录的方法很多，备忘录模式有很多变形和处理方式，像通用代码那样的方式一般不会用到，多数情况下的备忘录模式，是多状态多备份的。其实实现多状态多备份也很简单，最常用的方法是，我们在Memento中增加一个Map容器来存储所有的状态，在Caretaker类中同样使用一个Map容器才存储所有的备份。下面我们给出一个多状态多备份的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String state2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String state3 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState1</span><span class="params">(String state1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state1 = state1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState2</span><span class="params">(String state2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state2 = state2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState3</span><span class="params">(String state3)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state3 = state3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(BeanUtils.backupProp(<span class="keyword">this</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">		BeanUtils.restoreProp(<span class="keyword">this</span>, memento.getStateMap());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;state1=&quot;</span>+state1+<span class="string">&quot;state2=&quot;</span>+state2+<span class="string">&quot;state3=&quot;</span>+state3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; stateMap;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateMap = map;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getStateMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stateMap;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateMap</span><span class="params">(Map&lt;String, Object&gt; stateMap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateMap = stateMap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">backupProp</span><span class="params">(Object bean)</span></span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());</span><br><span class="line">			PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">			<span class="keyword">for</span>(PropertyDescriptor des: descriptors)&#123;</span><br><span class="line">				String fieldName = des.getName();</span><br><span class="line">				Method getter = des.getReadMethod();</span><br><span class="line">				Object fieldValue = getter.invoke(bean, <span class="keyword">new</span> Object[]&#123;&#125;);</span><br><span class="line">				<span class="keyword">if</span>(!fieldName.equalsIgnoreCase(<span class="string">&quot;class&quot;</span>))&#123;</span><br><span class="line">					result.put(fieldName, fieldValue);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreProp</span><span class="params">(Object bean, Map&lt;String, Object&gt; propMap)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());</span><br><span class="line">			PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">			<span class="keyword">for</span>(PropertyDescriptor des: descriptors)&#123;</span><br><span class="line">				String fieldName = des.getName();</span><br><span class="line">				<span class="keyword">if</span>(propMap.containsKey(fieldName))&#123;</span><br><span class="line">					Method setter = des.getWriteMethod();</span><br><span class="line">					setter.invoke(bean, <span class="keyword">new</span> Object[]&#123;propMap.get(fieldName)&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Memento&gt; memMap = <span class="keyword">new</span> HashMap&lt;String, Memento&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(String index)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memMap.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(String index, Memento memento)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.memMap.put(index, memento);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Originator ori = <span class="keyword">new</span> Originator();</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">		ori.setState1(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">		ori.setState2(<span class="string">&quot;强盛&quot;</span>);</span><br><span class="line">		ori.setState3(<span class="string">&quot;繁荣&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;===初始化状态===\n&quot;</span>+ori);</span><br><span class="line">		</span><br><span class="line">		caretaker.setMemento(<span class="string">&quot;001&quot;</span>,ori.createMemento());</span><br><span class="line">		ori.setState1(<span class="string">&quot;软件&quot;</span>);</span><br><span class="line">		ori.setState2(<span class="string">&quot;架构&quot;</span>);</span><br><span class="line">		ori.setState3(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;===修改后状态===\n&quot;</span>+ori);</span><br><span class="line">		</span><br><span class="line">		ori.restoreMemento(caretaker.getMemento(<span class="string">&quot;001&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;===恢复后状态===\n&quot;</span>+ori);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备忘录模式的优缺点和适用场景：</strong></p>
<p>备忘录模式的优点有：</p>
<ul>
<li>当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。</li>
<li>备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。</li>
</ul>
<p>备忘录模式的缺点：</p>
<ul>
<li>在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。</li>
</ul>
<p>如果有需要提供回滚操作的需求，使用备忘录模式非常适合，比如jdbc的事务操作，文本编辑器的Ctrl+Z恢复等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">创建型模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 10:57:06 / 修改时间：10:57:59" itemprop="dateCreated datePublished" datetime="2020-12-07T10:57:06+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h2><p><strong>定义：</strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116132235343.png" alt="image-20201116132235343"></p>
<p>单例模式是23种设计模式中最简单的一种模式。有以下几个要素：</p>
<p>​    私有的构造方法</p>
<p>​    指向自己实例的私有静态引用</p>
<p>​    以自己实例为返回值的静态的公有的方法</p>
<p><strong>饿汉式单例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">			singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单例模式的优点：</strong></p>
<p>​    在内存中只有一个对象，节省内存空间</p>
<p>​    避免频繁的创建销毁对象，可以提高性能</p>
<p>​    避免对共享资源的多重占用</p>
<p>​    可以全局访问</p>
<p><strong>适用场景：</strong>由于单例模式以上的优点，所以是编程中用的比价多多的一种设计模式。我总结了一下我所知道的适合使用单例模式的场景：</p>
<ul>
<li>需要频繁实例化然后销毁的对象。</li>
<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</li>
<li>有状态的工具类对象。</li>
<li>频繁访问数据库或文件的对象。</li>
<li>以及其他我没用过的所有要求只有一个对象的场景。</li>
</ul>
<p><strong>单例模式注意事项：</strong></p>
<ul>
<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>
<li>不要做断开单例类对象与类中静态引用的危险操作。</li>
<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>
</ul>
<p>关于java中单例模式的一些争议：</p>
<p><strong>单例模式的对象长时间不用会被jvm垃圾收集器收集吗</strong></p>
<ul>
<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>
<li>不要做断开单例类对象与类中静态引用的危险操作。</li>
<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>
</ul>
<p>关于java中单例模式的一些争议：</p>
<p><strong>单例模式的对象长时间不用会被jvm垃圾收集器收集吗</strong></p>
<ul>
<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>
<li>不要做断开单例类对象与类中静态引用的危险操作。</li>
<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>
</ul>
<p>关于java中单例模式的一些争议：</p>
<ul>
<li>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</li>
<li>不要做断开单例类对象与类中静态引用的危险操作。</li>
<li>多线程使用单例使用共享资源时，注意线程安全问题。</li>
</ul>
<p><strong>单例模式的对象长时间不用会被jvm垃圾收集器收集吗</strong></p>
<p>​    看到不少资料中说：如果一个单例对象在内存中长久不用，会被jvm认为是一个垃圾，在执行垃圾收集的时候会被清理掉。对此这个说法，笔者持怀疑态度，笔者本人的观点是：<strong>在hotspot虚拟机1.6版本中，除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。</strong></p>
<p><strong>在一个jvm中会出现多个单例吗</strong></p>
<p>​    在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(Singleton.class.getName());</span><br><span class="line">Constructor ct = c.getDeclaredConstructor();</span><br><span class="line">ct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure>

<p>这样每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p>
<p><strong>懒汉式单例线程安全吗</strong></p>
<p>懒汉式的单例模式是线程不安全的，即使是在实例化对象的方法上加<strong>synchronized</strong>关键字，也依然是危险的，但是笔者经过编码测试，发现加<strong>synchronized</strong>关键字修饰后，虽然对性能有部分影响，但是却是线程安全的，并不会产生实例化多个对象的情况。</p>
<p><strong>单例类可以被继承吗</strong></p>
<p>​    饿汉式单例和懒汉式单例由于构造方法是private的，所以他们都是不可继承的，但是其他很多单例模式是可以继承的，例如登记式单例。</p>
<p><strong>饿汉式单例好还是懒汉式单例好</strong></p>
<p>​    在java中，饿汉式单例要优于懒汉式单例。C++中则一般使用懒汉式单例。饿汉式是类一加载就实例化对象，所以要提前占用系统资源。然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。</p>
<h2 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h2><p><strong>定义：</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116171957986.png" alt="image-20201116171957986"></p>
<p><strong>工厂方法模式代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;产品&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Product();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">		IProduct prodect = factory.createProduct();</span><br><span class="line">		prodect.productMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂模式：</strong></p>
<p>​    首先需要说一下工厂模式。工厂模式根据抽象程度的不同分为三种：简单工厂模式（也叫静态工厂模式）、本文所讲述的<strong>工厂方法模式</strong>、以及抽象工厂模式。工厂模式是编程中经常用到的一种模式。它的主要优点有：</p>
<ul>
<li>可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。</li>
<li>对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。</li>
<li>降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。</li>
</ul>
<p><strong>工厂方法模式：</strong></p>
<p>​    工厂接口：工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际编程中，有时候也会使用一个抽象类来作为与调用者交互的接口，其本质上是一样的。</p>
<p>​    工厂实现。在编程中，工厂实现决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现。</p>
<p>​    产品接口。产品接口的主要目的是定义产品的规范，所有的产品都必须遵循产品接口定义的规范。产品接口是调用者最为关心的，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但要注意最好不要违反里氏替换原则。</p>
<p>​    产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。</p>
<p><strong>适用场景：</strong></p>
<p>首先，作为一种创建类模式，在任何需要生成<strong>复杂对象</strong>的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<p>​    其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。</p>
<p>​    再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。</p>
<p><strong>典型应用：</strong></p>
<p>要说明工厂模式的优点，可能没有比组装汽车更合适的例子了。场景是这样的：汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。假如不使用工厂模式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是汽车的发动机&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Underpan</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是汽车的底盘&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStyle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是汽车的轮胎&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">		Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">		Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">		ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">		car.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用者为了组装汽车还需要另外实例化发动机、底盘和轮胎，而这些汽车的组件是与调用者无关的，严重违反了迪米特法则，耦合度太高。并且非常不利于扩展。另外，本例中发动机、底盘和轮胎还是比较具体的，在实际应用中，可能这些产品的组件也都是抽象的，调用者根本不知道怎样组装产品。假如使用工厂方法的话，整个架构就显得清晰了许多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ICar <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">		Underpan underpan = <span class="keyword">new</span> Underpan();</span><br><span class="line">		Wheel wheel = <span class="keyword">new</span> Wheel();</span><br><span class="line">		ICar car = <span class="keyword">new</span> Car(underpan, wheel, engine);</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">		ICar car = factory.createCar();</span><br><span class="line">		car.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用工厂方法后，调用端的耦合度大大降低了。并且对于工厂来说，是可以扩展的，以后如果想组装其他的汽车，只需要再增加一个工厂类的实现就可以。无论是灵活性还是稳定性都得到了极大的提高。</p>
<h2 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h2><p><strong>定义：</strong>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201117101041833.png" alt="image-20201117101041833"></p>
<p><strong>抽象工厂模式与工厂方法模式的区别：</strong></p>
<p>​    抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>
<p>​    在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201117101644820.png" alt="image-20201117101644820"></p>
<p>在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。</p>
<p>明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。</p>
<p><strong>抽象工厂模式代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProduct1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProduct2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">implements</span> <span class="title">IProduct1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是1型产品&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">implements</span> <span class="title">IProduct2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是2型产品&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct1 <span class="title">createProduct1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct2 <span class="title">createProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> IProduct2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Product2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		IFactory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">		factory.createProduct1().show();</span><br><span class="line">		factory.createProduct2().show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂模式的优点：</strong></p>
<p>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一把或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p>
<p><strong>抽象工厂模式的缺点：</strong></p>
<p>​    产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</p>
<p><strong>适用场景：</strong></p>
<p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p>
<p><strong>总结：</strong></p>
<p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p>
<h2 id="4、建造者模式"><a href="#4、建造者模式" class="headerlink" title="4、建造者模式"></a>4、建造者模式</h2><p><strong>定义：</strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>类型：</strong>创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116114608546.png" alt="image-20201116114608546"></p>
<p><strong>四个要素：</strong></p>
<p>​    <strong>产品类：</strong>一般是一个较为负责的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。</p>
<p>​    <strong>抽象建造者：</strong>引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展，一般有两个抽象方法，一个用来建造产品，一个是用来返回产品。</p>
<p>​    <strong>建造者：</strong>实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</p>
<p>​    <strong>导演类：</strong>负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String type;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;名称：&quot;</span>+name);</span><br><span class="line">		System.out.println(<span class="string">&quot;型号：&quot;</span>+type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">(String arg1, String arg2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> product;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">		product.setName(arg1);</span><br><span class="line">		product.setType(arg2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		builder.setPart(<span class="string">&quot;宝马汽车&quot;</span>,<span class="string">&quot;X7&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> builder.getProduct();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">getBProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		builder.setPart(<span class="string">&quot;奥迪汽车&quot;</span>,<span class="string">&quot;Q5&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> builder.getProduct();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Director director = <span class="keyword">new</span> Director();</span><br><span class="line">		Product product1 = director.getAProduct();</span><br><span class="line">		product1.showProduct();</span><br><span class="line"> </span><br><span class="line">		Product product2 = director.getBProduct();</span><br><span class="line">		product2.showProduct();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建造者模式的有点</strong></p>
<p>​    首先，建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。</p>
<p>​    其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>
<p><strong>建造者模式与工厂模式的区别</strong></p>
<p>​    我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</p>
<p>​    与工厂模式相比，建造者模式一般用来创建<strong>更为复杂的对象</strong>，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>
<p><strong>总结</strong></p>
<p>​    建造者模式与工厂模式类似，他们都是建造者模式，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。</p>
<h2 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h2><p><strong>定义：</strong></p>
<p>​    用原型实例指定创建对象的终类，并通过拷贝这些原型创建新的对象。</p>
<p><strong>类型：</strong></p>
<p>​    创建类模式</p>
<p><strong>类图：</strong></p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201117102923155.png" alt="image-20201117102923155"></p>
<p>原型模式主要用于对象的复制，它的核心就是类图中的原型类Prototype。Prototype类需要以下两个条件：</p>
<p>​    实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</p>
<p>​    重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</p>
<p>​    原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			prototype = (Prototype)<span class="keyword">super</span>.clone();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> prototype; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;原型模式实现类&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			ConcretePrototype clonecp = (ConcretePrototype)cp.clone();</span><br><span class="line">			clonecp.show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原型模式的优点及适用场景：</strong></p>
<p>​    使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p>
<p>​    使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。</p>
<p>​    因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p>
<p><strong>原型模式的注意事项：</strong></p>
<ul>
<li><p>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</p>
</li>
<li><p>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			prototype = (Prototype)<span class="keyword">super</span>.clone();</span><br><span class="line">			prototype.list = (ArrayList) <span class="keyword">this</span>.list.clone();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> prototype; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ArrayList不是基本类型，所以成员变量list，不会被拷贝，需要我们自己实现深拷贝，幸运的是java提供的大部分容器类都实现了Cloneable接口，所以实现深拷贝并不是特别困难。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/07/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">六大原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-07 10:56:47 / 修改时间：10:57:44" itemprop="dateCreated datePublished" datetime="2020-12-07T10:56:47+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><p><strong>定义</strong>：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<p><strong>问题由来：</strong>类T负责两个不同的职责，职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。  </p>
<p><strong>解决方案：</strong>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。  </p>
<p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。<strong>所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。</strong></p>
<p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）  </p>
<p>举例说明，用一个类描述动物呼吸这个场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气</p>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p>
<pre><code>class Terrestrial&#123;
public void breathe(String animal)&#123;
    System.out.println(animal+&quot;呼吸空气&quot;);
    &#125;
&#125;    
class Aquatic&#123;
    public void breathe(String animal)&#123;
        System.out.println(animal+&quot;呼吸水&quot;);
    &#125;
&#125;
public class Client&#123;
    public static void main(String[] args)&#123;
        Terrestrial terrestrial = new Terrestrial();
        terrestrial.breathe(&quot;牛&quot;);
        terrestrial.breathe(&quot;羊&quot;);
        terrestrial.breathe(&quot;猪&quot;);
    Aquatic aquatic = new Aquatic();
    aquatic.breathe(&quot;鱼&quot;);
    &#125;
&#125;</code></pre>
<p>运行结果：</p>
<p>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气<br>鱼呼吸水</p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;鱼&quot;</span>.equals(animal))&#123;</span><br><span class="line">			System.out.println(animal+<span class="string">&quot;呼吸水&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸空气&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">		System.out.println(animal+<span class="string">&quot;呼吸水&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">		animal.breathe(<span class="string">&quot;牛&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;羊&quot;</span>);</span><br><span class="line">		animal.breathe(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line">		animal.breathe2(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>​     例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<p>遵循单一职责原的优点有：</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>​     需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
<h2 id="2、里氏替换原则"><a href="#2、里氏替换原则" class="headerlink" title="2、里氏替换原则"></a>2、里氏替换原则</h2><p><strong>定义：</strong>如果对每一个类型为T1的对象o1，都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>
<p><strong>定义2：</strong>所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p><strong>问题由来：</strong>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p><strong>解决方案：</strong>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。  </p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a-b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100-80=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>100-50=50<br>100-80=20</p>
<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p>
<p>​    两数相减</p>
<p>​    两数相加，然后再加100</p>
<p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100-80=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;100+20+100=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类B完成后，运行结果：</p>
<p>100-50=150<br>100-80=180<br>100+20+100=220</p>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>它包含以下4层含义:</p>
<p>​    子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p>
<p>​    子类中可以增加自己特有的方法。</p>
<p>​    当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p>
<p>​    当子类的方法实现父类的抽象方法时，方法的后置条件要比父类更严格。</p>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p>
<p>​    后果就是：**<em>你写的代码出问题的几率将会大大增加。**</em>  </p>
<h2 id="3、依赖倒置原则"><a href="#3、依赖倒置原则" class="headerlink" title="3、依赖倒置原则"></a>3、依赖倒置原则</h2><p><strong>定义：</strong>高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
<p><strong>问题由来：</strong>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是底层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<p><strong>解决方案：</strong>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p>​    依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是<strong>面向接口编程，</strong>我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;很久很久以前有一个阿拉伯的故事……&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);</span><br><span class="line">		System.out.println(book.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">		mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……</p>
<p> 运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;林书豪38+7领导尼克斯击败湖人……&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;林书豪17+9助尼克斯击败老鹰……&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;很久很久以前有一个阿拉伯的故事……&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;妈妈开始讲故事&quot;</span>);</span><br><span class="line">		System.out.println(reader.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">		mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">		mother.narrate(<span class="keyword">new</span> Newspaper());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……</p>
<p>这样修改后，无论怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递。</p>
<p>在实际编程中，我们一般需要做到如下三点：</p>
<p>​    低层模块尽量都要有抽象类或接口，或者两者都有。</p>
<p>​    变量的声明类型尽量是抽象类或接口。</p>
<p>​    使用继承时遵循里氏替换原则。</p>
<p>依赖倒置原则的核心就是要我们<strong>面向接口编程</strong>，理解了面向接口编程，也就理解了面向接口编程。</p>
<h2 id="4、接口隔离原则"><a href="#4、接口隔离原则" class="headerlink" title="4、接口隔离原则"></a>4、接口隔离原则</h2><p><strong>定义:</strong> 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p><strong>问题由来：</strong>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
<p><strong>解决方案：</strong>将臃肿的接口I产分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离的原则。</p>
<p>举例来说明接口隔离原则：</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116110332520.png" alt="image-20201116110332520"></p>
<p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I的方法1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I的方法2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I的方法3&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">	<span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I的方法1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">	<span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I的方法4&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I的方法5&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.depend1(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend3(<span class="keyword">new</span> B());</span><br><span class="line">		</span><br><span class="line">		C c = <span class="keyword">new</span> C();</span><br><span class="line">		c.depend1(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend2(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend3(<span class="keyword">new</span> D());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116110623007.png" alt="image-20201116110623007"></p>
<p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I1的方法1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I2的方法2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类B实现接口I2的方法3&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I1的方法1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I3的方法4&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;类D实现接口I3的方法5&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>   采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>
<h2 id="5、迪米特法则"><a href="#5、迪米特法则" class="headerlink" title="5、迪米特法则"></a>5、迪米特法则</h2><p><strong>定义：</strong>一个对象应该对其他对象保持最少的了解。</p>
<p><strong>问题由来：</strong> 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><strong>解决方案：</strong>尽量降低类与类之间的耦合。</p>
<p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
<p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：<strong>只与直接的朋友通信。</strong>首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为<strong>直接的朋友</strong>，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line">			<span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">&quot;分公司&quot;</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			<span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">&quot;总公司&quot;</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(SubEmployee e:list1)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		CompanyManager e = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">		e.printAllEmployee(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line">			<span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">&quot;分公司&quot;</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(SubEmployee e:list)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			<span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">			emp.setId(<span class="string">&quot;总公司&quot;</span>+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		<span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>​    迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h2 id="6、开闭原则"><a href="#6、开闭原则" class="headerlink" title="6、开闭原则"></a>6、开闭原则</h2><p><strong>定义：</strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p><strong>问题由来：</strong>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试</p>
<p><strong>解决方案：</strong>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>开闭原则无非就是想表达这样一层意思：<strong>用抽象构建框架，用实现扩展细节。</strong>因为抽象灵活性好，始应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们<strong>用抽象构建框架，用实现扩展细节</strong>的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116112329856.png" alt="image-20201116112329856"></p>
<p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形</p>
<p><img src="C:\Users\GCC\AppData\Roaming\Typora\typora-user-images\image-20201116112419572.png" alt="image-20201116112419572"></p>
<p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
