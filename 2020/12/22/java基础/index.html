<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="使用断言断言(Assertion)是一种调试程序的方式。在java中，使用assert关键字来实现断言。 先看一个栗子： 12345public static void main(String[] args)&amp;#123;    double x&#x3D;Math.abs(-123.45);    assert x&gt;&#x3D;0;    System.out.println(x);&amp;#125;  语句asse">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="http://example.com/2020/12/22/java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Laplace">
<meta property="og:description" content="使用断言断言(Assertion)是一种调试程序的方式。在java中，使用assert关键字来实现断言。 先看一个栗子： 12345public static void main(String[] args)&amp;#123;    double x&#x3D;Math.abs(-123.45);    assert x&gt;&#x3D;0;    System.out.println(x);&amp;#125;  语句asse">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNSVBRiVCOSVFOCVCMSVBMSVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/hi5stk9uie.jpeg?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/smkgdpetms.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/y5i0asgeto.png?imageView2/2/w/1620">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-5086501/a254wlyyrw.png?imageView2/2/w/1620">
<meta property="article:published_time" content="2020-12-22T02:43:53.000Z">
<meta property="article:modified_time" content="2021-03-25T02:40:46.069Z">
<meta property="article:author" content="GCC">
<meta property="article:tag" content="java相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png">

<link rel="canonical" href="http://example.com/2020/12/22/java%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java基础 | Laplace</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Laplace</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/22/java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/test.jpg">
      <meta itemprop="name" content="GCC">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laplace">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-22 10:43:53" itemprop="dateCreated datePublished" datetime="2020-12-22T10:43:53+08:00">2020-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 10:40:46" itemprop="dateModified" datetime="2021-03-25T10:40:46+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><p>断言(Assertion)是一种调试程序的方式。在java中，使用<code>assert</code>关键字来实现断言。</p>
<p>先看一个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x=Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x&gt;=<span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句<code>assert x&gt;=0;</code>即为断言，断言条件<code>x&gt;=0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>
<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x&gt;=<span class="number">0</span> : <span class="string">&quot;x must &gt;=0 &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;=0</code>,更加便于调试。</p>
<p>java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p>
<p>对于可恢复的程序错误，不应该使用断言。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr!=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该抛出异常并在上层捕获：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在程序中使用<code>assert</code>时，例如，一个简单的断言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//assert</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x&gt;<span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动给忽略了，不执行。</p>
<p>要执行<code>assert</code>语句，必须给java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>还可以有选择地对特定类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言。</p>
<p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNSVBRiVCOSVFOCVCMSVBMSVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png" alt="IO-操作对象分类"></p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><p><strong>同步、异步，阻塞与非阻塞：</strong></p>
<ul>
<li>同步：一个任务的完成之前不能做其他操作，必须等待。</li>
<li>异步：一个任务的完成之前，可以进行其他操作</li>
<li>阻塞：是相对于CPU来说，挂起当前线程，不能做其他操作只能等待</li>
<li>非阻塞：无须挂起当前线程，可以去执行其他操作。</li>
</ul>
<p>简答：</p>
<ul>
<li>BIO：Block IO同步阻塞式IO，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，没处理完之前此线程不能做其他操作，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO同步非阻塞IO，是传统IO的升级，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮循到连接有IO请求时才启动一个线程进行处理。客户端和服务器端通过Channel(通道)通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非堵塞IO，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，异步IO的操作基于事件和回调机制。</li>
</ul>
<p><strong>NIO相比BIO的优势</strong>：NIO（Non-Blocking IO，在java领域，也称为New I/O）,是一种同步非阻塞的/IO模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620" alt="img"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/42z7tewis8.png?imageView2/2/w/1620" alt="img"></p>
<p><strong>面向流与面向缓冲</strong></p>
<p>Java NIO和BIO之间第一个最大的区别是，BIO是面向流的，NIO是面向缓冲区的。javaIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲读取方法略有不同。数据读取到一个缓冲区，需要时可在缓冲区前后移动。这就增加了处理过程中的灵活性。但是还需要检查是否该缓冲区中包含所有需要处理的数据，而且需确保更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p><strong>阻塞IO与非阻塞IO</strong></p>
<p>java IO的各种流是阻塞的。这意味着，当一个线程调用read()或write时，该线程被阻塞，直到有数据被读取或者数据写入。该线程在阻塞期间不能做其他事情。而java NIO的非阻塞模式，如果通道没有东西可读，或不可写，读写函数马上返回，而不会阻塞，这个线程可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程可以管理多个输入和输出通道（channel），即IO多路复用的原理。</p>
<p><strong>零拷贝</strong></p>
<p>在传统的文件IO操作中，我们都是调用操作系统提供的底层标准IO系统调用函数read()、write() ，此时调用此函数的进程（在JAVA中即java进程）由当前的用户态切换到内核态，然后OS的内核代码负责将相应的文件数据读取到内核的IO缓冲区，然后再把数据从内核IO缓冲区拷贝到进程的私有地址空间中去，这样便完成了一次IO操作。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/hi5stk9uie.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>而NIO的零拷贝与传统的文件IO操作最大的不同之处就在于它虽然也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，这样直接从内存中读写文件，速度大幅度提升。</p>
<p><strong>NIO的核心部分</strong></p>
<p>java NIO主要由以下三个核心部分组成：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p><strong>Channel</strong></p>
<p>基本上，所有的IO在NIO中都从一个Channel开始。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。这里有个图示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/smkgdpetms.png?imageView2/2/w/1620" alt="img"></p>
<p>Channel和Buffer有好几种类型。下面是Java NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel(file)</li>
<li>DatagramChannel(UDP)</li>
<li>SocketChannel(TCP)</li>
<li>ServerSocketChannel(TCP)</li>
</ul>
<p><strong>Buffer</strong></p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte、short、int、long、float、double和char。</p>
<p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/y5i0asgeto.png?imageView2/2/w/1620" alt="img"></p>
<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>作为一个内存块，Buffer有个固定的最大值，就是capacity。Buffer只能写capacity个byte、long、char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>当写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>在写模式下，Buffer的limit表示最多能往Buffer里写多少数据。写模式下，limit等于capacity。</p>
<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</p>
<p><strong>Selector</strong></p>
<p>Selector允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/a254wlyyrw.png?imageView2/2/w/1620" alt="img"></p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事情，事件例如有新连接进来，数据接收等。</p>
<p><strong>NIO与epoll的关系</strong></p>
<p><strong>NIO处理消息的核心思路</strong></p>
<p>结合示例代码，总结NIO的核心思路：</p>
<ol>
<li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面例子中serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读</li>
<li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上，这样就不用BIO模型中1w 个while循环在阻塞，参见(1)</li>
<li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过clientSelector.select(1)方法可以轮询出来，进而批量处理，参见(2)</li>
<li>数据的读写面向 Buffer，参见(3)</li>
</ol>
<p><strong>同步与异步</strong></p>
<ul>
<li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li>异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<p>同步和异步的区别最大在于异步的话，调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p>举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</p>
<p>详细回答：</p>
<ul>
<li>BIO（Blocking IO）:同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li>NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li>优点：运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li>缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制</p>
<p>2.通过路径实现反射机制</p>
<p>3.通过类名实现反射机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        Class classobj3 = Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><p>1.形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符</p>
<p>2.含义上：字符常量相当于一个整形值，可以参加表达式运算，字符串常量代表一个地址值</p>
<p>3.占内存大小：字符常量只占一个字节，字符串常量占若干个字节。</p>
<h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
<h3 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h3><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};</p>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
<h3 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h3><p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>
<p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>
<p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>
<h3 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h3><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<p><strong>1、String不可变但不代表引用不可变</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span> + str);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=Hello World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<p><strong>2、通过反射可以修改所谓的“不可变”对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h3 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h3><p>String 类是 final 类，不可以被继承。</p>
<h3 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h3><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h3 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h3><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h3><p>使用StringBuilder或者StringBuffer的reverse()方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h3 id="数组有没有length-方法？String有没有length-方法"><a href="#数组有没有length-方法？String有没有length-方法" class="headerlink" title="数组有没有length()方法？String有没有length()方法"></a>数组有没有length()方法？String有没有length()方法</h3><p>数组没有length()方法，有length的属性。String有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和java混淆。</p>
<h3 id="String类的常用方法都有哪些？"><a href="#String类的常用方法都有哪些？" class="headerlink" title="String类的常用方法都有哪些？"></a>String类的常用方法都有哪些？</h3><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>
<h3 id="在使用HashMap的时候，用String做key有什么好处？"><a href="#在使用HashMap的时候，用String做key有什么好处？" class="headerlink" title="在使用HashMap的时候，用String做key有什么好处？"></a>在使用HashMap的时候，用String做key有什么好处？</h3><p>HashMap内部实现是通过key的hashCode来确定value的存储位置，因为字符串是不可变的，所以当创建字符串时，它的hashCode被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h3 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h3><p><strong>可变性</strong></p>
<p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数据保存字符串，char[] value，这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。<br><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用string</p>
<p>单线程操作字符串缓冲区下操作大量数据StringBuilder</p>
<p>多线程操作字符串缓冲区下操作大量数据StringBuffer</p>
<h2 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h2><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p><strong>装箱：将基本类型用它们对应的引用类型包装起来</strong></p>
<p><strong>拆箱：</strong>将包装类型转换为基本数据类型；</p>
<h3 id="int和Integer有什么区别"><a href="#int和Integer有什么区别" class="headerlink" title="int和Integer有什么区别"></a>int和Integer有什么区别</h3><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<h3 id="Integer-a-127与Integer-b-127相等吗"><a href="#Integer-a-127与Integer-b-127相等吗" class="headerlink" title="Integer a =127与Integer b=127相等吗"></a>Integer a =127与Integer b=127相等吗</h3><p>对于对象引用类型：==比较的是对象的内存地址</p>
<p>对于基本数据类型：==比较的是值</p>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围a1==b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer b = <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer a1 = <span class="number">128</span>;</span><br><span class="line">    Integer b1 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    Integer a2 = <span class="number">127</span>;</span><br><span class="line">    Integer b2 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>transient关键字</strong></p>
<p>用来表示一个成员变量不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。而非transient型的变量是被包括进去的。static修饰的静态变量天然是不可序列化的。</p>
<p><strong>JVM出现OOM的原因分析</strong></p>
<p><strong>堆溢出</strong>:java.lang.OutOfMemoryError: Java heap space</p>
<p>可能存在大对象分配；可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</p>
<p>检查是否存在大对象的分配，最有可能的是大数组分配；</p>
<p>通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄漏的问题</p>
<p>如果没有找到明显的内存泄露，使用 -Xmx 加大堆内存</p>
<p>还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性</p>
<p><strong>永久代/元空间溢出</strong>：PermGen spacejava.lang.OutOfMemoryError: Metaspace</p>
<p>1、在Java7之前，频繁的错误使用String.intern()方法 2、运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载 3、应用长时间运行，没有重启</p>
<p>1、检查是否永久代空间或者元空间设置的过小 2、检查代码中是否存在大量的反射操作 3、dump之后通过mat检查是否存在大量由于反射生成的代理类 4、放大招，重启JVM</p>
<p><strong>GC overhead limit exceeded</strong>：GC overhead limit exceeded</p>
<p>一般都是堆太小导致的。</p>
<p>检查项目中是否有大量的死循环或有使用大内存的代码</p>
<p>dump内存，检查是否存在内存泄漏，如果没有，加大内存</p>
<p><strong>方法栈溢出：</strong>unable to create new native Thread</p>
<p>创建了大量的线程导致的。</p>
<p>通过 -Xss 降低的每个线程栈大小的容量 </p>
<p>线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：</p>
<p><strong>非常规溢出</strong></p>
<p>分配超大数组：Requested array size exceeds VM limit</p>
<p>swap溢出：Out of swap space</p>
<p>原因：swap分区大小分配不足；其他进程消耗了所有的内存</p>
<p>解决方案：其他服务进程可以选择性的拆分出去；加大swap分区大小，或者加大机器内存大小</p>
<p>本地方法溢出：stack_trace_with_native_method</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E7%9B%B8%E5%85%B3/" rel="tag"># java相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/22/JDBC%E5%9F%BA%E7%A1%80/" rel="prev" title="JDBC基础">
      <i class="fa fa-chevron-left"></i> JDBC基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/22/spring%E6%BA%90%E7%A0%81/" rel="next" title="spring源码">
      spring源码 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">使用断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="nav-number">2.1.</span> <span class="nav-text">java 中 IO 流分为几种?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-NIO-AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">BIO,NIO,AIO 有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#capacity"><span class="nav-number">2.3.</span> <span class="nav-text">capacity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position"><span class="nav-number">2.4.</span> <span class="nav-text">position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#limit"><span class="nav-number">2.5.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">Files的常用方法都有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">什么是反射机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.2.</span> <span class="nav-text">反射机制优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">反射机制的应用场景有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">Java获取反射的三种方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%9B%B8%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">String相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">字符型常量和字符串常量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">什么是字符串常量池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E6%98%AF%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97"><span class="nav-number">4.3.</span> <span class="nav-text">String是最基本的数据类型吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="nav-number">4.4.</span> <span class="nav-text">String有哪些特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">4.5.</span> <span class="nav-text">String为什么是不可变的吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">4.5.1.</span> <span class="nav-text">String真的是不可变的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF-String-%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text">是否可以继承 String 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-str-%E2%80%9Di%E2%80%9D%E4%B8%8E-String-str-new-String-%E2%80%9Ci%E2%80%9D-%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="nav-number">4.7.</span> <span class="nav-text">String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.8.</span> <span class="nav-text">String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="nav-number">4.9.</span> <span class="nav-text">如何将字符串反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9FString%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95"><span class="nav-number">4.10.</span> <span class="nav-text">数组有没有length()方法？String有没有length()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">4.11.</span> <span class="nav-text">String类的常用方法都有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8HashMap%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%94%A8String%E5%81%9Akey%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">4.12.</span> <span class="nav-text">在使用HashMap的时候，用String做key有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%92%8CStringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">4.13.</span> <span class="nav-text">String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">Date相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="nav-number">5.1.</span> <span class="nav-text">包装类相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-number">5.1.1.</span> <span class="nav-text">自动装箱与拆箱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int%E5%92%8CInteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">int和Integer有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer-a-127%E4%B8%8EInteger-b-127%E7%9B%B8%E7%AD%89%E5%90%97"><span class="nav-number">5.3.</span> <span class="nav-text">Integer a &#x3D;127与Integer b&#x3D;127相等吗</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GCC"
      src="/images/test.jpg">
  <p class="site-author-name" itemprop="name">GCC</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GuanChenJY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GuanChenJY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:303163861@qq.com" title="E-Mail → mailto:303163861@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GCC</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
